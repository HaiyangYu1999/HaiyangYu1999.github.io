<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java接口和抽象类的异同</title>
    <url>/2020/11/12/JavaSE/InterfaceAndAbstractClass/</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p><strong>“java接口和抽象类的异同”这个题绝对是java面试中基础的, 高频的问题. 之前零零散散的复习过很多关于接口和抽象类讲解的文章, 但是没有系统的自己整理下来. 导致知识体系不全面并且很容易忘. 这次花点时间全面的分析一下两者的异同.</strong></p>
<a id="more"></a>

<h2 id="1-概念上的异同"><a href="#1-概念上的异同" class="headerlink" title="1. 概念上的异同"></a>1. 概念上的异同</h2><p>从设计理念上来说,</p>
<ul>
<li><p>两者都是对一些类的某些共同的特征的抽象. </p>
</li>
<li><p>接口是对动作的抽象, 抽象类是对根源的抽象. </p>
</li>
<li><p><strong>接口的设计目的, 是对类的行为进行约束, 可以强制要求不同的类具有相同的行为. 而抽象类的设计目的是代码复用.</strong> (摘自知乎的一句话, 个人认为总结的很好)</p>
<p>例如这个函数<code>public void putAll(Map&lt;? extends K, ? extends V&gt; m)</code>就通过接口Map<strong>强制要求传入的参数必须有Map接口Map定义的所有行为(所有方法).</strong> </p>
<p>对于抽象类<code>AbstractMap</code>, 因为对于任何映射来说, 有很多操作是相同的. 比如<code>get()</code>, <code>remove()</code>等方法. 所以如果继承这个类, 新的<code>AbstractMap</code>实现类就只需要关注新的类特有的一些结构和操作. 而不需要关注所有实现类都相同的方法了.</p>
</li>
</ul>
<h2 id="2-语法上的异同"><a href="#2-语法上的异同" class="headerlink" title="2. 语法上的异同"></a>2. 语法上的异同</h2><p>语法上来说, 抽象类和接口真的就是相同的地方寥寥无几了. </p>
<p>首先看一下抽象类和接口相比于普通类在语法上有哪些特点. </p>
<h3 id="2-1-抽象类"><a href="#2-1-抽象类" class="headerlink" title="2.1 抽象类"></a>2.1 抽象类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java abstract class test based on jdk 11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Haiyang Yu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractC</span>             // <span class="title">abstract</span> <span class="title">class</span> <span class="title">modifier</span> <span class="title">cannot</span> <span class="title">be</span> <span class="title">final</span></span></span><br><span class="line">                                            // modifier &quot;abstract&quot; cannot be omitted</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// all modifiers are allowed on a field</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> e = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> g = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//allow all constructors</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractC</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractC</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;;&#125;</span><br><span class="line">    AbstractC(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)&#123;;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AbstractC</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all regular methods are allowed</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f5</span><span class="params">()</span></span>&#123;;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">f6</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f7</span><span class="params">()</span></span>&#123;;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f8</span><span class="params">()</span></span>&#123;;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// abstract method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractF1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractF2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractF3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//private abstract void abstractF4();   // private cannot decorate the abstract method</span></span><br><span class="line">    <span class="comment">//public native abstract void abstractF5();  // native cannot decorate the abstract method</span></span><br><span class="line">    <span class="comment">//public static abstract void abstractF6();   // static cannot decorate the abstract method</span></span><br><span class="line">    <span class="comment">//public synchronized abstract void abstractF7();   // synchronized cannot decorate the abstract method</span></span><br><span class="line">    <span class="comment">//public static synchronized abstract void abstractF8();  // static synchronized cannot decorate the abstract method</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上面的注释可以看到, <strong>抽象类和普通类只有2点区别</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 类修饰符. 不能是final, 并且abstract修饰符不能被省略.</span><br><span class="line">2. 抽象方法. 普通类不能有抽象方法, 抽象类可以有被abstract修饰的抽象方法. 但是要注意, abstract不能和修饰符private, native, static, synchronized一起使用</span><br></pre></td></tr></table></figure>

<p><strong>除此之外,  成员变量, 构造器, 非抽象方法与普通类没有区别.</strong></p>
<h3 id="2-2-接口"><a href="#2-2-接口" class="headerlink" title="2.2 接口"></a>2.2 接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java Interface Test based on jdk 11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Haiyang Yu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">In</span>             // <span class="title">interface</span> <span class="title">modifier</span> <span class="title">cannot</span> <span class="title">be</span> <span class="title">final</span></span></span><br><span class="line"><span class="class"></span>&#123;                                        <span class="comment">// interface modifier is always abstract</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">// interface field is always public static final</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//private int b = 1; //interface field cannot be private neither protected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//public In()&#123;;&#125;   //cannot have public constructors</span></span><br><span class="line">    <span class="comment">//private In()&#123;;&#125;  //cannot have private constructors</span></span><br><span class="line">    <span class="comment">//protected In()&#123;;&#125; //cannot have protected constructors</span></span><br><span class="line">    <span class="comment">//In()&#123;;&#125;            //cannot have default constructors</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractF1</span><span class="params">()</span></span>;   <span class="comment">// regular abstract method is always public and abstract by default</span></span><br><span class="line">    <span class="comment">//private void abstractF2();  // private abstract method is not allowed</span></span><br><span class="line">    <span class="comment">//protected void abstractF3();// protected abstract method is not allowed</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">abstractF4</span><span class="params">()</span></span>;          <span class="comment">// equivalent to public void abstractF4();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//public void f1() &#123;;&#125;  //cannot have regular method, default modifier required</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;;&#125;   <span class="comment">// default method is always public</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;;&#125;           <span class="comment">// private method is allowed since jdk1.9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticF1</span><span class="params">()</span> </span>&#123;;&#125;          <span class="comment">//static method is allowed since jdk1.8</span></span><br><span class="line">                                               <span class="comment">// static method is public by default</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticF2</span><span class="params">()</span> </span>&#123;;&#125;         <span class="comment">// private static method is allowed since jdk1.9</span></span><br><span class="line">    <span class="comment">//protected static void staticF3() &#123;;&#125;     // private static method is not allowed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>接口与普通类的差别就非常大了. 可以说是几乎没有什么共同点.</strong></p>
<p>我们从类修饰符, 成员变量, 构造器, 普通方法, 抽象方法 这5个角度来分析.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 类修饰符 接口的修饰符不能是final, 默认是abstract修饰. 所以不写abstract也可以.</span><br><span class="line">2. 成员变量 接口中的成员变量默认是public static final修饰的. 不能含有protected, private, volatile, transient修饰的变量.</span><br><span class="line">3. 构造器 接口中不能含有任何构造器</span><br><span class="line">4. 普通方法 接口在这一点是最复杂的. 因为会随着jdk版本的变化而变化</span><br><span class="line">   在jdk1.7及之前, 默认不能有普通方法的. </span><br><span class="line">   在jdk1.8中, 可以有默认的方法和默认的静态方法. 但是默认方法前面要加修饰符default. 同时, 默认方法和默认静态方法的访问控制级别是public修饰的, 不写也是public, 而不是默认的访问控制级别.</span><br><span class="line">   在jdk1.9中, 可以有私有方法和私有静态方法. 对于protected和默认的访问控制级别, 还是不允许. </span><br><span class="line">5. 抽象方法 接口中抽象方法默认是public的和abstract的. 其他的访问控制级别不允许. 普通类中不允许有抽象方法.</span><br></pre></td></tr></table></figure>

<h3 id="2-3-接口和抽象类的异同"><a href="#2-3-接口和抽象类的异同" class="headerlink" title="2.3 接口和抽象类的异同"></a>2.3 接口和抽象类的异同</h3><p>通过上面两部分的分析, 很容易得出结论了</p>
<p>我们还是从类修饰符, 成员变量, 构造器, 普通方法, 抽象方法 这5个角度来分析.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 接口和抽象类的修饰符不能是final, 必须被abstract修饰. 但是接口是默认abstract的, 可以不用写.</span><br><span class="line">2. 接口的成员变量默认是public static final的. 抽象类的成员变量和普通类一样, 没有限制</span><br><span class="line">3. 接口不能有构造器, 抽象类的构造器和普通类一样, 没有限制</span><br><span class="line">4. 接口中的普通方法只能有4种类型, default 方法, default static方法, private 方法, private static方法. 其他类型的方法不允许. 并且也不允许存在synchronized, native关键字. 其中default方法的访问控制级别默认是public的. 抽象类中的普通方法没有任何限制.</span><br><span class="line">5. 接口中的抽象方法默认带了public, abstract关键字, 所以不写也可以. 但是其他的访问级别(private, protected)是不允许的. </span><br><span class="line">抽象类的抽象方法就必须写abstract关键字了. 并且访问控制基本可以包含public, protected, 默认访问级别. 但是private的访问级别是不被允许的. 同时, abstract不能和修饰符private, native, static, synchronized一起使用.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对了, 还有个共同点, 就是这两个都不能被实例化.</span><br><span class="line">还有个点, 就是接口和类的区别, 即接口可以extends多个接口, 不能extends类. 抽象类可以extends一个类, 可以implements多个接口</span><br></pre></td></tr></table></figure>



<p>总结到这里, 感觉应付一般的面试够用了. 但是, 在学习的过程中由发现了很多新的问题, 比如, **<code>接口中能有内部类吗, 能有内部接口吗?</code>, <code>内部抽象类的特点和抽象类还一样吗?</code>,<code>内部的接口或抽象类的修饰符有哪些要求, 必须是static吗, 允许final吗?</code>**等等. 所以, 学习是一个不断的探索过程, 会的越多, 不会的越多. </p>
<p>希望每个人对学习有一颗敬畏之心, 要知道山外有山, 天外有天. 这样才能不断的进步.</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 10 Regular Expression Matching</title>
    <url>/2020/09/28/Leetcode/Leetcode%2010%20Regular%20Expression%20Matching/</url>
    <content><![CDATA[<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;.&#39; Matches any single character.</span><br><span class="line">&#39;*&#39; Matches zero or more of the preceding element.</span><br></pre></td></tr></table></figure>

<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
<p><strong>Note:</strong></p>
<ul>
<li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li>
<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>这个题我自己没想出来, 思路完全借鉴于<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/">https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/</a></p>
<p><code>dp[i][j]</code> 表示的是<code>s[0]</code>到<code>s[i-1]</code>是否与<code>p[0]</code>到<code>p[j-1]</code>是否匹配.</p>
<p>状态转移矩阵的推到就不写了, 都在上面的URL中.</p>
<p>要注意的是, 当<code>p[j-1] == &#39;*&#39;</code>时, 并且<code>(p.charAt(j-2) == s.charAt(i-1) || p.charAt(j-2) == &#39;.&#39;)</code>, 这时有两个选择, 去判断<code>dp[i-1][j]</code>和去判断<code>dp[i][j-2]</code>. 下面举例说明</p>
<blockquote>
<p><code>s = &quot;aaaa&quot;, p = &quot;c*b*a*&quot;</code> . 当检查到<code>p[5] == &#39;*&#39;</code>并且<code>p[3]== s[6] == &#39;a&#39;</code>的时候, 我们可以选择p中最后的<code>a*</code>匹配0个a, 即检查新的<code>s = &quot;aaaa&quot;, p = &quot;c*b*&quot;</code>是否匹配. 也可以选择p中最后的<code>a*</code>匹配s中最后一个a, 即检查新的<code>s = &quot;aaa&quot;, p = &quot;c*b*a*&quot;</code>是否匹配. 这两个只要有一个匹配, 那么原来的s和p也是匹配的</p>
</blockquote>
<p>同时, 要注意边界条件的判断,</p>
<ul>
<li><code>dp[0][0] = true</code>这时显然的</li>
<li><code>dp[i][0] always false</code> 也是显然的<code>(i &gt; 0)</code></li>
<li><code>dp[0][j]</code>比较难判断(*<em>关键点是只有”<code>c*b*</code>“这样的正则表达式才能匹配0个字符的字串. 不以’</em>‘结尾的正则表达式肯定不能匹配空串!**)<ul>
<li>当<code>p[j-1] != &#39;*&#39;</code>时, p要匹配含有至少1个字符的字符串. 显然是false</li>
<li>当<code>p[j-1] == &#39;*&#39;</code>时, 使用这个星号匹配0个字符, 那么就有<code>dp[0][j] = dp[0][j-2]</code>. 例如, p = “ca*”, s是空串. 首先检查p[2] 为星号, 使用这个星号匹配0个a, 那么即可检查新的p = “c”和空串是否匹配即可.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> m = s.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// dp[i][0] always false</span></span><br><span class="line">        <span class="comment">// but dp[0][j] depends, e.g. &quot;a*&quot; matches &quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; (p.charAt(j-<span class="number">2</span>) == s.charAt(i-<span class="number">1</span>) || p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == s.charAt(i-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                            dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1 Two Sum</title>
    <url>/2020/09/07/Leetcode/Leetcode%201%20Two%20Sum/</url>
    <content><![CDATA[<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly\</em></strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>



<a id="more"></a>
<h2 id="1-暴力求解"><a href="#1-暴力求解" class="headerlink" title="1. 暴力求解"></a>1. 暴力求解</h2><p>注意，最后要判断返回的下标不能相等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; <span class="built_in">size</span>; ++j)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;i,j&#125;;</span><br><span class="line">                 <span class="keyword">return</span> res;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>嵌套for 寻找nums[i] + nums[j] == target 的{i, j}. 花费O(n^2)的时间复杂度</p>
<h2 id="2-利用hashtable降低时间复杂度"><a href="#2-利用hashtable降低时间复杂度" class="headerlink" title="2. 利用hashtable降低时间复杂度"></a>2. 利用hashtable降低时间复杂度</h2><p>经分析 只需要对于每个i, 在nums中找到值为target - nums[i]的值对应的下标，可以先便利一遍vector构造hashtable，花费O(1)的复杂度查找. 总时间复杂度O(2n)</p>
<p>注意api的使用</p>
<p>insert() 接受pair对象，也可以为初始化列表{key, value}</p>
<p>find(); 接受key_type对象，返回查找结果的迭代器，若查找不到返回尾后迭代器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            mp.insert(&#123;nums[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != mp.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = it-&gt;second;</span><br><span class="line">                <span class="keyword">if</span>(i != j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-一遍hashtable"><a href="#3-一遍hashtable" class="headerlink" title="3. 一遍hashtable"></a>3. 一遍hashtable</h2><p>将2 中的算法改进，在遍历的过程中构造hashtable，这样只需要遍历一遍，但是第i个元素只能和第1, …, i-1个元素查找。返回的{i, j}一定有i &gt; j。如果有顺序要求要改正返回值。时间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            mp.insert(&#123;nums[i], i&#125;);</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != mp.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = it-&gt;second;</span><br><span class="line">                <span class="keyword">if</span>(i != j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 100 Same Tree</title>
    <url>/2020/09/30/Leetcode/Leetcode%20100%20Same%20Tree/</url>
    <content><![CDATA[<p>Given two binary trees, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归的判断即可.</p>
<p>两个树相同 =&gt; 根节点相同并且左右子树都相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span> || q == <span class="keyword">null</span> &amp;&amp; p != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val != q.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 101 Symmetric Tree</title>
    <url>/2020/09/30/Leetcode/Leetcode%20101%20Symmetric%20Tree/</url>
    <content><![CDATA[<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>



<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>



<p><strong>Follow up:</strong> Solve it both recursively and iteratively.</p>
<a id="more"></a>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><p>两个树tree1, tree2对称 =&gt; 两个树的根节点相同, 并且tree1的左子树与tree2的右子树对称, 并且tree1的右子树和tree2的左子树对称.</p>
<p>当一个树的左右子树对称时, 这个树是对称的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isTwoTreeSymmetric(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTwoTreeSymmetric</span><span class="params">(TreeNode tree1, TreeNode tree2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree1 == <span class="keyword">null</span> &amp;&amp; tree2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree1 != <span class="keyword">null</span> &amp;&amp; tree2 == <span class="keyword">null</span> || tree1 == <span class="keyword">null</span> &amp;&amp; tree2 != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tree1.val == tree2.val &amp;&amp; isTwoTreeSymmetric(tree1.left, tree2.right) &amp;&amp; isTwoTreeSymmetric(tree1.right, tree2.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2 迭代"></a>2 迭代</h2><p>这个题要利用队列.</p>
<p>首先将root.left和root.right加入到队列中,</p>
<p>然后当队列非空时, 每次从队列中取出2个指针tree1, tree2. 如果tree1.val=tree2.val, 那么就可以将tree1.left和tree2.right<strong>连续的</strong>加入队列, 在将来某个时刻这两个值也会被连续的读出, 判断tree1.left和tree2.right是不是对称的. 同理, 也需要将tree1.right和tree2.left<strong>连续的</strong>加入队列. </p>
<p>如果tree1和tree2都是null, 那可以跳过他们, 再读下一对数据.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root.left);</span><br><span class="line">        q.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode tree1 = q.poll();</span><br><span class="line">            TreeNode tree2 = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(tree1 == <span class="keyword">null</span> &amp;&amp; tree2 == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tree1 != <span class="keyword">null</span> &amp;&amp; tree2 == <span class="keyword">null</span> || tree1 == <span class="keyword">null</span> &amp;&amp; tree2 != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tree1.val != tree2.val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.offer(tree1.left);</span><br><span class="line">                    q.offer(tree2.right);</span><br><span class="line">                    q.offer(tree1.right);</span><br><span class="line">                    q.offer(tree2.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 102 Binary Tree Level Order Traversal</title>
    <url>/2020/10/05/Leetcode/Leetcode%20102%20Binary%20Tree%20Level%20Order%20Traversal/</url>
    <content><![CDATA[<p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>



<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="队列-BFS"><a href="#队列-BFS" class="headerlink" title="队列 + BFS"></a>队列 + BFS</h2><p>利用队列.</p>
<p>对于每一层的节点, 先将这一层的所有节点入队列, 并且求出这一层所有节点的个数thisLevelSize.</p>
<p>对于队列中每一个节点, 出队列这个节点, 并将非空的左右子节点入队列.</p>
<p>出队列thisLevelSize次, 这一层就遍历完了. 放入到一个list即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; llist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> llist;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> thisLevelSize = q.size();</span><br><span class="line">            List&lt;Integer&gt; thisLevelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(thisLevelSize != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode tmp = q.poll();</span><br><span class="line">                thisLevelList.add(tmp.val);</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.right);</span><br><span class="line">                --thisLevelSize;</span><br><span class="line">            &#125;</span><br><span class="line">            llist.add(thisLevelList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> llist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中Integer[], int[]和Collection&lt;Integer&gt;的相互转换</title>
    <url>/2020/11/15/JavaSE/IntegerArrayToIntArray/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>今天刷leetcode 349题的时候, 发现了一个有趣的事情. </p>
<p>原题是求两个数组的交集, <code>public int[] intersection(int[] nums1, int[] nums2)</code>. 我觉得你们应该也不会觉得这个题难. 转化为两个集合之后很简单就做出来了. 但是, 题目要求返回的是<code>int[]</code>.</p>
<p>一开始我也没当回事, 以为调用一个<code>toArray()</code>方法就可以的. 但是这种方法根本不行, 只能得到<code>Integer[]</code> 而不是<code>int[]</code>. 并且<code>Integer[]</code>没法强制转换成为<code>int[]</code>. </p>
<p>事实上, 如果我们想将一个<code>Set&lt;Integer&gt;</code>转化成<code>int[]</code>, 还是需要一番操作的.</p>
<p>首先最笨的方法就是new一个<code>int[]</code>然后逐个元素添加. 但是这种方法显得太古老了一些.</p>
<p>在网上查了一番资料之后, 找到了解决这个问题的办法, 可以实现<code>Integer[]</code>和<code>int[]</code>互转. 那就是用Java 8中新引入的特性, Stream.</p>
<a id="more"></a>

<h2 id="2-Stream"><a href="#2-Stream" class="headerlink" title="2. Stream"></a>2. Stream</h2><p>其实Stream这个引入并不是为了数据转换用的, 而是流式计算. 里面的各种方法和Spark RDD的操作方法极其一致. 可以将Java中的Stream看成Spark中的RDD. 都支持map, reduce, count, filter等各种操作. 其实这些操作也很像SQL. </p>
<p>有了Stream之后, 我们在java中就可以实现链式编程了. </p>
<p>例如, 在一个数组中打印出<strong>小于10的</strong>, <strong>偶数</strong>, <strong>降序排序的</strong>, <strong>前2个元素</strong>的<strong>平方</strong>的<strong>字符串表示</strong>. 可以这样实现, </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">Arrays.stream(a).filter((x) -&gt; x &lt; <span class="number">10</span>)</span><br><span class="line">    .filter((x) -&gt; x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    .sorted((i1, i2) -&gt; i2.compareTo(i1))</span><br><span class="line">    .limit(<span class="number">2</span>)</span><br><span class="line">    .map(i -&gt; i * i)</span><br><span class="line">    .map(String::valueOf)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="3-数组或集合转为流"><a href="#3-数组或集合转为流" class="headerlink" title="3. 数组或集合转为流"></a>3. 数组或集合转为流</h2><h3 id="3-1-集合或引用类型数组转化为流"><a href="#3-1-集合或引用类型数组转化为流" class="headerlink" title="3.1 集合或引用类型数组转化为流"></a>3.1 集合或引用类型数组转化为流</h3><p>在Java中, 每一个<strong>集合</strong>或者<strong>引用类型数组</strong>都能转化为对应的流<code>Stream&lt;?&gt;</code>. 如果是集合的话, 直接调用<code>stream()</code>方法就可以获得对应的流, 如果是引用类型数组的话, 可以使用Arrays类中的静态方法<code>Arrays.stream()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();                <span class="comment">//Collection转化为Stream&lt;?&gt;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    set.add(i);</span><br><span class="line">&#125;</span><br><span class="line">Stream&lt;Integer&gt; integerStream1 = set.stream();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers = <span class="keyword">new</span> Integer[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;     <span class="comment">//引用类型数组转化为Stream&lt;?&gt;</span></span><br><span class="line">Stream&lt;Integer&gt; integerStream2 = Arrays.stream(integers);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-基本类型数组转化为流"><a href="#3-2-基本类型数组转化为流" class="headerlink" title="3.2 基本类型数组转化为流"></a>3.2 基本类型数组转化为流</h3><p>对于<strong>基本类型数组</strong>, 转化成流也可以使用Arrays类中的静态方法<code>Arrays.stream()</code>. </p>
<p>但是要注意, 基本数据类型数组转化的流就不是<code>Stream&lt;?&gt;</code>这样的类型了. 因为<code>int</code>这样的不算一个类, 不能出现在泛型中. 但是为了避免计算的时候频繁的装箱拆箱, Java特意设置了3个基本类型流<code>IntStream</code>, <code>LongStream</code>, <code>DoubleStream</code>. </p>
<p>这样, <code>int[], long[], double[]</code>也可以转化成对应的基本类型流了. 但是要注意, 对于这3种基本类型之外的基本类型数组<code>char[], float[]</code>这样的还是没法转化成流.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;                   </span><br><span class="line">IntStream intStream = Arrays.stream(ints);         <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">CharStream = Arrays.stream(chars);                 <span class="comment">//错误, 没有CharStream这个类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们查看Arrays.stream()的各个重载方法也能发现这个结果, 即只有引用类型数组和int, long, double这三种基本类型数组才能调用Arrays.stream()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">stream</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LongStream <span class="title">stream</span><span class="params">(<span class="keyword">long</span>[] array)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleStream <span class="title">stream</span><span class="params">(<span class="keyword">double</span>[] array)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-注意点"><a href="#3-3-注意点" class="headerlink" title="3.3 注意点"></a>3.3 注意点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意: 上文说的类型Stream&lt;?&gt;, IntStream等严格来说并不是一个类型, 而是一个接口.</span></span><br><span class="line"><span class="comment">//Stream&lt;?&gt;真正的实现类是抽象类ReferencePipeline下面的一个静态内部类ReferencePipeline.Head,</span></span><br><span class="line"><span class="comment">//IntStream真正的实现类是抽象类IntPipeline下面的一个静态内部类IntPipeline.Head,</span></span><br><span class="line"><span class="comment">//LongStream, DoubleStream也有类似的实现类.</span></span><br><span class="line"><span class="comment">//但是为了下文描述方便, 仍然采用Stream&lt;?&gt;类型, IntStream类型这样的描述.</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Stream-lt-Integer-gt-和IntStream"><a href="#4-Stream-lt-Integer-gt-和IntStream" class="headerlink" title="4. Stream&lt;Integer&gt;和IntStream"></a>4. Stream&lt;Integer&gt;和IntStream</h2><p>刚才说了这么多, 我们已经拿到<code>Integer[]</code>转换的流<code>Stream&lt;Integer&gt;</code>和<code>int[]</code>转化的流<code>IntStream</code>了, 但是这两者怎么互相转化呢?</p>
<h3 id="4-1-Stream-lt-Integer-gt-转化为-IntStream"><a href="#4-1-Stream-lt-Integer-gt-转化为-IntStream" class="headerlink" title="4.1 Stream&lt;Integer&gt; 转化为 IntStream"></a>4.1 <code>Stream&lt;Integer&gt;</code> 转化为 <code>IntStream</code></h3><p>   查看类型<code>Stream</code>的源码, 发现有<code>Stream&lt;?&gt;</code>转化为<code>IntStream, LongStream, DoubleStream</code>的方法</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</span><br><span class="line"><span class="function">LongStream <span class="title">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</span><br><span class="line"><span class="function">DoubleStream <span class="title">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<p>   所以可以用这些方法实现转化. </p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream intStream2 = integerStream2.mapToInt(x -&gt; x);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-IntStream转化为Stream-lt-Integer-gt"><a href="#4-2-IntStream转化为Stream-lt-Integer-gt" class="headerlink" title="4.2 IntStream转化为Stream&lt;Integer&gt;"></a>4.2 <code>IntStream</code>转化为<code>Stream&lt;Integer&gt;</code></h3><p>   查看类<code>IntStream</code>的源码, 发现也有一个方法<code>box()</code>转化成对应的包装类.</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;Integer&gt; <span class="title">boxed</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>   所以可以用这个方法转化成包装类的流.</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integerStream3 = intStream.boxed();</span><br></pre></td></tr></table></figure>

<p>   <code>LongStream</code>转化为<code>Stream&lt;Long&gt;</code>, <code>DoubleStream</code>转化为<code>Stream&lt;Double&gt;</code>同理</p>
<h2 id="5-流转化为数组或集合"><a href="#5-流转化为数组或集合" class="headerlink" title="5. 流转化为数组或集合"></a>5. 流转化为数组或集合</h2><p>流转化为数组, 也有对应的方法. 两种流都为<code>toArray()</code>方法. 流转为集合, 为<code>collect()</code>方法.</p>
<h3 id="5-1-引用类型的流转化成数组"><a href="#5-1-引用类型的流转化成数组" class="headerlink" title="5.1 引用类型的流转化成数组"></a>5.1 引用类型的流转化成数组</h3><p>对于引用类型的流<code>Stream&lt;?&gt;</code>, 转化成数组有2种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] toArray();     <span class="comment">//无参方法, 返回Object[], 但是Object[]强制转化为Integer[]的时候会出现运行时异常, 所以一般不用</span></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);  <span class="comment">//要提供返回数组类型的构造器, 不需要强制类型转化</span></span><br></pre></td></tr></table></figure>


   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] integers3 = integerStream2.toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">Integer[] integers4 = integerStream2.toArray((i)-&gt;&#123;<span class="keyword">return</span> <span class="keyword">new</span> Integer[i];&#125;);  <span class="comment">//lambda表达式形式, 和上一行的方法引用等价</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-基本类型流转化成数组"><a href="#5-2-基本类型流转化成数组" class="headerlink" title="5.2 基本类型流转化成数组"></a>5.2 基本类型流转化成数组</h3><p>对于基本类型的流<code>IntStream</code>, 转化成数组也是用的<code>toArray()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] toArray();                            <span class="comment">//对于基本类型的流的toArray()方法, 既不用传参, 也不用强制类型转换</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ints2 = intStream.toArray();</span><br></pre></td></tr></table></figure>

<h3 id="5-3-引用类型流转化成集合"><a href="#5-3-引用类型流转化成集合" class="headerlink" title="5.3 引用类型流转化成集合"></a>5.3 引用类型流转化成集合</h3><p>引用类型流<code>Stream&lt;?&gt;</code>转为集合, 为<code>collect()</code>方法. 有2个重载的<code>collect()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br><span class="line"><span class="comment">//这个方法的参数为Collectors类中定义的一些函数式接口, 可以将流转换成对应的集合.</span></span><br><span class="line">Integer[] integers = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(integers);</span><br><span class="line"><span class="comment">//如果测试的话, 下面这三行代码只能保留一个. 否则多次使用一个流会出现异常.</span></span><br><span class="line">List&lt;Integer&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">Set&lt;Integer&gt; set1 = stream.collect(Collectors.toSet());</span><br><span class="line">Map&lt;Integer, Integer&gt; map = stream.collect(Collectors.toMap((i)-&gt;i, (i)-&gt;i+<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br><span class="line"><span class="comment">//这三个参数很有mapreduce的感觉. 对于第i个线程, 先用Supplier创建一个类型为R的对象ri, 然后对于流中的每个元素a, 和创建的对象ri, 执行accumulator操作(ri.accumulator(a)). 最后, 把各个线程创建的ri用combiner结合起来,得到新的对象作为返回结果.</span></span><br><span class="line"><span class="comment">//可能举个例子会更容易理解. </span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    set.add(i);</span><br><span class="line">&#125;</span><br><span class="line">Stream&lt;Integer&gt; stream = set.parallelStream();</span><br><span class="line">List&lt;Integer&gt; list = stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);</span><br><span class="line"><span class="comment">//一个2个线程的并行流[1,2,3,4,5]. [1,2,3]在线程1中, [4,5]在线程2中.</span></span><br><span class="line"><span class="comment">//第一步, 这两个线程分别使用supplier参数创建两个新的对象, 这里创建的是两个new ArrayList&lt;&gt;(). 记他们为r1和r2</span></span><br><span class="line"><span class="comment">//第二步, 对于第i个线程, 流中的每个元素都使用accumulator作用到ri上. 在这里就是将每个元素add到新创建的ArrayList ri上面</span></span><br><span class="line"><span class="comment">//第三步, 对于所有线程生成的ri, 两两执行combiner操作. 在这里r1 = [1,2,3], r2 = [4,5]. 执行addAll操作(r1.addAll(r2)). 返回最后结果.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以写成lambda表达式形式, 只不过更复杂. </span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    set.add(i);</span><br><span class="line">&#125;</span><br><span class="line">Stream&lt;Integer&gt; stream = set.parallelStream();</span><br><span class="line">List&lt;Integer&gt; list = stream.collect(()-&gt;&#123;<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();&#125;, </span><br><span class="line">                                    (r, element)-&gt;&#123;r.add(element);&#125;,                                        </span><br><span class="line">                                    (r1, r2)-&gt;&#123;r1.addAll(r2);&#125;);</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="5-4-基本类型流转化成集合"><a href="#5-4-基本类型流转化成集合" class="headerlink" title="5.4 基本类型流转化成集合"></a>5.4 基本类型流转化成集合</h3><p>基本类型的流转成集合只有一种<code>collect()</code>方法, 原理和上述引用类型的<code>collect()</code>相同. 不再赘述.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">              ObjIntConsumer&lt;R&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">              BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">IntStream intStream = Arrays.stream(ints);</span><br><span class="line">Map&lt;Integer, Integer&gt; map = intStream.collect(HashMap::<span class="keyword">new</span>, </span><br><span class="line">                                              (r, element) -&gt; r.put(element, element * element),</span><br><span class="line">                                              HashMap::putAll);</span><br></pre></td></tr></table></figure>

<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>了解上面的知识之后, 我们就可以在集合, 引用类型数组, 基本类型数组之间通过流进行转化了, 转化的关键分为三步, </p>
<ul>
<li><strong>将集合或数组转化成流,</strong> </li>
<li><strong>再利用引用类型流和基本类型流进行转化,</strong> </li>
<li><strong>最后将流再转化回集合或数组.</strong></li>
</ul>
<h3 id="6-1-int-与-Integer-互相转化"><a href="#6-1-int-与-Integer-互相转化" class="headerlink" title="6.1 int[] 与 Integer[]互相转化"></a>6.1 int[] 与 Integer[]互相转化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int[] =&gt; Integer[]</span></span><br><span class="line"><span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">IntStream intStream = Arrays.stream(ints);</span><br><span class="line">Stream&lt;Integer&gt; integerStream = intStream.boxed();</span><br><span class="line">Integer[] integers = integerStream.toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer[] =&gt; int[]</span></span><br><span class="line">Integer[] integers = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; integerStream = Arrays.stream(integers);</span><br><span class="line">IntStream intStream = integerStream.mapToInt(x -&gt; x);</span><br><span class="line"><span class="keyword">int</span>[] ints = intStream.toArray();</span><br></pre></td></tr></table></figure>

<h3 id="6-2-int-与-Collection-lt-Integer-gt-互相转化"><a href="#6-2-int-与-Collection-lt-Integer-gt-互相转化" class="headerlink" title="6.2 int[] 与 Collection&lt;Integer&gt; 互相转化"></a>6.2 int[] 与 Collection&lt;Integer&gt; 互相转化</h3><p>为了简单起见, 这里的Collection都用List来代替, Set, Queue等集合同理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int[] =&gt; Collection&lt;Integer&gt;</span></span><br><span class="line"><span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">IntStream intStream = Arrays.stream(ints);</span><br><span class="line">List&lt;Integer&gt; intList = intStream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collection&lt;Inetger&gt; =&gt; int[]</span></span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">Stream&lt;Integer&gt; integerStream = intList.stream();</span><br><span class="line">IntStream intStream = integerStream.mapToInt(x -&gt; x);</span><br><span class="line"><span class="keyword">int</span>[] ints = intStream.toArray();</span><br></pre></td></tr></table></figure>

<h3 id="6-3-Integer-与-Collection-lt-Integer-gt-互相转化"><a href="#6-3-Integer-与-Collection-lt-Integer-gt-互相转化" class="headerlink" title="6.3 Integer[] 与 Collection&lt;Integer&gt; 互相转化"></a>6.3 Integer[] 与 Collection&lt;Integer&gt; 互相转化</h3><p>为了简单起见, 这里的Collection都用List来代替, Set, Queue等集合同理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer[] =&gt; Collection&lt;Integer&gt;</span></span><br><span class="line">Integer[] integers = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; integerStream = Arrays.stream(integers);</span><br><span class="line">List&lt;Integer&gt; intList = integerStream.collect(Collectors.toList());</span><br><span class="line">List&lt;Integer&gt; intList = integerStream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll); <span class="comment">// also ok</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collection&lt;Integer&gt; =&gt; Integer[]</span></span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">Stream&lt;Integer&gt; integerStream = intList.stream();</span><br><span class="line">Integer[] integers = integerStream.toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p><strong>同时, 这两者的转化还可以不需要<code>Stream&lt;?&gt;</code>流. 这也是唯二不需要流就能互相转化的了.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer[] =&gt; Collection&lt;Integer&gt;</span></span><br><span class="line">Integer[] integers = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(integers));</span><br><span class="line"><span class="comment">/*注意, 不能使用以下的方法创建一个ArrayList, 因为这样创建出来的intList只能进行读和修改元素操作, 不能进行添加元素和删除元素操作!!!*/</span></span><br><span class="line">List&lt;Integer&gt; intList = Arrays.asList(integers);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collection&lt;Integer&gt; =&gt; Integer[]</span></span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">Integer[] integers = intList.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">/*注意, 不能使用下面的方法从ArrayList&lt;Integer&gt;得到Integer[], 因为java中的类型转化只能针对单独的对象, Object[]直接转换到Integer[]是不行的!!!*/</span></span><br><span class="line">Integer[] integers = (Integer[]) intList.toArray();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 103 Binary Tree Zigzag Level Order Traversal</title>
    <url>/2020/10/05/Leetcode/Leetcode%20103%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/</url>
    <content><![CDATA[<p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>



<p>return its zigzag level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="队列-BFS"><a href="#队列-BFS" class="headerlink" title="队列 + BFS"></a>队列 + BFS</h2><p>和leetcode 102 一样, 只是增加一个变量currentDepth来判断是从左到右还是从右到左.</p>
<p>这时, 为了实现从右到左的效果, 我们可以用LinkedList的push和add方法. 一个头插一个尾插. (注意只有LinkedList有这个操作, List接口是没有的)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; llist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> llist;</span><br><span class="line">        <span class="keyword">int</span> currentDepth = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> thisLevelSize = q.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; thisLevelList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(thisLevelSize != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode tmp = q.poll();</span><br><span class="line">                <span class="keyword">if</span>((currentDepth &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                    thisLevelList.push(tmp.val);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    thisLevelList.add(tmp.val);</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.right);</span><br><span class="line">                --thisLevelSize;</span><br><span class="line">            &#125;</span><br><span class="line">            ++currentDepth;</span><br><span class="line">            llist.add(thisLevelList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> llist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 104 Maximum Depth Of Binary Tree</title>
    <url>/2020/10/02/Leetcode/Leetcode%20104%20Maximum%20Depth%20Of%20Binary%20Tree/</url>
    <content><![CDATA[<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its depth = 3.</p>
<a id="more"></a>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><p>直接递归非常简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left) + <span class="number">1</span>, maxDepth(root.right) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2 BFS"></a>2 BFS</h2><p>每一次将一层的节点(非空)加入队列, 看看一共加入了多少次.</p>
<p>比递归稍慢.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span>(size != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode tmp = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.right);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 107 Binary Tree Level Order Traversal II</title>
    <url>/2020/10/05/Leetcode/Leetcode%20107%20Binary%20Tree%20Level%20Order%20Traversal%20II/</url>
    <content><![CDATA[<p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>



<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><p>和leetcode 102 完全一样, 只不过最后要把list翻转一下.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; llist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> llist;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> thisLevelSize = q.size();</span><br><span class="line">            List&lt;Integer&gt; thisLevelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(thisLevelSize != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode tmp = q.poll();</span><br><span class="line">                thisLevelList.add(tmp.val);</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.right);</span><br><span class="line">                --thisLevelSize;</span><br><span class="line">            &#125;</span><br><span class="line">            llist.add(thisLevelList);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(llist);</span><br><span class="line">        <span class="keyword">return</span> llist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 105 Construct Binary Tree From Preorder And Inorder Traversal</title>
    <url>/2020/08/14/Leetcode/Leetcode%20105%20Construct%20Binary%20Tree%20From%20Preorder%20And%20Inorder%20Traversal/</url>
    <content><![CDATA[<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>Return the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><p>注意到</p>
<blockquote>
<p>前序遍历中, 第一个元素肯定是根节点的元素. 中序遍历中, 根节点元素左边的元素为左子树的元素, 右边的元素为右子树的元素</p>
</blockquote>
<p>所以, 给定四个参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator preorder_begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator preorder_end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator inorder_begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator inorder_end)</span></span></span><br></pre></td></tr></table></figure>

<p>那么根节点的元素一定是<code>*preorder_begin</code>, 在中序遍历中找到<code>*preorder_begin</code>对应的位置<code>inorder_parentNode</code></p>
<p>那么<code>inorder_parentNode</code>左边的元素都为左子树, 统计左子树节点的数量<code>leftTreeNums</code>, 在前序遍历的数组中, <code>preorder_begin + 1</code>到<code> preorder_begin + leftTreeNums + 1</code>即为左子树的位置,  在中序遍历的数组中<code>inorder_begin</code>到 <code>inorder_parentNode</code> 即为左子树的位置. 右子树在前序遍历和中序遍历的位置同理可得. </p>
<p>递归的构造左子树和右子树, 再加上parentNode即可.</p>
<p>最好情况时间复杂度O(nlogn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder.<span class="built_in">begin</span>(), preorder.<span class="built_in">end</span>(), inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator preorder_begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator preorder_end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator inorder_begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator inorder_end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder_begin == preorder_end || inorder_begin == inorder_end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> parentNodeValue = *preorder_begin;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator inorder_parentNode= <span class="built_in">find</span>(inorder_begin, inorder_end, parentNodeValue);</span><br><span class="line">        <span class="keyword">int</span> leftTreeNums = inorder_parentNode - inorder_begin;</span><br><span class="line">        <span class="keyword">int</span> rightTreeNums = inorder_end - inorder_parentNode - <span class="number">1</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(parentNodeValue);</span><br><span class="line">        res-&gt;left = buildTree(preorder_begin + <span class="number">1</span>, preorder_begin + leftTreeNums + <span class="number">1</span>, inorder_begin, inorder_parentNode);</span><br><span class="line">        res-&gt;right = buildTree(preorder_end - rightTreeNums, preorder_end, inorder_parentNode + <span class="number">1</span>, inorder_end);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-递归-with-HashMap"><a href="#2-递归-with-HashMap" class="headerlink" title="2 递归 with HashMap"></a>2 递归 with HashMap</h2><p>上面的做法只超过25%的cpp程序, 寻找运行慢的原因是因为, 在每一次的递归中, 都需要查找根节点的值<code>parentNodeValue</code>在中序遍历中的位置<code>inorder_parentNode</code>. </p>
<p>假如二叉树是平衡的, 那么第1层递归要在1个长为n的数组中找1个<code>inorder_parentNode</code>, 第2层递归要在2个长为n/2的数组中找2个<code>inorder_parentNode</code>, …, 第log n层递归要在2^(n-1)个长为n/2^(n-1)的数组中找2^(n-1)个<code>inorder_parentNode</code>. 总的查找时间为n * log n. 若二叉树不平衡, 考虑任何一个节点只有左子树, 则查找时间升高到n(n-1)/2. 非常费时间</p>
<h4 id="所以在相同的数组中多次进行元素查找可以用哈希表加快查询速度-参考leetcode-1"><a href="#所以在相同的数组中多次进行元素查找可以用哈希表加快查询速度-参考leetcode-1" class="headerlink" title="**所以在相同的数组中多次进行元素查找可以用哈希表加快查询速度. ** 参考leetcode 1."></a>**所以在相同的数组中多次进行元素查找可以用哈希表加快查询速度. ** 参考leetcode 1.</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = inorder.<span class="built_in">begin</span>(); it != inorder.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    mp.insert(&#123;*it,it&#125;);</span><br></pre></td></tr></table></figure>

<p>每一次递归中的find查找只花费常数时间复杂度. 总复杂度为O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = inorder.<span class="built_in">begin</span>(); it != inorder.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            mp.insert(&#123;*it,it&#125;);</span><br><span class="line">        <span class="keyword">return</span> buildTree(mp, preorder.<span class="built_in">begin</span>(), preorder.<span class="built_in">end</span>(), inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt;&amp; mp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator preorder_begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator preorder_end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator inorder_begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator inorder_end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder_begin == preorder_end || inorder_begin == inorder_end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> parentNodeValue = *preorder_begin;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator inorder_parentNode= mp.<span class="built_in">find</span>(parentNodeValue) -&gt; second;</span><br><span class="line">        <span class="keyword">int</span> leftTreeNums = inorder_parentNode - inorder_begin;</span><br><span class="line">        <span class="keyword">int</span> rightTreeNums = inorder_end - inorder_parentNode - <span class="number">1</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(parentNodeValue);</span><br><span class="line">        res-&gt;left = buildTree(mp, preorder_begin + <span class="number">1</span>, preorder_begin + leftTreeNums + <span class="number">1</span>, inorder_begin, inorder_parentNode);</span><br><span class="line">        res-&gt;right = buildTree(mp, preorder_end - rightTreeNums, preorder_end, inorder_parentNode + <span class="number">1</span>, inorder_end);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-非递归"><a href="#3-非递归" class="headerlink" title="3 非递归"></a>3 非递归</h2><p><strong>贴一个leetcode官方给的题解, 用的栈模拟了递归. 感觉时间和空间上不会好很多但是难度增加了很多, 个人不是太喜欢这个做法.</strong></p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>思路</p>
<p>迭代法是一种非常巧妙的实现方法。</p>
<p>对于前序遍历中的任意两个连续节点 u 和 v，根据前序遍历的流程，我们可以知道 u 和 v 只有两种可能的关系：</p>
<ul>
<li><p>v 是 u 的左儿子。这是因为在遍历到 u 之后，下一个遍历的节点就是 u 的左儿子，即 v；</p>
</li>
<li><p>u 没有左儿子，并且 v 是 u 的某个祖先节点（或者 u 本身）的右儿子。如果 u 没有左儿子，那么下一个遍历的节点就是 u 的右儿子。如果 u 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 u 不在它的右儿子的子树中）的节点 u_a  ，那么 v 就是 u_a  的右儿子。</p>
</li>
</ul>
<p>第二种关系看上去有些复杂。我们举一个例子来说明其正确性，并在例子中给出我们的迭代算法。</p>
<p>例子</p>
<p>我们以树</p>
<pre><code>         3
        / \
       9  20
      /  /  \
     8  15   7
   / \
  5  10
 /
4</code></pre>
<p>为例，它的前序遍历和中序遍历分别为</p>
<p>preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]<br>inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]<br>我们用一个栈 stack 来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针 index 指向中序遍历的某个位置，初始值为 0。index 对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p>
<p>首先我们将根节点 3 入栈，再初始化 index 所指向的节点为 4，随后对于前序遍历中的每个节点，我们依此判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p>
<p>我们遍历 9。9 一定是栈顶节点 3 的左儿子。我们使用反证法，假设 9 是 3 的右儿子，那么 3 没有左儿子，index 应该恰好指向 3，但实际上为 4，因此产生了矛盾。所以我们将 9 作为 3 的左儿子，并将 9 入栈。</p>
<p>stack = [3, 9]<br>index -&gt; inorder[0] = 4<br>我们遍历 8，5 和 4。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。</p>
<p>stack = [3, 9, 8, 5, 4]<br>index -&gt; inorder[0] = 4<br>我们遍历 10，这时情况就不一样了。我们发现 index 恰好指向当前的栈顶节点 4，也就是说 4 没有左儿子，那么 10 必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的。</p>
<p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p>
<p>因此我们可以把 index 不断向右移动，并与栈顶节点进行比较。如果 index 对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将 index 增加 1 并弹出栈顶节点，直到 index 对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点 x 就是 10 的双亲节点，这是因为 10 出现在了 x 与 x 在栈中的下一个节点的中序遍历之间，因此 10 就是 x 的右儿子。</p>
<p>回到我们的例子，我们会依次从栈顶弹出 4，5 和 8，并且将 index 向右移动了三次。我们将 10 作为最后弹出的节点 8 的右儿子，并将 10 入栈。</p>
<p>stack = [3, 9, 10]<br>index -&gt; inorder[3] = 10<br>我们遍历 20。同理，index 恰好指向当前栈顶节点 10，那么我们会依次从栈顶弹出 10，9 和 3，并且将 index 向右移动了三次。我们将 20 作为最后弹出的节点 3 的右儿子，并将 20 入栈。</p>
<p>stack = [20]<br>index -&gt; inorder[6] = 15<br>我们遍历 15，将 15 作为栈顶节点 20 的左儿子，并将 15 入栈。</p>
<p>stack = [20, 15]<br>index -&gt; inorder[6] = 15<br>我们遍历 7。index 恰好指向当前栈顶节点 15，那么我们会依次从栈顶弹出 15 和 20，并且将 index 向右移动了两次。我们将 7 作为最后弹出的节点 20 的右儿子，并将 7 入栈。</p>
<p>stack = [7]<br>index -&gt; inorder[8] = 7<br>此时遍历结束，我们就构造出了正确的二叉树。</p>
<p>算法</p>
<p>我们归纳出上述例子中的算法流程：</p>
<p>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p>
<p>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</p>
<p>无论是哪一种情况，我们最后都将当前的节点入栈。</p>
<p>最后得到的二叉树即为答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!preorder.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="keyword">int</span> inorderIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> preorderVal = preorder[i];</span><br><span class="line">            TreeNode* node = stk.top();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top()-&gt;val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    ++inorderIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 108 Convert Sorted Array To Binary Search Tree</title>
    <url>/2020/10/15/Leetcode/Leetcode%20108%20Convert%20Sorted%20Array%20To%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>这题很简单, 先找到数组中间的元素mid作为根节点, 然后问题就变成了0到mid-1的子数组构造BST和mid+1到length-1的子数组构造BST了. 递归地进行即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(begin == end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[begin]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[mid], sortedArrayToBST(nums, begin, mid - <span class="number">1</span>), sortedArrayToBST(nums, mid + <span class="number">1</span>, end));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 106 Construct Binary Tree From Inorder And Postorder Traversal</title>
    <url>/2020/08/10/Leetcode/Leetcode%20106%20Construct%20Binary%20Tree%20From%20Inorder%20And%20Postorder%20Traversal/</url>
    <content><![CDATA[<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<p>Return the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>解法完全与 leetcode 105 相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = inorder.<span class="built_in">begin</span>(); it != inorder.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            mp.insert(&#123;*it,it&#125;);</span><br><span class="line">        <span class="keyword">return</span> buildTree(mp, postorder.<span class="built_in">begin</span>(), postorder.<span class="built_in">end</span>(), inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt;&amp; mp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator postorder_begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator postorder_end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator inorder_begin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator inorder_end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder_begin == postorder_end || inorder_begin == inorder_end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator inorder_parentNode= mp.<span class="built_in">find</span>(*(postorder_end - <span class="number">1</span>)) -&gt; second;</span><br><span class="line">        <span class="keyword">int</span> leftTreeNums = inorder_parentNode - inorder_begin;</span><br><span class="line">        <span class="keyword">int</span> rightTreeNums = inorder_end - inorder_parentNode - <span class="number">1</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(*inorder_parentNode);</span><br><span class="line">        res-&gt;left = buildTree(mp, postorder_begin, postorder_begin + leftTreeNums, inorder_begin, inorder_parentNode);</span><br><span class="line">        res-&gt;right = buildTree(mp, postorder_end - <span class="number">1</span> - rightTreeNums, postorder_end - <span class="number">1</span>, inorder_parentNode + <span class="number">1</span>, inorder_end);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 109 Convert Sorted List To Binary Search Tree</title>
    <url>/2020/10/17/Leetcode/Leetcode%20109%20Convert%20Sorted%20List%20To%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<p>Given the <code>head</code> of a singly linked list where elements are <strong>sorted in ascending order</strong>, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,3]</span><br><span class="line">Output: [3,1]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in <code>head</code> is in the range <code>[0, 2 * 104]</code>.</li>
<li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li>
</ul>
<a id="more"></a>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><p>和leetcode 108 差不多.</p>
<p>只不过这里找到中间元素slow的同时, 还要找到slow的前面的元素, 以断裂链表. 将链表分为两个子链表</p>
<p>分治, 时间复杂度O(nlogn)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode midPrev = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            midPrev = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode ans = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        midPrev.next = <span class="keyword">null</span>;</span><br><span class="line">        ans.left = sortedListToBST(head);</span><br><span class="line">        ans.right = sortedListToBST(slow.next);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-转化为数组"><a href="#2-转化为数组" class="headerlink" title="2 转化为数组"></a>2 转化为数组</h2><p>为了优化时间复杂度, 可以把链表转化为数组, 然后和leetcode 108 一样. 时间复杂度O(n)</p>
<h2 id="3-利用中序遍历"><a href="#3-利用中序遍历" class="headerlink" title="3 利用中序遍历"></a>3 利用中序遍历</h2><p><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-1-3/">https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-1-3/</a></p>
<p>这是一种很巧妙的方法, 先确定开始和结束的位置 begin 和 end, 然后逐次往里面添加链表中的值.</p>
<p>利用globalHead控制链表的遍历, 用begin和end控制二叉树的结构, 即哪些部分是左子树的, 哪些部分是右子树的. 十分巧妙. 时间复杂度O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode globalHead;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        globalHead = head;</span><br><span class="line">        <span class="keyword">int</span> len = getLength(head);</span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">        TreeNode ans = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        ans.left = buildTree(begin, mid - <span class="number">1</span>);</span><br><span class="line">        ans.val = globalHead.val;</span><br><span class="line">        globalHead = globalHead.next;</span><br><span class="line">        ans.right = buildTree(mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 111 Minimum Depth Of Binary Tree</title>
    <url>/2020/10/20/Leetcode/Leetcode%20111%20Minimum%20Depth%20Of%20Binary%20Tree/</url>
    <content><![CDATA[<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [2,null,3,null,4,null,5,null,6]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<a id="more"></a>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>一开始刚看这个题目, 感觉很简单, <code>return root == null ? 0 : Math.min(minDepth(root.left), minDepth(root.right)) + 1;</code> 一行就能搞定. submit后才发现根本不是这样. 这题和求maxDepth的思路不一样!!!</p>
<p>考虑下面的树， 上面的“一行算法”就失效了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br></pre></td></tr></table></figure>

<p>正确的解法应该是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 11 Container With Most Water</title>
    <url>/2020/07/17/Leetcode/Leetcode%2011%20Container%20With%20Most%20Water/</url>
    <content><![CDATA[<p>\11. Container With Most Water</p>
<p>Medium</p>
<p>6231587Add to ListShare</p>
<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="img"></p>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure>



<a id="more"></a>
<h2 id="1-暴力算法-超时"><a href="#1-暴力算法-超时" class="headerlink" title="1 暴力算法(超时)"></a>1 暴力算法(超时)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">height</span>.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = (j - i) * <span class="built_in">min</span>(<span class="built_in">height</span>[i],<span class="built_in">height</span>[j]);</span><br><span class="line">                <span class="keyword">if</span>(tmp &gt; <span class="built_in">max</span>)</span><br><span class="line">                    <span class="built_in">max</span> = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-贪婪算法"><a href="#2-贪婪算法" class="headerlink" title="2 贪婪算法"></a>2 贪婪算法</h2><p>我们发现, 要想容量最大, 要么就两个bar之间的宽度大,  要么bar的高度大. </p>
<p>可以先计算出宽度最大的容量(let i:=1 j:=length-1), 然后再让i,j向中间缩进寻找高度更高的bar，判断是否超过刚才两个bar宽度比较大的容量。</p>
<p>向中间缩进是有技巧的，对于两个bar height[i]和height[j]，一定要短的bar向中间缩进，否则可能会错过最优解。</p>
<ul>
<li>例如，heights = [2, 6, 5, 5, 5, 4]中, 当i = 0; j = 5;时，如果将长的bar (height[5]=4)向中间移动,移动后j=4，这样就再也寻找不到最优解(i=1,j=5,volume=16)了。</li>
<li>如果移动短的bar (height[0]=2), 移动后i=1. 这样也错过了某些解。比如(i=0,j=4,),(i=0,j=3)等。但是这些解不可能比原来的解大(i = 0; j = 5, volume = 10)，这是因为错过的这些解长度不可能比原来的解长， 高度也不可能比原来的解高(即使j对应的bar高，因为i对应的bar比j对应的bar低，所以总体高度也不可能大于i对应的bar)。</li>
<li>也正因为这些错过的解不可能是最优解，所以减少了许多计算和比较，将复杂度降为O(n)。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> volume = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">height</span>.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            volume = <span class="built_in">max</span>(volume,(j-i) * <span class="built_in">min</span>(<span class="built_in">height</span>[i],<span class="built_in">height</span>[j]));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">height</span>[i] &lt; <span class="built_in">height</span>[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> volume;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 110 Balanced Binary Tree</title>
    <url>/2020/10/17/Leetcode/Leetcode%20110%20Balanced%20Binary%20Tree/</url>
    <content><![CDATA[<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<blockquote>
<p>a binary tree in which the left and right subtrees of <em>every</em> node differ in height by no more than 1.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,3,3,null,null,4,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<a id="more"></a>
<h2 id="自底向上的递归"><a href="#自底向上的递归" class="headerlink" title="自底向上的递归"></a>自底向上的递归</h2><p>碰到不平衡的节点就返回高度为-1.</p>
<p>当两个子树都平衡的时候才计算高度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NotBalanced = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root)[<span class="number">1</span>] != NotBalanced;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getDepth(TreeNode root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] leftTree = getDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(leftTree[<span class="number">1</span>] == NotBalanced)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, NotBalanced&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightTree = getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(rightTree[<span class="number">1</span>] == NotBalanced)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, NotBalanced&#125;;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftTree[<span class="number">0</span>] - rightTree[<span class="number">0</span>]) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, NotBalanced&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Math.max(leftTree[<span class="number">0</span>], rightTree[<span class="number">0</span>]) + <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 112 Path Sum</title>
    <url>/2020/10/19/Leetcode/Leetcode%20112%20Path%20Sum/</url>
    <content><![CDATA[<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure>

<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<a id="more"></a>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>直接递归地判断即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root.val == sum;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> hasPathSum(root.right, sum - root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> hasPathSum(root.left, sum - root.val);</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 114 Flatten Binary Tree To Linked List</title>
    <url>/2020/10/05/Leetcode/Leetcode%20114%20Flatten%20Binary%20Tree%20To%20Linked%20List/</url>
    <content><![CDATA[<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example, given the following tree:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>

<p>The flattened tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><p>思路简单, 实现起来比较复杂.</p>
<p>flatten一个树, 等于先flatten两个子树, 然后再将两个子树合起来, 合起来的时候, flatten过的左子树在前, 右子树在后.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        TreeNode tmp = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        TreeNode iterator = root;</span><br><span class="line">        <span class="keyword">while</span>(iterator.right != <span class="keyword">null</span>)</span><br><span class="line">            iterator = iterator.right;</span><br><span class="line">        iterator.right = tmp;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2 迭代"></a>2 迭代</h2><p>贴一个leetcode官网上的方法,这个方法太赞了, 空间复杂度只有O(1).</p>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/</a></p>
<p>注意到前序遍历访问各节点的顺序是根节点、左子树、右子树。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。</p>
<p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode tmp = curr.right;</span><br><span class="line">            TreeNode leftNode = curr.left;</span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(leftNode.right != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                leftNode = leftNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">            leftNode.right = tmp;</span><br><span class="line">            curr.right = curr.left;</span><br><span class="line">            curr.left = <span class="keyword">null</span>;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 116 Populating Next Right Pointers In Each Node</title>
    <url>/2020/10/16/Leetcode/Leetcode%20116%20Populating%20Next%20Right%20Pointers%20In%20Each%20Node/</url>
    <content><![CDATA[<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the given tree is less than <code>4096</code>.</li>
<li><code>-1000 &lt;= node.val &lt;= 1000</code></li>
</ul>
<a id="more"></a>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>看到这个题之后的第一反应就是按层处理, 把每一层的所有节点都放到一个队列中, 然后挨个把他们连接起来. 后来发现题目要求不能使用除递归外的额外空间. 所以只能用递归做了</p>
<p>后来想了一会, 发现递归好像比队列更加简单.</p>
<p>首先递归边界是null或者叶子节点.</p>
<p>然后connect(root)就等价于先connect两个子树, 然后<strong>再把左子树最右侧的节点与右子树最左侧的节点连接起来</strong></p>
<p>左子树a的所有最右侧节点定义为<code>a, a.right, a.right.right, ....</code></p>
<p>右子树b的所有最左侧节点定义为<code>b, b.left, b.left.left, ....</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            connect(root.left);</span><br><span class="line">            connect(root.right);</span><br><span class="line">            Node left = root.left;</span><br><span class="line">            Node right = root.right;</span><br><span class="line">            <span class="keyword">while</span>(left != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left.next = right;</span><br><span class="line">                left = left.right;</span><br><span class="line">                right = right.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 113 Path Sum II</title>
    <url>/2020/10/19/Leetcode/Leetcode%20113%20Path%20Sum%20II/</url>
    <content><![CDATA[<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>

<p>Return:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>直接深度优先遍历就可以了. </p>
<p>注意递归边界是叶子节点. 当叶子节点的值与sum相等时, 将递归路径加入结果中. 注意要加入递归路径的拷贝. 因为递归路径随时在变化.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        pathSum(lists, curr, root, sum);</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; curr, TreeNode root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;null pointer&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val == sum)</span><br><span class="line">            &#123;</span><br><span class="line">                curr.add(root.val);</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curr.add(root.val);</span><br><span class="line">            pathSum(ans, curr, root.right, sum - root.val);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curr.add(root.val);</span><br><span class="line">            pathSum(ans, curr, root.left, sum - root.val);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            curr.add(root.val);</span><br><span class="line">            pathSum(ans, curr, root.right, sum - root.val);</span><br><span class="line">            pathSum(ans, curr, root.left, sum - root.val);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 117 Populating Next Right Pointers In Each Node II</title>
    <url>/2020/10/19/Leetcode/Leetcode%20117%20Populating%20Next%20Right%20Pointers%20In%20Each%20Node%20II/</url>
    <content><![CDATA[<p>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,null,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,7,#]</span><br><span class="line">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the given tree is less than <code>6000</code>.</li>
<li><code>-100 &lt;= node.val &lt;= 100</code></li>
</ul>
<a id="more"></a>
<h2 id="1-队列"><a href="#1-队列" class="headerlink" title="1 队列"></a>1 队列</h2><p>实在想不出递归的方法了. 主要是下面这样的树没法递归地处理. 因为没法找到左子树的最右侧元素和右子树的最左侧元素. </p>
<p>只能用队列分层处理了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">     &#x2F;   \</span><br><span class="line">    2     3</span><br><span class="line">   &#x2F; \   &#x2F; \</span><br><span class="line">  4   5 6   7</span><br><span class="line"> &#x2F;           \</span><br><span class="line">8             9</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        Queue&lt;Node&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            Node beginNode = <span class="keyword">new</span> Node();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Node nextNode = q.poll();</span><br><span class="line">                --size;</span><br><span class="line">                beginNode.next = nextNode;</span><br><span class="line">                beginNode = nextNode;</span><br><span class="line">                <span class="keyword">if</span>(beginNode.left != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(beginNode.left);</span><br><span class="line">                <span class="keyword">if</span>(beginNode.right != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(beginNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2 链表"></a>2 链表</h2><p>这个想法真的好. </p>
<p>我们利用队列的目的就是储存上一层的节点, 以方便把这一层所有节点都加入到队列中以便连接.</p>
<p>但是事实上, 获得上一层节点不需要一个队列来存储. <strong>因为上一层节点已经是连接好的了, 所以只需要传递一个上一层所有元素的首指针<code>preLevel</code>即可获得这一层所有元素</strong>, 然后连接他们, 再继续传递到下一层.</p>
<p>真的是妙啊.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        Node prevLevel = root;</span><br><span class="line">        <span class="keyword">while</span>(prevLevel != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node currHead = <span class="keyword">new</span> Node();</span><br><span class="line">            Node tail = currHead;</span><br><span class="line">            Node prevHead = prevLevel;</span><br><span class="line">            <span class="keyword">while</span>(prevHead != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(prevHead.left != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tail.next = prevHead.left;</span><br><span class="line">                    tail = tail.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(prevHead.right != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tail.next = prevHead.right;</span><br><span class="line">                    tail = tail.next;</span><br><span class="line">                &#125;</span><br><span class="line">                prevHead = prevHead.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prevLevel = currHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 119 Pascals Triangle II</title>
    <url>/2020/07/17/Leetcode/Leetcode%20119%20Pascals%20Triangle%20II/</url>
    <content><![CDATA[<p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p>
<a id="more"></a>
<h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p>时间复杂度仍需要O(n^2),注意到每一行的vector只需要由上一行来计算，和更上面的元素无关</p>
<p>所以当有第k行时，直接在第k行的基础上计算并覆盖第k+1行</p>
<p>要注意提前拷贝出来要被覆盖的第k行的值，并且注意最后加上1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = rowIndex;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vc</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp_jMinus1 = vc[<span class="number">0</span>];   <span class="comment">//copy to prevent being covered</span></span><br><span class="line">            <span class="keyword">int</span> tmp_j = vc[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp_val = tmp_jMinus1 + tmp_j;</span><br><span class="line">                tmp_jMinus1 = tmp_j;</span><br><span class="line">                tmp_j = vc[j+<span class="number">1</span>];        <span class="comment">//copy to prevent being covered</span></span><br><span class="line">                vc[j] = tmp_val;      <span class="comment">//covering the value</span></span><br><span class="line">            &#125;</span><br><span class="line">            vc.back() = tmp_jMinus1 + tmp_j;   <span class="comment">//change the second last value</span></span><br><span class="line">            vc.push_back(<span class="number">1</span>);                   <span class="comment">//add the last one</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 118 Pascals Triangle</title>
    <url>/2020/07/17/Leetcode/Leetcode%20118%20Pascals%20Triangle/</url>
    <content><![CDATA[<p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h2><p>直接构造即可 复杂度O(n^2)</p>
<p>注意numRows = 0, 1, 2的特殊情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvc;</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">0</span>) <span class="keyword">return</span> vvc;</span><br><span class="line">        vvc.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">1</span>&#125;));</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> vvc;</span><br><span class="line">        vvc.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;));</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">2</span>) <span class="keyword">return</span> vvc;</span><br><span class="line">        </span><br><span class="line">        assert(numRows &gt; <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">3</span>; j &lt;= numRows; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            tmp.push_back(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j - <span class="number">2</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> a = vvc.back()[i] + vvc.back()[i + <span class="number">1</span>];</span><br><span class="line">                tmp.push_back(a);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.push_back(<span class="number">1</span>);</span><br><span class="line">            vvc.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 120 Triangle</title>
    <url>/2020/07/18/Leetcode/Leetcode%20120%20Triangle/</url>
    <content><![CDATA[<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>The minimum path sum from top to bottom is <code>11</code> (i.e., <strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11).</p>
<p><strong>Note:</strong></p>
<p>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p>
<a id="more"></a>
<h2 id="1-从上到下计算"><a href="#1-从上到下计算" class="headerlink" title="1 从上到下计算"></a>1 从上到下计算</h2><p>由于求top到第k层的最短距离只依赖于top到第k-1层的距离,</p>
<p>创建一个vector shortest 储存top到第k层每一个元素的距离, 计算k+1层时直接覆盖shortest. 最后取shortest中的最小值</p>
<p>此方法需要考虑很多的边界条件 (我改正heap-overflow的错误至少花了30分钟),</p>
<ul>
<li><p>创建两个变量tmp_j和tmp_jPlus1保存将要被覆盖的变量，所以triangle[k]至少要有2个元素，否则内存错误。这也就意味着triangle.size() = 0或1时要单独讨论。</p>
</li>
<li><p>对于第k层的第0个元素，其最短距离只与第k-1层第0个元素有关，不需要比较两个相邻的值，所以应该单独求解</p>
</li>
<li><p>对于第k层的倒数第二个元素，最短距离由比较第k-1层的倒数第二个元素和倒数第一个元素得出，但是得出结果之后不能更新tmp_j和tmp_jPlus1，因为此时的tmp_jPlus1已经是shortest中最后一个元素了，再+1会内存错误</p>
</li>
<li><p>对于第k层的最后一个元素，要使用push_back的方式添加，而不是修改shortest.back()，因为上一层的shortest元素比这一层的少1，所以要+1</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortest;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        shortest.push_back(triangle[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//makesure shortest has at least 2 elements</span></span><br><span class="line">        shortest[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>] + triangle[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        shortest.push_back(triangle[<span class="number">0</span>][<span class="number">0</span>] + triangle[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp_j = shortest[<span class="number">0</span>];     <span class="comment">//backup variable</span></span><br><span class="line">            <span class="keyword">int</span> tmp_jPlus1 = shortest[<span class="number">1</span>];   <span class="comment">//why shortest has at least 2 elements</span></span><br><span class="line">            shortest[<span class="number">0</span>] = tmp_j + triangle[i][<span class="number">0</span>]; <span class="comment">//shortest[i][0] must come from shortest[i-1][0]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; triangle[i].<span class="built_in">size</span>() - <span class="number">2</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                shortest[j] = <span class="built_in">min</span>(tmp_j,tmp_jPlus1) + triangle[i][j];</span><br><span class="line">                tmp_j = tmp_jPlus1;</span><br><span class="line">                tmp_jPlus1 = shortest[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//secondly last one cannot operate j+1</span></span><br><span class="line">            <span class="keyword">int</span> second_last_index = triangle[i].<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">            shortest[second_last_index] = <span class="built_in">min</span>(tmp_j,tmp_jPlus1) + triangle[i][second_last_index];</span><br><span class="line">            <span class="comment">//shortest[i][i] must come from shortest[i-1][i-1]</span></span><br><span class="line">            <span class="keyword">int</span> last = tmp_jPlus1 + triangle[i].back(); </span><br><span class="line">            shortest.push_back(last);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *min_element(shortest.<span class="built_in">begin</span>(),shortest.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-从下到上计算"><a href="#2-从下到上计算" class="headerlink" title="2 从下到上计算"></a>2 从下到上计算</h2><p><strong>从上到下的最短距离等于从下到上的最短距离!</strong></p>
<p><code>dist_triangle[i]\[j]</code>的距离等于<code>min(dist_triangle[i+1][j], dist_triangle[i+1][j+1]) + triangle[i][j]</code></p>
<p>i从triangle.size()-2遍历到0， 不需要考虑边界条件，内存错误数组溢出的问题，也不需要考虑新建vector储存最短距离，直接可以覆盖到triangle上，使用O(1)的extra space。</p>
<p>只需要考虑triangle.size() == 0的特殊条件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                triangle[i][j] = <span class="built_in">min</span>(triangle[i+<span class="number">1</span>][j],triangle[i+<span class="number">1</span>][j+<span class="number">1</span>]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1179 Reformat Department Table</title>
    <url>/2020/10/29/Leetcode/Leetcode%201179%20Reformat%20Department%20Table/</url>
    <content><![CDATA[<p>able: <code>Department</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| revenue       | int     |</span><br><span class="line">| month         | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(id, month) is the primary key of this table.</span><br><span class="line">The table has information about the revenue of each department per month.</span><br><span class="line">The month has values in [&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;].</span><br></pre></td></tr></table></figure>



<p>Write an SQL query to reformat the table such that there is a department id column and a revenue column <strong>for each month</strong>.</p>
<p>The query result format is in the following example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Department table:</span><br><span class="line">+------+---------+-------+</span><br><span class="line">| id   | revenue | month |</span><br><span class="line">+------+---------+-------+</span><br><span class="line">| 1    | 8000    | Jan   |</span><br><span class="line">| 2    | 9000    | Jan   |</span><br><span class="line">| 3    | 10000   | Feb   |</span><br><span class="line">| 1    | 7000    | Feb   |</span><br><span class="line">| 1    | 6000    | Mar   |</span><br><span class="line">+------+---------+-------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------+-------------+-------------+-------------+-----+-------------+</span><br><span class="line">| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |</span><br><span class="line">+------+-------------+-------------+-------------+-----+-------------+</span><br><span class="line">| 1    | 8000        | 7000        | 6000        | ... | null        |</span><br><span class="line">| 2    | 9000        | null        | null        | ... | null        |</span><br><span class="line">| 3    | null        | 10000       | null        | ... | null        |</span><br><span class="line">+------+-------------+-------------+-------------+-----+-------------+</span><br><span class="line"></span><br><span class="line">Note that the result table has 13 columns (1 for the department id + 12 for the months).</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1 暴力"></a>1 暴力</h2><p>每一个都嵌套一个子查询.</p>
<p>但是超时了. 好像leetcode sql的超时不用TLE而是Connection Timed Out. 第一次见到这种错的我还琢磨了老半天 😢</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> t.id,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;Jan&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> Jan_Revenue,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;Feb&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> Feb_Revenue,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;Mar&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> Mar_Revenue,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;Apr&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> Apr_Revenue,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;May&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> May_Revenue,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;Jun&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> Jun_Revenue,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;Jul&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> Jul_Revenue,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;Aug&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> Aug_Revenue,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;Sep&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> Sep_Revenue,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;Oct&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> Oct_Revenue,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;Nov&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> Nov_Revenue,</span><br><span class="line">(<span class="keyword">select</span> revenue <span class="keyword">from</span> Department <span class="keyword">where</span> <span class="keyword">month</span> = <span class="string">&#x27;Dec&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span> = t.id) <span class="keyword">as</span> Dec_Revenue</span><br><span class="line"><span class="keyword">from</span> Department <span class="keyword">as</span> t;</span><br></pre></td></tr></table></figure>

<h2 id="2-不使用子查询"><a href="#2-不使用子查询" class="headerlink" title="2 不使用子查询"></a>2 不使用子查询</h2><p>可以使用聚合函数SUM和case语句</p>
<p>例如 通过case语句把表做个变换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------+---------+-------+</span><br><span class="line">| id   | revenue | month |</span><br><span class="line">+------+---------+-------+</span><br><span class="line">| 1    | 8000    | Jan   |</span><br><span class="line">| 2    | 9000    | Jan   |</span><br><span class="line">| 3    | 10000   | Feb   |</span><br><span class="line">| 1    | 7000    | Feb   |</span><br><span class="line">| 1    | 6000    | Mar   |</span><br><span class="line">+------+---------+-------+</span><br></pre></td></tr></table></figure>

<p>变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id   Jan   Feb   Mar</span><br><span class="line">1    8000  null  null</span><br><span class="line">2    9000  null  null</span><br><span class="line">3    null  10000 null</span><br><span class="line">1    null  7000  null</span><br><span class="line">1    null  null  6000</span><br></pre></td></tr></table></figure>

<p>然后再对id分组求和即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;Jan&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Jan_Revenue,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;Feb&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Feb_Revenue,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;Mar&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Mar_Revenue,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;Apr&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Apr_Revenue,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;May&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> May_Revenue,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;Jun&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Jun_Revenue,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;Jul&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Jul_Revenue,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;Aug&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Aug_Revenue,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;Sep&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Sep_Revenue,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;Oct&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Oct_Revenue,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;Nov&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Nov_Revenue,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">month</span> <span class="keyword">when</span> <span class="string">&#x27;Dec&#x27;</span> <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Dec_Revenue</span><br><span class="line"><span class="keyword">from</span> department <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 12 Integer To Roman</title>
    <url>/2020/08/31/Leetcode/Leetcode%2012%20Integer%20To%20Roman/</url>
    <content><![CDATA[<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>
<ul>
<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li>
<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li>
<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>
</ul>
<p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: &quot;III&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: &quot;IX&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-🧠短路的做法"><a href="#1-🧠短路的做法" class="headerlink" title="1 🧠短路的做法"></a>1 🧠短路的做法</h2><p><strong>至今仍然想不明白为什么我不用数组存储这个映射, 而是用hashmap…… 代码又慢又长…或许需要重新new一个🧠了</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> ten = (num / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> hundred = (num / <span class="number">100</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> thousand = (num / <span class="number">1000</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> thousandDigit[thousand] + hundredDigit[hundred] + tenDigit[ten] + oneDigit[one];</span><br><span class="line">    &#125;</span><br><span class="line">    Solution()</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; thousandDigit;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; hundredDigit;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; tenDigit;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; oneDigit;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        thousandDigit.insert(&#123;<span class="number">0</span>,<span class="string">&quot;&quot;</span>&#125;);</span><br><span class="line">        thousandDigit.insert(&#123;<span class="number">1</span>,<span class="string">&quot;M&quot;</span>&#125;);</span><br><span class="line">        thousandDigit.insert(&#123;<span class="number">2</span>,<span class="string">&quot;MM&quot;</span>&#125;);</span><br><span class="line">        thousandDigit.insert(&#123;<span class="number">3</span>,<span class="string">&quot;MMM&quot;</span>&#125;);</span><br><span class="line">        hundredDigit.insert(&#123;<span class="number">0</span>,<span class="string">&quot;&quot;</span>&#125;);</span><br><span class="line">        hundredDigit.insert(&#123;<span class="number">1</span>,<span class="string">&quot;C&quot;</span>&#125;);</span><br><span class="line">        hundredDigit.insert(&#123;<span class="number">2</span>,<span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">        hundredDigit.insert(&#123;<span class="number">3</span>,<span class="string">&quot;CCC&quot;</span>&#125;);</span><br><span class="line">        hundredDigit.insert(&#123;<span class="number">4</span>,<span class="string">&quot;CD&quot;</span>&#125;);</span><br><span class="line">        hundredDigit.insert(&#123;<span class="number">5</span>,<span class="string">&quot;D&quot;</span>&#125;);</span><br><span class="line">        hundredDigit.insert(&#123;<span class="number">6</span>,<span class="string">&quot;DC&quot;</span>&#125;);</span><br><span class="line">        hundredDigit.insert(&#123;<span class="number">7</span>,<span class="string">&quot;DCC&quot;</span>&#125;);</span><br><span class="line">        hundredDigit.insert(&#123;<span class="number">8</span>,<span class="string">&quot;DCCC&quot;</span>&#125;);</span><br><span class="line">        hundredDigit.insert(&#123;<span class="number">9</span>,<span class="string">&quot;CM&quot;</span>&#125;);</span><br><span class="line">        tenDigit.insert(&#123;<span class="number">0</span>,<span class="string">&quot;&quot;</span>&#125;);</span><br><span class="line">        tenDigit.insert(&#123;<span class="number">1</span>,<span class="string">&quot;X&quot;</span>&#125;);</span><br><span class="line">        tenDigit.insert(&#123;<span class="number">2</span>,<span class="string">&quot;XX&quot;</span>&#125;);</span><br><span class="line">        tenDigit.insert(&#123;<span class="number">3</span>,<span class="string">&quot;XXX&quot;</span>&#125;);</span><br><span class="line">        tenDigit.insert(&#123;<span class="number">4</span>,<span class="string">&quot;XL&quot;</span>&#125;);</span><br><span class="line">        tenDigit.insert(&#123;<span class="number">5</span>,<span class="string">&quot;L&quot;</span>&#125;);</span><br><span class="line">        tenDigit.insert(&#123;<span class="number">6</span>,<span class="string">&quot;LX&quot;</span>&#125;);</span><br><span class="line">        tenDigit.insert(&#123;<span class="number">7</span>,<span class="string">&quot;LXX&quot;</span>&#125;);</span><br><span class="line">        tenDigit.insert(&#123;<span class="number">8</span>,<span class="string">&quot;LXXX&quot;</span>&#125;);</span><br><span class="line">        tenDigit.insert(&#123;<span class="number">9</span>,<span class="string">&quot;XC&quot;</span>&#125;);</span><br><span class="line">        oneDigit.insert(&#123;<span class="number">0</span>,<span class="string">&quot;&quot;</span>&#125;);</span><br><span class="line">        oneDigit.insert(&#123;<span class="number">1</span>,<span class="string">&quot;I&quot;</span>&#125;);</span><br><span class="line">        oneDigit.insert(&#123;<span class="number">2</span>,<span class="string">&quot;II&quot;</span>&#125;);</span><br><span class="line">        oneDigit.insert(&#123;<span class="number">3</span>,<span class="string">&quot;III&quot;</span>&#125;);</span><br><span class="line">        oneDigit.insert(&#123;<span class="number">4</span>,<span class="string">&quot;IV&quot;</span>&#125;);</span><br><span class="line">        oneDigit.insert(&#123;<span class="number">5</span>,<span class="string">&quot;V&quot;</span>&#125;);</span><br><span class="line">        oneDigit.insert(&#123;<span class="number">6</span>,<span class="string">&quot;VI&quot;</span>&#125;);</span><br><span class="line">        oneDigit.insert(&#123;<span class="number">7</span>,<span class="string">&quot;VII&quot;</span>&#125;);</span><br><span class="line">        oneDigit.insert(&#123;<span class="number">8</span>,<span class="string">&quot;VIII&quot;</span>&#125;);</span><br><span class="line">        oneDigit.insert(&#123;<span class="number">9</span>,<span class="string">&quot;IX&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-正确做法"><a href="#2-正确做法" class="headerlink" title="2 正确做法"></a>2 正确做法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> ten = (num / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> hundred = (num / <span class="number">100</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> thousand = (num / <span class="number">1000</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> thousandDigit[thousand] + hundredDigit[hundred] + tenDigit[ten] + oneDigit[one];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> thousandDigit[<span class="number">4</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">string</span> hundredDigit[<span class="number">10</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">string</span> tenDigit[<span class="number">10</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">string</span> oneDigit[<span class="number">10</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 122 Best Time To Buy And Sell Stock II</title>
    <url>/2020/07/18/Leetcode/Leetcode%20122%20Best%20Time%20To%20Buy%20And%20Sell%20Stock%20II/</url>
    <content><![CDATA[<p>Say you have an array <code>prices</code> for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">             Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li>
</ul>
<a id="more"></a>
<h2 id="1-动态规划-超时"><a href="#1-动态规划-超时" class="headerlink" title="1 动态规划(超时)"></a>1 动态规划(超时)</h2><p>思路是 维护一个数组maxSubProfit</p>
<p>maxSubProfit(index) 代表从0到index的子数组的最大profit</p>
<p>可以发现，子数组得到最大profit时必定是已经卖出的状态(因为假如到达index天还持有stocks，在index当天卖出后的profit一定大于这种情况)</p>
<p>所以，从第0天到第index+1天的最大profit可以用 第0天到第index天，第0天到第index-1天， …  ，第0天到第0天表示为如下几者的最大值</p>
<ul>
<li>从第0天到第index - 1天的最大值 （因为与index只差一天，无法完成购买和卖出stocks的操作）</li>
<li>从第0天到第i 天的profit最大值(i = index - 2 : 0) 加上第i + 1天买股票第index卖出获得的profit(如果这个不赚钱就加0)</li>
<li>第0天买入中间不做任何操作，第index天卖出。（比较这个是因为防止stock价格一直递增导致的漏解）</li>
</ul>
<p>将index设置为prices.size() - 1即可获得最终结果</p>
<p>此方法每计算一个index需要前面从0到index - 1的值来判断index次，复杂度O(n^2)</p>
<p>（我自己以为这么复杂的题复杂度降低到n^2已经可以了，暴力法要O(n*2^n)的复杂度(列举所有的方法2^n复杂度, 对每一种方法计算profit的平均复杂度为n/2)，事实上用O(n) 的复杂度就可以解决）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSubProfit</span><span class="params">(prices.<span class="built_in">size</span>(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> getSubMaxProfit(prices, maxSubProfit, prices.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSubMaxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; maxSubProfit, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxSubProfit[index] &gt; <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> maxSubProfit[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSubProfit[index] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> maxSubProfit[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSubProfit[index] = <span class="built_in">max</span>(<span class="number">0</span>, prices[<span class="number">1</span>] - prices[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> maxSubProfit[index];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        assert(index &gt;= <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> profit_iBuy_indexSell = <span class="built_in">max</span>(<span class="number">0</span>,prices[index] - prices[i]);</span><br><span class="line">            <span class="keyword">int</span> total_profit = getSubMaxProfit(prices, maxSubProfit,i - <span class="number">1</span>) + profit_iBuy_indexSell;</span><br><span class="line">            <span class="keyword">if</span>(total_profit &gt; maxProfit)</span><br><span class="line">                maxProfit = total_profit;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> profit_indexMinus1 = getSubMaxProfit(prices,maxSubProfit,index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(maxProfit &lt; profit_indexMinus1)</span><br><span class="line">            maxProfit = profit_indexMinus1;</span><br><span class="line">        <span class="keyword">int</span> buy1_sellindex = prices[index] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(maxProfit &lt; buy1_sellindex)</span><br><span class="line">            maxProfit = buy1_sellindex;</span><br><span class="line">        maxSubProfit[index] = maxProfit;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-贪心算法"><a href="#2-贪心算法" class="headerlink" title="2 贪心算法"></a>2 贪心算法</h2><p>观察到要想赚的最多，只需要在所有上升的区间左边买入，右边卖出。为了防止卖出卖早了，所以要直到价格下跌的前一天才卖。价格下跌的当天就再买入，看看后面价格上升吗，如果不上升就撤销上一次买入，并且这一次再购买，上升就再等到价格下跌的前一天再卖出。这种做法对于任意一个价格上升的区间都能赚到，加起来显然是profit最多的。</p>
<p>这种方法相当于找到数组中所有递增的区间，时间复杂度显然是O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">0</span> || prices.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//buy stocks at the first day</span></span><br><span class="line">        <span class="keyword">int</span> profit = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> previous = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> isIncreasing = (previous &lt; prices[i]);</span><br><span class="line">            <span class="keyword">if</span>(isIncreasing)  <span class="comment">//if increase, don&#x27;t sell wait the maximun price</span></span><br><span class="line">            &#123;</span><br><span class="line">                ; <span class="comment">//do nothing but refresh the previous var</span></span><br><span class="line">                previous = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>   <span class="comment">//if found decrease, sell the stocks at yesterday&#x27;s price and buy today&#x27;s stock</span></span><br><span class="line">            &#123;</span><br><span class="line">                profit += previous;</span><br><span class="line">                profit -= prices[i];</span><br><span class="line">                previous = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> isLastDay = (i == prices.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//if today is the last day, stocks must be sold out, since you don&#x27;t have anymore chance to sell them.</span></span><br><span class="line">            <span class="keyword">if</span>(isLastDay) </span><br><span class="line">            &#123;</span><br><span class="line">                profit += prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 125 Valid Palindrome</title>
    <url>/2020/09/21/Leetcode/Leetcode%20125%20Valid%20Palindrome/</url>
    <content><![CDATA[<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p><strong>Note:</strong> For the purpose of this problem, we define empty string as valid palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>s</code> consists only of printable ASCII characters.</li>
</ul>
<a id="more"></a>
<h2 id="1-构造新的字符串"><a href="#1-构造新的字符串" class="headerlink" title="1 构造新的字符串"></a>1 构造新的字符串</h2><p>先构造一个新的字符串tmp, 储存原字符串删掉非alpha num类型的字符并且全变为小写的字符. 然后在判断tmp是不是palindrome.</p>
<p>但是这需要额外的空间复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">isalnum</span>(i))</span><br><span class="line">                tmp.push_back(<span class="built_in">tolower</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>() / <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i] != tmp[tmp.<span class="built_in">size</span>() - <span class="number">1</span> - i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-在原字符串上直接判断"><a href="#2-在原字符串上直接判断" class="headerlink" title="2 在原字符串上直接判断"></a>2 在原字符串上直接判断</h2><p>思路是, 使用两个指针, left和right. 每一次比较left和right指向的值是否相等. 当left &gt;= right时停止迭代.</p>
<p>更新left和right的时候, 跳过非字母和数字的字符. </p>
<p>但是要注意没有任何字母数字的字符串的判断 <code>&quot;,:&quot;</code>这样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; s.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; !<span class="built_in">std</span>::<span class="built_in">isalnum</span>(s[left]))</span><br><span class="line">                ++left;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; <span class="number">0</span> &amp;&amp; !<span class="built_in">std</span>::<span class="built_in">isalnum</span>(s[right]))</span><br><span class="line">                --right;</span><br><span class="line">            <span class="keyword">if</span>(left == s.<span class="built_in">size</span>() - <span class="number">1</span>)  <span class="comment">//make string likes this &quot;,:&quot; true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">tolower</span>(s[left]) == <span class="built_in">std</span>::<span class="built_in">tolower</span>(s[right]))</span><br><span class="line">            &#123;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 121 Best Time To Buy And Sell Stock</title>
    <url>/2020/07/18/Leetcode/Leetcode%20121%20Best%20Time%20To%20Buy%20And%20Sell%20Stock/</url>
    <content><![CDATA[<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.</span><br><span class="line">             Not 7-1 &#x3D; 6, as selling price needs to be larger than buying price.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>设立两个变量 profit 和 min</p>
<p>对于i 从0 遍历到price.size()-1, profit存储了从0到i的最大利润，min存储了从0到i的最小值。</p>
<p>当i更新到i+1时，重新计算i+1是否是更小的值，与前面的min比较。同时计算i+1的加入是否产生了更大的profit。 price[i+1]-min与profit比较。</p>
<ul>
<li>此题可以这样做的关键在于，对于第i+1个加入的元素，只需要前i个元素中的最小值即可求出maxprofit，能在O(1)时间完成</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> profit = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; <span class="built_in">min</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">min</span> = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> profit_at_index_i = prices[i] - <span class="built_in">min</span>;</span><br><span class="line">            <span class="keyword">if</span>(profit_at_index_i &gt; profit)</span><br><span class="line">            &#123;</span><br><span class="line">                profit = profit_at_index_i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 129 Sum Root To Leaf Numbers</title>
    <url>/2020/10/20/Leetcode/Leetcode%20129%20Sum%20Root%20To%20Leaf%20Numbers/</url>
    <content><![CDATA[<p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum &#x3D; 12 + 13 &#x3D; 25.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>直接深度优先搜索到所有的叶子节点, 然后把这些叶子节点上的值都加起来即可.</p>
<p>可惜java没法传引用, 只能定制一个包装类IntegerWrapper. 用这种方式实现int参数的修改</p>
<p>如果是c++的话会方便得多. 直接<code>private void sumNumbers(int&amp; sum, int&amp; curr, TreeNode* root)</code>就完事了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        IntegerWrapper sum = <span class="keyword">new</span> IntegerWrapper();</span><br><span class="line">        IntegerWrapper curr = <span class="keyword">new</span> IntegerWrapper();</span><br><span class="line">        sumNumbers(sum, curr, root);</span><br><span class="line">        <span class="keyword">return</span> sum.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sumNumbers</span><span class="params">(IntegerWrapper sum, IntegerWrapper curr, TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curr.set(curr.get() * <span class="number">10</span>);</span><br><span class="line">            curr.set(curr.get() + root.val);</span><br><span class="line">            sum.set(sum.get() + curr.get());</span><br><span class="line">            curr.set(curr.get() / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            curr.set(curr.get() * <span class="number">10</span>);</span><br><span class="line">            curr.set(curr.get() + root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                sumNumbers(sum, curr, root.left);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                sumNumbers(sum, curr, root.right);</span><br><span class="line">            curr.set(curr.get() / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerWrapper</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = Integer.valueOf(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 127 Word Ladder</title>
    <url>/2020/10/20/Leetcode/Leetcode%20127%20Word%20Ladder/</url>
    <content><![CDATA[<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;</span><br><span class="line">endWord &#x3D; &quot;cog&quot;</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1 暴力"></a>1 暴力</h2><p>暴力地构造一个邻接矩阵图, 用BFS求最短距离.</p>
<p>时间复杂度是O(m*n^2) m是单词长度， n是wordList长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] dist;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] isTraversed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        init(beginWord, endWord, wordList);</span><br><span class="line">        <span class="keyword">int</span> shortest = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(<span class="number">0</span>);</span><br><span class="line">        isTraversed[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> currSize = q.size();</span><br><span class="line">            <span class="keyword">while</span>(currSize != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = q.poll();</span><br><span class="line">                --currSize;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dist[curr][i] == <span class="number">1</span> &amp;&amp; !isTraversed[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(list.get(i).equals(endWord))</span><br><span class="line">                            <span class="keyword">return</span> shortest + <span class="number">2</span>;</span><br><span class="line">                        q.offer(i);</span><br><span class="line">                        isTraversed[i] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++shortest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(beginWord);</span><br><span class="line">        list.addAll(wordList);</span><br><span class="line">        dist = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()][list.size()];</span><br><span class="line">        isTraversed = <span class="keyword">new</span> <span class="keyword">boolean</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i][j] = (i &gt; j) ? dist[j][i] : getDist(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDist</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        String s1 = list.get(i);</span><br><span class="line">        String s2 = list.get(j);</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s1.length(); ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(k) != s2.charAt(k))</span><br><span class="line">                ++dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-一次字符变化-BFS"><a href="#2-一次字符变化-BFS" class="headerlink" title="2 一次字符变化 + BFS"></a>2 一次字符变化 + BFS</h2><p>来源 <a href="https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/">https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/</a></p>
<p>首先要构造通用状态到所有单词的映射map. 例如, dog的通用状态就有3个, <code>*og, d*g, do*</code>. 如果两个单词有一个相同的通用状态, 那么这两个单词就是相通的. 例如dog, dig 有相同的通用状态d*g</p>
<p>而map就存储了任意一个给定的通用状态都对应了哪些单词.</p>
<p>例如, <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code>就对应了下面的map</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d*g -&gt; dog </span><br><span class="line">c*g -&gt; cog </span><br><span class="line">ho* -&gt; hot </span><br><span class="line">*og -&gt; log cog dog </span><br><span class="line">h*t -&gt; hot </span><br><span class="line">lo* -&gt; lot log </span><br><span class="line">l*t -&gt; lot </span><br><span class="line">l*g -&gt; log </span><br><span class="line">do* -&gt; dot dog </span><br><span class="line">*ot -&gt; lot dot hot </span><br><span class="line">d*t -&gt; dot </span><br><span class="line">co* -&gt; cog </span><br></pre></td></tr></table></figure>

<p>那么, 我们从beginWord = “hit”开始, 首先将元组(hit, 1)放入队列,</p>
<p>取出(hit,1), 找到hit所有的通用状态, <code>*it, h*t, hi*</code>, 发现只有<code>h*t</code>在map里面, 就把<code>h*t</code>对应的所有单词都加入到队列里面, 同时, distance要加1, 即(hot, 2)加入到队列中, 并且将hot标记为已经遍历过的. 这时, 队列中只有(hot,2)</p>
<p>然后取出(hot, 2), 找到hot所有通用状态, <code>*ot, h*t, ho*</code>. 对应的所有单词为<code>lot, dot, hot, hot, hot</code>. 这时hot已经遍历过了, 就只把(lot, 3), (dot,3)加入队列, 并设置lot和dot为已经遍历过的.</p>
<p>以此类推, 直到取出的值等于endWord. 返回元组第二个元素.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Set&lt;String&gt;&gt; map;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Boolean&gt; isVisited = <span class="keyword">new</span> HashMap&lt;&gt;();;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        init(wordList);</span><br><span class="line">        Queue&lt;Pair&lt;String, Integer&gt;&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(<span class="keyword">new</span> Pair&lt;String, Integer&gt;(beginWord, <span class="number">1</span>));</span><br><span class="line">        isVisited.put(beginWord, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            Pair&lt;String, Integer&gt; pair = q.poll();</span><br><span class="line">            String s = pair.getKey();</span><br><span class="line">            <span class="keyword">if</span>(endWord.equals(s))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> pair.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                String wildCard_s = s.substring(<span class="number">0</span>,i) + <span class="string">&quot;*&quot;</span> + s.substring(i+<span class="number">1</span>, s.length());</span><br><span class="line">                Set&lt;String&gt; adjacentStrings = map.get(wildCard_s);</span><br><span class="line">                <span class="keyword">if</span>(adjacentStrings == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(String diff1char_s : adjacentStrings)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(isVisited.get(diff1char_s) != <span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//string has already been traversed </span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> Pair&lt;String, Integer&gt;(diff1char_s, pair.getValue() + <span class="number">1</span>));</span><br><span class="line">                    isVisited.put(diff1char_s, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(List&lt;String&gt; wordList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : wordList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                String wildCard_s = str.substring(<span class="number">0</span>,i) + <span class="string">&quot;*&quot;</span> + str.substring(i + <span class="number">1</span>, str.length());</span><br><span class="line">                map.putIfAbsent(wildCard_s, <span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">                map.get(wildCard_s).add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-双向BFS"><a href="#3-双向BFS" class="headerlink" title="3 双向BFS"></a>3 双向BFS</h2><p>为了解决BFS搜索的越来越多, 使用双向BFS搜索.</p>
<p>这时要建立两个队列qBegin, qEnd用来遍历了. 一个从头开始遍历, 一个从尾开始遍历.</p>
<p>同时, 为了标记哪个节点已经被遍历过了, 要创建2个map, beginVisited和endVisited. 如果某个节点从头开始遍历过了, 就把他放到beginVisit里面, 对应的值为到beginWord的距离. 对于endVisited同理.</p>
<p>同时要写一个辅助函数<code>int visitWord(Queue&lt;Pair&lt;String, Integer&gt;&gt; currQ, Map&lt;String, Integer&gt; currMap, Map&lt;String, Integer&gt; anotherMap)</code></p>
<p>这个函数的作用是 以当前的currQ为队列, 从队列中取出来一个值, 这个值的所有通用状态对应的字符串(即所有变换一个字符可以得到的字符串)记为集合S, 如果S里面至少有一个值在anotherMap里面, 就说明当前的遍历首位相接了. 直接返回两端的距离之和就可以了.</p>
<p>如果S里面的值都不在anotherMap里, 说明还没到可以和另外一个遍历相接. 就按照普通的BFS更新currQ和currMap. 返回-1.</p>
<p><code>visitWord(qBegin, beginVisited, endVisited);</code>和<code>visitWord(qEnd, endVisited, beginVisited);</code>在一个循环里先后调用, 往中间凑.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Set&lt;String&gt;&gt; map;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; beginVisited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; endVisited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!wordList.contains(endWord))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        init(wordList);</span><br><span class="line">        Queue&lt;Pair&lt;String, Integer&gt;&gt; qBegin = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Queue&lt;Pair&lt;String, Integer&gt;&gt; qEnd = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        qBegin.offer(<span class="keyword">new</span> Pair&lt;String, Integer&gt;(beginWord, <span class="number">1</span>));</span><br><span class="line">        beginVisited.put(beginWord,<span class="number">1</span>);</span><br><span class="line">        qEnd.offer(<span class="keyword">new</span> Pair&lt;String, Integer&gt;(endWord, <span class="number">1</span>));</span><br><span class="line">        endVisited.put(endWord,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!qBegin.isEmpty() &amp;&amp; !qEnd.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = visitWord(qBegin, beginVisited, endVisited);</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = visitWord(qEnd, endVisited, beginVisited);</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; -<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(List&lt;String&gt; wordList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : wordList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                String wildCard_s = str.substring(<span class="number">0</span>,i) + <span class="string">&quot;*&quot;</span> + str.substring(i + <span class="number">1</span>, str.length());</span><br><span class="line">                map.putIfAbsent(wildCard_s, <span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">                map.get(wildCard_s).add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">visitWord</span><span class="params">(Queue&lt;Pair&lt;String, Integer&gt;&gt; currQ, Map&lt;String, Integer&gt; currMap, Map&lt;String, Integer&gt; anotherMap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Pair&lt;String, Integer&gt; pair = currQ.poll();</span><br><span class="line">        String str = pair.getKey();</span><br><span class="line">        Integer value = pair.getValue();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            String wildCard_s = str.substring(<span class="number">0</span>,i) + <span class="string">&quot;*&quot;</span> + str.substring(i+<span class="number">1</span>, str.length());</span><br><span class="line">            <span class="keyword">if</span>(map.get(wildCard_s) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(String diff1char_s : map.get(wildCard_s))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(anotherMap.containsKey(diff1char_s))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> anotherMap.get(diff1char_s) + value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!currMap.containsKey(diff1char_s))</span><br><span class="line">                &#123;</span><br><span class="line">                    currMap.put(diff1char_s, value + <span class="number">1</span>);</span><br><span class="line">                    currQ.offer(<span class="keyword">new</span> Pair&lt;String, Integer&gt;(diff1char_s, value + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 13 Roman To Integer</title>
    <url>/2020/08/31/Leetcode/Leetcode%2013%20Roman%20To%20Integer/</url>
    <content><![CDATA[<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>
<ul>
<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li>
<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li>
<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>
</ul>
<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="一遍扫描"><a href="#一遍扫描" class="headerlink" title="一遍扫描"></a>一遍扫描</h2><p>先构建一个字符到整数的映射, 扫描的时候<strong>碰到某个字符就加或减其对应的值</strong></p>
<p>关键是如何确定加还是减</p>
<p>发现, 只需要比较第i位的字符和第i+1位的字符大小即可</p>
<blockquote>
<p>例如, IX中, I &lt; X, 所以I为-1而不是1.</p>
<p>MCMXCIV 中, 第一个C后面是M, 而C &lt; M, 这时C就代表-100, 第二个C后面是I, C &gt; I, 这时C就代表100.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == s.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += charToInt[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> isNegative = (charToInt[s[i]] &lt; charToInt[s[i+<span class="number">1</span>]]);</span><br><span class="line">                ans += isNegative ? -charToInt[s[i]] : charToInt[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Solution()</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; charToInt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        charToInt.insert(&#123;<span class="string">&#x27;I&#x27;</span>,<span class="number">1</span>&#125;);</span><br><span class="line">        charToInt.insert(&#123;<span class="string">&#x27;V&#x27;</span>,<span class="number">5</span>&#125;);</span><br><span class="line">        charToInt.insert(&#123;<span class="string">&#x27;X&#x27;</span>,<span class="number">10</span>&#125;);</span><br><span class="line">        charToInt.insert(&#123;<span class="string">&#x27;L&#x27;</span>,<span class="number">50</span>&#125;);</span><br><span class="line">        charToInt.insert(&#123;<span class="string">&#x27;C&#x27;</span>,<span class="number">100</span>&#125;);</span><br><span class="line">        charToInt.insert(&#123;<span class="string">&#x27;D&#x27;</span>,<span class="number">500</span>&#125;);</span><br><span class="line">        charToInt.insert(&#123;<span class="string">&#x27;M&#x27;</span>,<span class="number">1000</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 130 Surrounded Regions</title>
    <url>/2020/10/20/Leetcode/Leetcode%20130%20Surrounded%20Regions/</url>
    <content><![CDATA[<p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>
<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p>After running your function, the board should be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p><strong>Explanation:</strong></p>
<p>Surrounded regions shouldn’t be on the border, which means that any <code>&#39;O&#39;</code> on the border of the board are not flipped to <code>&#39;X&#39;</code>. Any <code>&#39;O&#39;</code> that is not on the border and it is not connected to an <code>&#39;O&#39;</code> on the border will be flipped to <code>&#39;X&#39;</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
<a id="more"></a>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>关键是读懂题意. 这题读懂题意之后就很好做了</p>
<p>对于内部的一个点’O’, 我们判断某个这个块是否到达边界是不好判定的.</p>
<p>但是可以从边界开始找, 找到四周边界上所有O组成的块, 将他们置为P, 然后遍历二维数组, O变为X, P变为O.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X P X X</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> M = board.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            setOtoP(board, <span class="number">0</span>, j);</span><br><span class="line">            setOtoP(board, M - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            setOtoP(board, i, <span class="number">0</span>);</span><br><span class="line">            setOtoP(board, i, N - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOtoP</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isLocationValid(board, i, j) &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">            setOtoP(board, i + <span class="number">1</span>, j);</span><br><span class="line">            setOtoP(board, i - <span class="number">1</span>, j);</span><br><span class="line">            setOtoP(board, i, j + <span class="number">1</span>);</span><br><span class="line">            setOtoP(board, i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLocationValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = board.length;</span><br><span class="line">        <span class="keyword">int</span> N = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> i &gt; -<span class="number">1</span> &amp;&amp; i &lt; M &amp;&amp; j &gt; -<span class="number">1</span> &amp;&amp; j &lt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 131 Palindrome Partitioning</title>
    <url>/2020/10/21/Leetcode/Leetcode%20131%20Palindrome%20Partitioning/</url>
    <content><![CDATA[<p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of <em>s</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1 动态规划"></a>1 动态规划</h2><p><strong>这道题感觉和leetcode 93差不多, 都是那种求所有可能的解的. 用了动态规划更慢, 还是老老实实用DFS吧</strong></p>
<p><strong>只有那种求最大, 求最小的问题用动态规划才合适.</strong></p>
<p>dp[i]表示从0到i的字串所形成的所有palindrome partitioning</p>
<p>例如 对于”aab” <code>dp[0] = [[a]], dp[1] = [[a,a], [aa]], dp[2] = [[a,a,b], [aa,b]]</code></p>
<p>那么如果求出了dp[0]到dp[i-1], 就可以根据这些信息生成dp[i]. 步骤如下</p>
<blockquote>
<p>如果从0到i的子串是回文串, 就把这个子串单独组成的list加入到dp[i]中</p>
<p>如果从j到i的字串是回文串(j &gt; 0), 首先找到从0到j-1的所有回文列表, 每个列表都加上从j到i的字串<code>string.substring(j, i+1)</code> 然后将这些列表add到dp[i]中.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = s.length();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt;[] dp = (List&lt;List&lt;String&gt;&gt;[]) <span class="keyword">new</span> List[n];</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; dp0 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dp0.add(Arrays.asList(<span class="string">&quot;&quot;</span> + s.charAt(<span class="number">0</span>)));</span><br><span class="line">        dp[<span class="number">0</span>] = dp0;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;List&lt;String&gt;&gt; currLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(isPalindromic(s.substring(<span class="number">0</span>, i + <span class="number">1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                currLists.add(Arrays.asList(s.substring(<span class="number">0</span>, i + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindromic(s.substring(j, i + <span class="number">1</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;List&lt;String&gt;&gt; prevLists = dp[j-<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">for</span>(List&lt;String&gt; prevList : prevLists)</span><br><span class="line">                    &#123;</span><br><span class="line">                        List&lt;String&gt; currList = <span class="keyword">new</span> ArrayList&lt;&gt;(prevList);</span><br><span class="line">                        currList.add(s.substring(j, i + <span class="number">1</span>));</span><br><span class="line">                        currLists.add(currList);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = currLists;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindromic</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2 DFS"></a>2 DFS</h2><p>直接用DFS寻找所有的可能. 看上去是暴力解法, 但是这是最快的了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        partition(ans, curr, s);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; curr, String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(s))</span><br><span class="line">        &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindromic(s.substring(<span class="number">0</span>, i + <span class="number">1</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    curr.add(s.substring(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">                    partition(ans, curr, s.substring(i+<span class="number">1</span>, s.length()));</span><br><span class="line">                    curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindromic</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 134 Gas Station</title>
    <url>/2020/10/17/Leetcode/Leetcode%20134%20Gas%20Station/</url>
    <content><![CDATA[<p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<p><strong>Note:</strong></p>
<ul>
<li>If there exists a solution, it is guaranteed to be unique.</li>
<li>Both input arrays are non-empty and have the same length.</li>
<li>Each element in the input arrays is a non-negative integer.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  &#x3D; [1,2,3,4,5]</span><br><span class="line">cost &#x3D; [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 4. Your tank &#x3D; 4 - 1 + 5 &#x3D; 8</span><br><span class="line">Travel to station 0. Your tank &#x3D; 8 - 2 + 1 &#x3D; 7</span><br><span class="line">Travel to station 1. Your tank &#x3D; 7 - 3 + 2 &#x3D; 6</span><br><span class="line">Travel to station 2. Your tank &#x3D; 6 - 4 + 3 &#x3D; 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  &#x3D; [2,3,4]</span><br><span class="line">cost &#x3D; [3,4,3]</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">You can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&#39;s start at station 2 and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 0. Your tank &#x3D; 4 - 3 + 2 &#x3D; 3</span><br><span class="line">Travel to station 1. Your tank &#x3D; 3 - 3 + 3 &#x3D; 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&#39;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-贪心1"><a href="#1-贪心1" class="headerlink" title="1 贪心1"></a>1 贪心1</h2><p>首先很明显的一点就是 如果sum(gas) &lt; sum(cost), 是没办法跑完一圈的.</p>
<p>然后, 我们构造一个新数组gas1, 其中gas1[i] = gas[i] - cost[i]</p>
<p>这个数组gas1表示了每经过一个station的消耗. 如果gas1[i] &gt; 0, 就说明经过这个station的gas多于cost.</p>
<blockquote>
<p>例如 gas  = [1,2,3,4,5], cost = [3,4,5,1,2], 那么新的gas1 = [-2,-2,-2, 3, 3]. </p>
</blockquote>
<p>对于上面的gas1, 我们显然应该要选择从第1个3出发, 这样才能积攒到足够多的油, 来支撑走完全程.</p>
<p>所以, 要从<strong>循环数组中最大子序列的开始位置出发</strong>, 只有这样才能积累足够多的油, 支撑跑完一圈.</p>
<p>下面证明这个结论</p>
<blockquote>
<p>假设数组的最大子数组是从0开始, k结束. 数组其余部分是从k+1开始, 从n结束.</p>
<p>对于一般情况, 容易证明通过平移可以得到上面的形式.</p>
<p>我们用反证法, </p>
<p>假如从最大子数组积累的油不够支撑到到达节点j, 即<code>sum(0,j) &lt; 0</code> (j &gt; k). 这里简记<code>sum(i,j)</code>为数组从第i个元素到第j个元素的求和. </p>
<p>由于整个数组的和<code>sum(0, n) &gt;= 0</code>(这是由<code>sum(gas) &gt;= sum(cost)</code>保证的.)</p>
<p>而又有<code>sum(0,j) &lt; 0</code>, 所以就能推出<code>sum(j+1,n) &gt; 0</code>. </p>
<p>既然<code>sum(j+1,n) &gt; 0</code>, 那么从0到k的子数组就不是最大子数组了. 因为加上j+1到n这一段后会更大. 推出矛盾</p>
<p>所以只能是对于任意的j, (<code>k &lt; j &lt; n</code>), <code>sum(0,j) &gt; 0</code> 也就是有足够的油跑到j. </p>
</blockquote>
<p>至于如何求循环数组的最大子序列的开始位置, 可以将两个gas1首尾连接拼成一个大的数组, 然后再进行普通的数组求最大子序列开始位置的计算. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum_gas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum_cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : gas)</span><br><span class="line">            sum_gas += i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : cost)</span><br><span class="line">            sum_cost += i;</span><br><span class="line">        <span class="keyword">if</span>(sum_cost &gt; sum_gas)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; ++i)</span><br><span class="line">            gas[i] -= cost[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] doubleGas = <span class="keyword">new</span> <span class="keyword">int</span>[gas.length * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : gas)</span><br><span class="line">            doubleGas[k++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : gas)</span><br><span class="line">            doubleGas[k++] = i;</span><br><span class="line">        <span class="keyword">int</span> maxSubarray = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSubarrayBeginLocation = doubleGas.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = doubleGas.length - <span class="number">1</span>; i &gt; -<span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            curr = curr + doubleGas[i];</span><br><span class="line">            <span class="keyword">if</span>(curr &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(curr &gt; maxSubarray)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxSubarray = curr;</span><br><span class="line">                    maxSubarrayBeginLocation = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSubarrayBeginLocation % gas.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-贪心2"><a href="#2-贪心2" class="headerlink" title="2 贪心2"></a>2 贪心2</h2><p><a href="https://leetcode-cn.com/problems/gas-station/solution/guan-fang-ti-jie-kan-qi-lai-hao-fu-za-lai-kan-yi-k/">https://leetcode-cn.com/problems/gas-station/solution/guan-fang-ti-jie-kan-qi-lai-hao-fu-za-lai-kan-yi-k/</a></p>
<p>这个方法更巧妙, 用1次遍历就解决了所有的问题. 找到从0开始的最小子数组的结束位置i, 然后剔除掉这个子数组, 使得这个子数组最后才会被遍历. 从i+1开始.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> endIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sumFrom0Toi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = gas[i] - cost[i];</span><br><span class="line">            sumFrom0Toi += a;</span><br><span class="line">            <span class="keyword">if</span>(sumFrom0Toi &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = sumFrom0Toi;</span><br><span class="line">                endIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sumFrom0Toi &gt;= <span class="number">0</span>) ? (endIndex + <span class="number">1</span>) % gas.length : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 136 Single Number</title>
    <url>/2020/10/02/Leetcode/Leetcode%20136%20Single%20Number/</url>
    <content><![CDATA[<p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>这题和leetcode 268一样. 利用一个数异或某个数两次, 等于没异或.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">            a ^= i;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 138 Copy List With Random Pointer</title>
    <url>/2020/10/20/Leetcode/Leetcode%20138%20Copy%20List%20With%20Random%20Pointer/</url>
    <content><![CDATA[<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy"><strong>deep copy</strong></a> of the list.</p>
<p>The Linked List is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>
<ul>
<li><code>val</code>: an integer representing <code>Node.val</code></li>
<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) where random pointer points to, or <code>null</code> if it does not point to any node.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/12/18/e1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/12/18/e2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [[1,1],[2,1]]</span><br><span class="line">Output: [[1,1],[2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/e3.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">Output: [[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br><span class="line">Explanation: Given linked list is empty (null pointer), so return null.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>
<li><code>Node.random</code> is null or pointing to a node in the linked list.</li>
<li>The number of nodes will not exceed 1000.</li>
</ul>
<a id="more"></a>
<h2 id="1-数组-hashtable"><a href="#1-数组-hashtable" class="headerlink" title="1 数组 + hashtable"></a>1 数组 + hashtable</h2><p>首先建立一个<code>hashmap&lt;Node, i&gt;</code>, 对应着链表的某个节点在第i个位置上. (从0开始计数)</p>
<p>然后新建一个Node数组, 每个数组都new一个新的Node. 链表遍历一遍, 把链表第i个节点的值复制到数组第i个元素上.</p>
<p>然后数组遍历一遍, 数组第i个元素的next指向数组第i+1个元素.</p>
<p>然后链表遍历一遍, 对于遍历的每一个元素node, 找到这个元素在链表中的位置i, 同时找到node.random在链表中的位置j.</p>
<p>最后在数组中添加<code>nodes[i].random = nodes[j]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;Node, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> locationInList = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node i = head; i != <span class="keyword">null</span>; i = i.next)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(i, locationInList);</span><br><span class="line">            ++locationInList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = locationInList;</span><br><span class="line">        Node[] nodes = <span class="keyword">new</span> Node[len];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node i = head; i != <span class="keyword">null</span>; i = i.next)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes[k++] = <span class="keyword">new</span> Node(i.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes[i].next = nodes[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Node i = head; i != <span class="keyword">null</span>; i = i.next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> iLocation = map.get(i);</span><br><span class="line">            <span class="keyword">if</span>(i.random == <span class="keyword">null</span>)</span><br><span class="line">                nodes[iLocation].random = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> iRandomLocation = map.get(i.random);</span><br><span class="line">                nodes[iLocation].random = nodes[iRandomLocation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-hashtable"><a href="#2-hashtable" class="headerlink" title="2 hashtable"></a>2 hashtable</h2><p>经过1的分析, 发现可以不用那个数组. 直接建立一个原Node到新Node的映射即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node newHead = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">        Node tail = newHead;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Node i = head; i != <span class="keyword">null</span>; i = i.next)</span><br><span class="line">        &#123;</span><br><span class="line">            Node j = <span class="keyword">new</span> Node(i.val);</span><br><span class="line">            map.put(i,j);</span><br><span class="line">            tail.next = j;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node i = head;</span><br><span class="line">        Node j = newHead.next;</span><br><span class="line">        <span class="keyword">while</span>(i != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node iRandom = i.random;</span><br><span class="line">            Node jRandom = map.get(iRandom);</span><br><span class="line">            j.random = jRandom;</span><br><span class="line">            i = i.next;</span><br><span class="line">            j = j.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-利用链表作为映射"><a href="#3-利用链表作为映射" class="headerlink" title="3 利用链表作为映射"></a>3 利用链表作为映射</h2><p>这方法太巧妙了(日常感叹答案的巧妙哈哈哈). </p>
<p>对于原链表<code>a-&gt;b-&gt;c</code>, 我们仍然需要原链表某一个节点到对应链表的节点的映射.</p>
<p>这时, 把新链表的那个节点都插入到原链表对应节点的后面, 变成<code>a-&gt;a&#39;-&gt;b-&gt;b&#39;-&gt;c-&gt;c&#39;</code></p>
<p><strong>这样不需要hashtable也能存储原来的映射了!!!</strong></p>
<p>首先要重新赋值新链表的random指针, </p>
<blockquote>
<p>如果原链表的random指针为<code>a.ramdom == c</code>, 那么根据我们的映射, 就能得到<code>a.next.random == c.next</code>!</p>
</blockquote>
<p>然后再将两条链表分离出来即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//copy old linkedList from a-&gt;b to a-&gt;a&#x27;-&gt;b-&gt;b&#x27;</span></span><br><span class="line">        <span class="keyword">for</span>(Node i = head; i != <span class="keyword">null</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            Node tmp = i.next;</span><br><span class="line">            Node i_ = <span class="keyword">new</span> Node(i.val);</span><br><span class="line">            i.next = i_;</span><br><span class="line">            i_.next = tmp;</span><br><span class="line">            i = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//copy random pointer</span></span><br><span class="line">        <span class="keyword">for</span>(Node i = head; i != <span class="keyword">null</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            Node iRandom = i.random;</span><br><span class="line">            i.next.random = (iRandom == <span class="keyword">null</span>) ? <span class="keyword">null</span> : iRandom.next;</span><br><span class="line">            i = i.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//split two linkedLists</span></span><br><span class="line">        Node newHead = head.next;</span><br><span class="line">        Node j = newHead;</span><br><span class="line">        <span class="keyword">for</span>(Node i = head; i != <span class="keyword">null</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            i.next = i.next.next;</span><br><span class="line">            j.next = j.next == <span class="keyword">null</span> ? <span class="keyword">null</span> : j.next.next;</span><br><span class="line">            i = i.next;</span><br><span class="line">            j = j.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 137 Single Number II</title>
    <url>/2020/10/04/Leetcode/Leetcode%20137%20Single%20Number%20II/</url>
    <content><![CDATA[<p>Given a <strong>non-empty</strong> array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1 哈希表"></a>1 哈希表</h2><p>想不到空间复杂度O(1)的算法了…..</p>
<p>只能hashmap了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            map.putIfAbsent(i,<span class="number">0</span>);</span><br><span class="line">            map.put(i,map.get(i) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue() == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> entry.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2 位运算"></a>2 位运算</h2><p>思路来源于<a href="https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetcode/">https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetcode/</a></p>
<p>所以假如数组是这样的[1,1,1,2,2,2,3,3,3,4], 自然是可以求出只出现一次的元素.</p>
<p>但是, 如果数组是这样的[1,2,3,4,1,2,3,1,2,3], 第一次将1传进去, seen_once置为1, seen_twice置为0, 当下一次将2传入, 会不会打乱保存了1只出现了一次的信息的变量seen_one? 所以我们要证明, 这个算法与元素顺序无关. 如果无关的话, 就可以视为对数组[1,1,1,2,2,2,3,3,3,4]进行计算, 显然会得到正确的答案4.</p>
<p>我们假设seen_once的初始值第i位为0, seen_twice的初始值第i位为0. 第一个元素第i位为a, 第二个元素第i位为b. (a, b = 0 or 1)</p>
<p>那么先计算a, 再计算b的结果为:</p>
<blockquote>
<p><code>seen_once = a</code></p>
<p><code>seen_two = (~a)&amp;(0^a) = 0</code>  </p>
<p><code>seen_once =a^b</code></p>
<p><code>seen_two = ~(a^b)&amp;b</code> </p>
</blockquote>
<p>先计算b, 后计算a的结果为<code>(a^b)</code>和<code>~(a^b)&amp;a</code>两者无论a, b取任何值(0或1)都是相等的.</p>
<p>同理, 可以计算出</p>
<ul>
<li>seen_once的初始值第i位为0, seen_twice的初始值第i位为1,第一个元素第i位为a, 第二个元素第i位为b</li>
<li>seen_once的初始值第i位为1, seen_twice的初始值第i位为0,第一个元素第i位为a, 第二个元素第i位为b</li>
<li>seen_once的初始值第i位为1, seen_twice的初始值第i位为1,第一个元素第i位为a, 第二个元素第i位为b</li>
</ul>
<p>这三种情况下, 先计算第一个元素和先计算第二个元素都是相等的. 因为i的任意性, 所以整个的值seen_one, seen_two也和计算顺序无关.</p>
<p>这就保证了[1,2,3,4,1,2,3,1,2,3]这样的数组可以通过交换, 变成[1,1,1,2,2,2,3,3,3,4]. 后者的正确性显然.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            one = (~two) &amp; (one ^ i);</span><br><span class="line">            two = (~one) &amp; (two ^ i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 139 Word Break</title>
    <url>/2020/10/24/Leetcode/Leetcode%20139%20Word%20Break/</url>
    <content><![CDATA[<p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
<li>You may assume the dictionary does not contain duplicate words.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">             Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-DFS-超时"><a href="#1-DFS-超时" class="headerlink" title="1 DFS(超时)"></a>1 DFS(超时)</h2><p>s可以由wordDict组成的条件为, <strong>对于<code>String i in wordDict</code>, 至少有一个字符串i使得s满足s由i开头, 并且s的剩余部分也能由wordDict组成</strong></p>
<p>递归边界为s为””.</p>
<p>不出所料, 超时了</p>
<p>超时用例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab&quot;</span><br><span class="line">[&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;,&quot;aaaaa&quot;,&quot;aaaaaa&quot;,&quot;aaaaaaa&quot;,&quot;aaaaaaaa&quot;,&quot;aaaaaaaaa&quot;,&quot;aaaaaaaaaa&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>反思</strong>: 上面的超时是因为进行了大量的无用计算.</p>
<blockquote>
<p>例如, 计算”aaaab”, dict = [a, aa]</p>
<p>首先选择dict其中的一个string “a”, 接下来计算”aaab”是否可以由dict组成. </p>
<p>然后计算”aaab”是否可以由dict组成的时候, 又要计算”aab”是否可以由dict组成. 以此类推最后得到<strong>如果一开始选择”a”, 不能由dict拼成这个字符串.</strong></p>
<p>但是, 我们回到起点, 接下来选择dict另外一个string “aa”作为开始, 接下来就又要判断”aab”是否可以由dict组成. </p>
<p>这和前面两个”a”的情况一模一样, 所以就浪费了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(String i : wordDict)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.startsWith(i) &amp;&amp; wordBreak(s.substring(i.length()), wordDict))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2 动态规划"></a>2 动态规划</h2><p>也是用dfs那个思路, 就是如果从0到i的子串可以由dict组成, 并且从i+1到j的子串在dict里面, 那么从0到j的子串也可以由dict组成.</p>
<p>边界是空串””是可以被dict组成.</p>
<p>dp[i] 表示从<strong>0到i-1</strong>的子串能否被dict组成. </p>
<p>dp[0]表示空串. <code>dp[0] = true</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(String word : wordDict)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> j = word.length();</span><br><span class="line">                    <span class="keyword">if</span>(i + j &lt;= n &amp;&amp; s.substring(i, i + j).equals(word))</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i + j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 14 Longest Common Prefix</title>
    <url>/2020/09/01/Leetcode/Leetcode%2014%20Longest%20Common%20Prefix/</url>
    <content><![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>All given inputs are in lowercase letters <code>a-z</code>.</p>
<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1 暴力"></a>1 暴力</h2><p>对strs的每个元素, 按位比较(这里的按位比较不是指位运算的那个位, 而是先比较第0个字符, 再比较第1个字符,..), 找到最长的前缀</p>
<p>复杂度mn, m是prefix的长度, n是strs的size</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.empty()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.front().<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> chr = strs.front()[i];</span><br><span class="line">            <span class="keyword">bool</span> isPrefix = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span> str : strs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= str.<span class="built_in">size</span>() || str[i] != chr)</span><br><span class="line">                &#123;</span><br><span class="line">                    isPrefix = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isPrefix)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.push_back(chr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-利用set排序"><a href="#2-利用set排序" class="headerlink" title="2 利用set排序"></a>2 利用set排序</h2><p>这个答案是引用 <a href="https://leetcode.com/problems/longest-common-prefix/discuss/821706/4-ms-C%2B%2B-Solution-using-SET">leetcode.com,Author:[harsh_310]</a> 的, 思路是把所有的str放入一个 tree-set中.</p>
<p>那么有字典序 set[0] &lt; set[1] &lt; set[2] &lt; … &lt; set[size - 1].</p>
<p>所以, 如果有 set[0] 和 set[size - 1] 有相同的某个最长前缀prefix, 那么根据字典序的关系, 所有的set元素的最长前缀也是prefix. 从而求出结果. </p>
<p>时间复杂度 nlogn, 空间复杂度n</p>
<p>这个方法和暴力算法没有优劣之分, 因为不能确定logn 和 m的大小, 同时空间复杂度也比暴力高</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = strs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : strs)</span><br><span class="line">        s.insert(i);</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> *s.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s1 = *s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">string</span> s2 = *(s.rbegin());</span><br><span class="line">        <span class="built_in">string</span> temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> string_size = <span class="built_in">min</span>(s1.<span class="built_in">size</span>(),s2.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string_size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s2[i])</span><br><span class="line">            <span class="keyword">return</span> s1.substr(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.substr(<span class="number">0</span>, string_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 141 Linked List Cycle</title>
    <url>/2020/08/16/Leetcode/Leetcode%20141%20Linked%20List%20Cycle/</url>
    <content><![CDATA[<p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<a id="more"></a>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>两个指针slow和fast, slow一次前进一步, fast前进2步, 判断在碰到nullptr前两个指针是否相等即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">bool</span> hasCycle = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span> || fast-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                hasCycle = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasCycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 142 Linked List Cycle II</title>
    <url>/2020/08/16/Leetcode/Leetcode%20142%20Linked%20List%20Cycle%20II/</url>
    <content><![CDATA[<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Note:</strong> Do not modify the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">Output: no cycle</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p><strong>Follow-up</strong>:<br>Can you solve it without using extra space?</p>
<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1 暴力"></a>1 暴力</h2><p>建立一个ListNode* 到 int 的映射, 存储每个节点的访问次数.</p>
<p>依次访问链表, 每一次访问就增加1次访问次数, 返回第一个使访问次数为2的节点.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;ListNode*, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            ++mp[head];</span><br><span class="line">            <span class="keyword">if</span>(mp[head] == <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="2 快慢指针"></a>2 快慢指针</h2><p>首先仍然是构造快慢指针fast, slow, 快指针一次走2步, 慢指针一次走1步. 直到他们相遇.</p>
<p>关键点来了</p>
<p><strong>两个指针在某个节点相遇后, 将慢指针移至头节点, 快指针不变, 然后快慢指针一次都走1步, 再次相遇的点即为环开始的点!!</strong></p>
<p>证明如下:</p>
<p>记链表中的环的长度为b, 其余长度为a, 两个指针第一次相遇是在慢指针进入环内x步后相遇的.</p>
<p>那么慢指针从开始到相遇一共走了 <code>s = a + x</code>步, 快指针自然是走了<code>f = 2a + 2x</code>步. 同时, 快指针走的所有路程为开始的a个节点, 在环中转了<code>n</code>次圈, 在加上最后的<code>x</code>个节点. 所以<code>f = a + x +nb</code></p>
<p>上面三个式子结合, 能推导出<code>a + x = nb</code></p>
<p>下面快指针变为走1步了, 慢指针从头节点开始, 若想要使得慢指针停留在环的第一个位置, 则慢指针必须走k步,k满足 <code>k = a + mb</code>, 其中m是正整数. 当快指针走k步的时候, 总步数<code>f=2a + 2x + a +mb</code>, 由上面的推导, a+x是b的倍数, 所以f = a (mod b), 即慢指针走a + mb步后快指针也会在环的第一个位置. </p>
<p>取m = 0, 即变为寻找快慢指针第一个相遇的位置. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;next)</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(fast != slow);</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 143 Reorder List</title>
    <url>/2020/10/22/Leetcode/Leetcode%20143%20Reorder%20List/</url>
    <content><![CDATA[<p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,<br>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p><strong>思路比较简单</strong></p>
<p>首先说思路, 对于一个链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7</p>
<p>先把他从中间分成两部分, 1-&gt;2-&gt;3-&gt;4 和 5-&gt;6-&gt;7</p>
<p>然后翻转后面的链表5-&gt;6-&gt;7 ==&gt; 7-&gt;6-&gt;5</p>
<p>然后对于1-&gt;2-&gt;3-&gt;4 和 7-&gt;6-&gt;5这两个链表, 合并起来, 变为1-&gt;7-&gt;2-&gt;6-&gt;3-&gt;5-&gt;4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//reverse the node after slow</span></span><br><span class="line">        reverse(slow);</span><br><span class="line">        ListNode list2 = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode list1 = head;</span><br><span class="line">        ListNode i = list1;</span><br><span class="line">        ListNode j = list2;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//insert j to i_behind</span></span><br><span class="line">            ListNode tmpj = j;</span><br><span class="line">            j = j.next;</span><br><span class="line">            tmpj.next = <span class="keyword">null</span>;</span><br><span class="line">            ListNode tmpi = i.next;</span><br><span class="line">            i.next = tmpj;</span><br><span class="line">            tmpj.next = tmpi;</span><br><span class="line">            i = tmpi;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ListNode p1 = head.next;</span><br><span class="line">        ListNode p2 = head.next.next;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next.next = <span class="keyword">null</span>;</span><br><span class="line">        head.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 144 Binary Tree Preorder Traversal</title>
    <url>/2020/10/01/Leetcode/Leetcode%20144%20Binary%20Tree%20Preorder%20Traversal/</url>
    <content><![CDATA[<p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>Follow up:</strong></p>
<p>Recursive solution is trivial, could you do it iteratively?</p>
<a id="more"></a>
<h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><p>参考于 <a href="https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html">https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; preorder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> || !stk.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                preorder.add(p.val);</span><br><span class="line">                stk.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = stk.pop();</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 145 Binary Tree Postorder Traversal</title>
    <url>/2020/10/02/Leetcode/Leetcode%20145%20Binary%20Tree%20Postorder%20Traversal/</url>
    <content><![CDATA[<p>Given the <code>root</code> of a binary tree, return <em>the postorder traversal of its nodes’ values</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2,3]</span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre3.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/pre2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>Follow up:</strong></p>
<p>Recursive solution is trivial, could you do it iteratively?</p>
<a id="more"></a>
<h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><p>参考于<a href="https://www.cnblogs.com/mini-coconut/p/9079464.html">https://www.cnblogs.com/mini-coconut/p/9079464.html</a></p>
<p>要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p>
<p>这个思路很好，目的也是要保证遍历过程的正确性，多使用了一个指针pre来存储前一次访问的节点，这样就可以判断此节点的右子树有没有被访问过。判断条件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(pre!&#x3D;NULL &amp;&amp;(pre&#x3D;&#x3D;cur-&gt;left||pre&#x3D;&#x3D;cur-&gt;right))</span><br></pre></td></tr></table></figure>

<p>很难理解，一开始会想，这里的pre==cur-&gt;left是错误的，因为如果我前一个访问的是该节点的左孩子，那就可以直接访问该节点吗，怎么可能呢。仔细想，就是这样的。因为这种情况只可能出现在，该节点没有右孩子，所以上一个访问完左孩子，直接就可以访问该节点。如果有右孩子在，上一个访问的节点不可能是左孩子，因为右孩子是在此节点之后打入栈中的，会更早的出现在栈顶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        stk.push(curr);</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            curr = stk.peek();</span><br><span class="line">            <span class="keyword">if</span>((curr.left == <span class="keyword">null</span> &amp;&amp; curr.right == <span class="keyword">null</span>) || (prev != <span class="keyword">null</span> &amp;&amp; (prev == curr.left || prev == curr.right)))</span><br><span class="line">            &#123;</span><br><span class="line">                ans.add(curr.val);</span><br><span class="line">                stk.pop();</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>)</span><br><span class="line">                    stk.push(curr.right);</span><br><span class="line">                <span class="keyword">if</span>(curr.left != <span class="keyword">null</span>)</span><br><span class="line">                    stk.push(curr.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 147 Insertion Sort List</title>
    <url>/2020/10/21/Leetcode/Leetcode%20147%20Insertion%20Sort%20List/</url>
    <content><![CDATA[<p>Sort a linked list using insertion sort.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="img"><br>A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.<br>With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list</p>
<p><strong>Algorithm of Insertion Sort:</strong></p>
<ol>
<li>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</li>
<li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.</li>
<li>It repeats until no input elements remain.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>首先列表在中间断开, 排序的是一个链表sortedListHead, 未排序的是另外的链表remainderListHead</p>
<p>当然, 最初的时候sortedListHead只有1个元素</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1-&gt;5-&gt;3-&gt;4-&gt;0  &#x3D;&gt;    -1    5-&gt;3-&gt;4-&gt;0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后只要remainderListHead非空, 就在里面取出首元素curr来, </p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1    5-&gt;3-&gt;4-&gt;0  &#x3D;&#x3D;&gt; -1   5   3-&gt;4-&gt;0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后将curr归置到sortedListHead相应的位置.</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1   5   3-&gt;4-&gt;0   &#x3D;&#x3D;&gt; -1-&gt;5  3-&gt;4-&gt;0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以此类推,</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1-&gt;5  3-&gt;4-&gt;0  &#x3D;&#x3D;&gt; -1-&gt;5  3  4-&gt;0</span><br><span class="line">-1-&gt;5  3  4-&gt;0  &#x3D;&#x3D;&gt; -1-&gt;3-&gt;5  4-&gt;0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>知道remainderListHead为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode sortedListHead = head;</span><br><span class="line">        ListNode remainderListHead = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(remainderListHead != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode curr = remainderListHead;</span><br><span class="line">            remainderListHead = remainderListHead.next;</span><br><span class="line">            curr.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//now insert Node curr into sortedListHead.</span></span><br><span class="line">            <span class="keyword">if</span>(curr.val &lt; sortedListHead.val)</span><br><span class="line">            &#123;</span><br><span class="line">                curr.next = sortedListHead;</span><br><span class="line">                sortedListHead = curr;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode prev = sortedListHead;</span><br><span class="line">                ListNode next_ = sortedListHead.next;</span><br><span class="line">                <span class="keyword">while</span>(next_ != <span class="keyword">null</span> &amp;&amp; next_.val &lt; curr.val)</span><br><span class="line">                &#123;</span><br><span class="line">                    next_ = next_.next;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// now we have prev &lt; curr &lt; next_ or prev &lt; curr &lt; null</span></span><br><span class="line">                prev.next = curr;</span><br><span class="line">                curr.next = next_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedListHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 15 Three Sum</title>
    <url>/2020/07/31/Leetcode/Leetcode%2015%20Three%20Sum/</url>
    <content><![CDATA[<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate triplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-hashmap"><a href="#1-hashmap" class="headerlink" title="1 hashmap"></a>1 hashmap</h2><p>仿照two sum的做法, 构造一个map储存各个元素和各个元素出现的次数.</p>
<p>先对nums排序.</p>
<p>对于任意的i, j, i &gt; j,这时有nums[i] &lt;= nums[j]. 只需要在hashmap中寻找有没有值为-nums[i] - nums[j]的元素即可. </p>
<p>关键在于如何去重. 下面记a=nums[i], b=nums[j] 因为nums是排好序的, 所以有a &lt;= b</p>
<blockquote>
<p>若map中有值为-nums[i] - nums[j]的元素c时, 若c  &lt; b, 即c对应的数组下标一定在b对应的下标前面. 所以当a不变时, j在之前的遍历中b一定取值过现在的c, 所以现在一定会重复. 即(a, b, c) = (a, b_1, c_1) 其中b_1 = c, c_1 = b  例如[-4 -1 -1 0 0 1 1 2]中, (-1, 1, 0)和(-1, 0, 1)是重的. 所以一定要保证a&lt;=b&lt;=c的顺序.</p>
</blockquote>
<blockquote>
<p>若c &gt; b 则没有重复的风险. </p>
</blockquote>
<blockquote>
<p> 若 c == b, 则要考虑c在map中出现的次数. 例如[-4 -1 -1 0 0 1 1 2]中, a = -4, b = 2, 想要找到c = 2,但是2只在nums出现一次. 所以不成立</p>
</blockquote>
<blockquote>
<p>还要考虑 a == b == c == 0的情况. 如果0出现的次数小于3次, 不成立.</p>
</blockquote>
<blockquote>
<p>同时也要避免递增i时出现的重复. [-4 <strong>-1</strong> -1 <strong>0</strong> 0 <strong>1</strong> 1 2] 和 [-4 -1 <strong>-1</strong> <strong>0</strong> 0 <strong>1</strong> 1 2] 是重的, 所以当<code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]</code>时要continue</p>
</blockquote>
<blockquote>
<p>递增j时也可能出现重复. [-4 <strong>-1</strong> -1 <strong>0</strong> 0 <strong>1</strong> 1 2] 和 [-4 <strong>-1</strong> -1 0 <strong>0</strong> <strong>1</strong> 1 2]是重的. 所以当<code>j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]</code>时要continue</p>
</blockquote>
<p>这个方法时间为n^2, 空间为n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvc;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> vvc;</span><br><span class="line"></span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++mp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> a = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> b = nums[j];</span><br><span class="line">                <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator cIt = mp.<span class="built_in">find</span>(-a - b);</span><br><span class="line">                <span class="keyword">if</span>(cIt == mp.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> c = cIt-&gt;first;</span><br><span class="line">                <span class="keyword">int</span> c_count = cIt-&gt;second;</span><br><span class="line">                <span class="keyword">if</span>(c == b &amp;&amp; c == a &amp;&amp; c_count &lt; <span class="number">3</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(c == b &amp;&amp; c_count &lt; <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(c &gt;= b)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = &#123;a,b,c&#125;;</span><br><span class="line">                    vvc.push_back(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-扫描-双指针"><a href="#2-扫描-双指针" class="headerlink" title="2 扫描 + 双指针"></a>2 扫描 + 双指针</h2><p>固定 3 个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums))(k,len(nums)) 两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合：<br>当 nums[k] &gt; 0 时直接break跳出：因为 nums[j] &gt;= nums[i] &gt;= nums[k] &gt; 0，即 3 个数字都大于 0 ，在此固定指针 k 之后不可能再找到结果了。<br>当 k &gt; 0且nums[k] == nums[k - 1]时即跳过此元素nums[k]：因为已经将 nums[k - 1] 的所有组合加入到结果中，本次双指针搜索只会得到重复组合。<br>i，j 分设在数组索引 (k, len(nums))(k,len(nums)) 两端，当i &lt; j时循环计算s = nums[k] + nums[i] + nums[j]，并按照以下规则执行双指针移动：<br>当s &lt; 0时，i += 1并跳过所有重复的nums[i]；<br>当s &gt; 0时，j -= 1并跳过所有重复的nums[j]；<br>当s == 0时，记录组合[k, i, j]至res，执行i += 1和j -= 1并跳过所有重复的nums[i]和nums[j]，防止记录到重复组合。</p>
<p>思路解析参考于<a href="https://leetcode-cn.com/problems/3sum/solution/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/">https://leetcode-cn.com/problems/3sum/solution/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvc;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> vvc;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> a = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(k &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[k] == nums[k+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    --k;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> b = nums[j];</span><br><span class="line">                <span class="keyword">int</span> c = nums[k];</span><br><span class="line">                <span class="keyword">int</span> sum = a + b + c;</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = &#123;a,b,c&#125;;</span><br><span class="line">                    vvc.push_back(tmp);</span><br><span class="line">                    ++j;</span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 148 Sort List</title>
    <url>/2020/10/22/Leetcode/Leetcode%20148%20Sort%20List/</url>
    <content><![CDATA[<p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p>
<p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [4,2,1,3]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [-1,5,3,4,0]</span><br><span class="line">Output: [-1,0,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is in the range <code>[0, 5 * 104]</code>.</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
</ul>
<a id="more"></a>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><p>递归方法很简单, 但是<strong>不满足空间复杂度O(1)的要求.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode list2 = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode list1 = head;</span><br><span class="line">        ListNode sortedList1 = sortList(list1);</span><br><span class="line">        ListNode sortedList2 = sortList(list2);</span><br><span class="line">        ListNode sortedWholeHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode tail = sortedWholeHead;</span><br><span class="line">        ListNode i = sortedList1;</span><br><span class="line">        ListNode j = sortedList2;</span><br><span class="line">        <span class="comment">//merge</span></span><br><span class="line">        <span class="keyword">while</span>(i != <span class="keyword">null</span> || j != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode tmp = j;</span><br><span class="line">                j = j.next;</span><br><span class="line">                tmp.next = <span class="keyword">null</span>;</span><br><span class="line">                tail.next = tmp;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode tmp = i;</span><br><span class="line">                i = i.next;</span><br><span class="line">                tmp.next = <span class="keyword">null</span>;</span><br><span class="line">                tail.next = tmp;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i.val &gt; j.val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode tmp = j;</span><br><span class="line">                j = j.next;</span><br><span class="line">                tmp.next = <span class="keyword">null</span>;</span><br><span class="line">                tail.next = tmp;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode tmp = i;</span><br><span class="line">                i = i.next;</span><br><span class="line">                tmp.next = <span class="keyword">null</span>;</span><br><span class="line">                tail.next = tmp;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedWholeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2 迭代"></a>2 迭代</h2><p>参考自<a href="https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-jiu-yin-wei-zhe-ge-ti-bei-wu-/">https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-jiu-yin-wei-zhe-ge-ti-bei-wu-/</a></p>
<p>这种方法从低到上的进行归并. 就避免了递归</p>
<p>使用cut操作依次把链表分割成长度为size的单元(size从1开始，指数级递增)<br>使用迭代的方式依次合并分割开的小单元，直到size&gt;=length时，停止循环，返回结果。size表示的即为链表中长度为size的小单元已经是有序的</p>
<p>主要就是cut和merge两个关键操作 </p>
<p><code>cut(curr, n)</code>表示将curr的前n个节点切断, 返回第n+1个节点的指针. 而curr对应的链表就是第1个到第n个的节点.</p>
<p><code>merge(list1, list2)</code>表示归并两个有序链表, 返回归并后的链表的第一个节点</p>
<p>下面举例说明</p>
<blockquote>
<p>链表[5 -1 3 4 0]</p>
<ol start="0">
<li><p>首先初始化size = 1, 当前链表curr 为head</p>
</li>
<li><p>我们从当前链表curr中分离出两个长度为size的链表 5 和 -1, 然后归并他们, 变为 -1 -&gt; 5. 将其存储在新的链表中. dummyHead -&gt; -1 -&gt; 5</p>
</li>
<li><p>剩余的链表为3-&gt;4-&gt;0, 再次分离两个链表, 3, 4. 归并他们 3-&gt;4, 然后加到dummyHead最后 dummyHead -&gt; -1 -&gt; 5-&gt;3-&gt;4</p>
</li>
<li><p>剩余的链表为0, 再次分离两个链表, 0 和 null, 归并他们, 加到dummyHead最后 dummyHead -&gt; -1 -&gt; 5-&gt;3-&gt;4-&gt;0</p>
</li>
<li><p>当再次取两个长度为size的链表的时候, 发现都为空. 跳出这次循环, 更新size = size*2; curr = dummyHead-&gt;next.</p>
</li>
<li><p>再次回到步骤 1, 直到size &gt; length</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode i = head; i != <span class="keyword">null</span>; i = i.next)</span><br><span class="line">        &#123;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="keyword">while</span>(size &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode curr = dummyHead.next;</span><br><span class="line">            dummyHead.next = <span class="keyword">null</span>;</span><br><span class="line">            ListNode tail = dummyHead;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode l1 = curr;</span><br><span class="line">                curr = cut(curr, size);</span><br><span class="line">                ListNode l2 = curr;</span><br><span class="line">                curr = cut(curr, size);</span><br><span class="line">                <span class="keyword">if</span>(l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ListNode lMerge = merge(l1, l2);</span><br><span class="line">                tail.next = lMerge;</span><br><span class="line">                <span class="keyword">while</span>(tail.next != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tail = tail.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            size *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">cut</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode i = head;</span><br><span class="line">        <span class="keyword">while</span>(n - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; i != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i = i.next;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        ListNode res = i.next;</span><br><span class="line">        i.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode list1, ListNode list2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode sortedWholeHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode tail = sortedWholeHead;</span><br><span class="line">        ListNode i = list1;</span><br><span class="line">        ListNode j = list2;</span><br><span class="line">        <span class="comment">//merge</span></span><br><span class="line">        <span class="keyword">while</span>(i != <span class="keyword">null</span> || j != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode tmp = j;</span><br><span class="line">                j = j.next;</span><br><span class="line">                tmp.next = <span class="keyword">null</span>;</span><br><span class="line">                tail.next = tmp;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode tmp = i;</span><br><span class="line">                i = i.next;</span><br><span class="line">                tmp.next = <span class="keyword">null</span>;</span><br><span class="line">                tail.next = tmp;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i.val &gt; j.val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode tmp = j;</span><br><span class="line">                j = j.next;</span><br><span class="line">                tmp.next = <span class="keyword">null</span>;</span><br><span class="line">                tail.next = tmp;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode tmp = i;</span><br><span class="line">                i = i.next;</span><br><span class="line">                tmp.next = <span class="keyword">null</span>;</span><br><span class="line">                tail.next = tmp;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedWholeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 151 Reverse Words In A String</title>
    <url>/2020/10/25/Leetcode/Leetcode%20151%20Reverse%20Words%20In%20A%20String/</url>
    <content><![CDATA[<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>
<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>
<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>
<p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;the sky is blue&quot;</span><br><span class="line">Output: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;  hello world  &quot;</span><br><span class="line">Output: &quot;world hello&quot;</span><br><span class="line">Explanation: Your reversed string should not contain leading or trailing spaces.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a good   example&quot;</span><br><span class="line">Output: &quot;example good a&quot;</span><br><span class="line">Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;  Bob    Loves  Alice   &quot;</span><br><span class="line">Output: &quot;Alice Loves Bob&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;Alice does not even like bob&quot;</span><br><span class="line">Output: &quot;bob like even not does Alice&quot;</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>&#39; &#39;</code>.</li>
<li>There is <strong>at least one</strong> word in <code>s</code>.</li>
</ul>
<p><strong>Follow up:</strong></p>
<ul>
<li><p>Could you solve it <strong>in-place</strong> with <code>O(1)</code> extra space?</p>
<h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1 双指针"></a>1 双指针</h2></li>
</ul>
<p>用双指针从后向前遍历每一个单词, 逐个加到一个空串中. 原地修改的哪种方法实在想不出来了. 还是菜🥗🥗🥗</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span> &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                --i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( i &gt; <span class="number">-1</span> &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                    --i;</span><br><span class="line">                ans.insert(ans.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>() + i + <span class="number">1</span>, s.<span class="built_in">begin</span>() + j + <span class="number">1</span>);</span><br><span class="line">                ans.push_back(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="2-两次翻转"><a href="#2-两次翻转" class="headerlink" title="2 两次翻转"></a>2 两次翻转</h2><p>先把字符串所有字符都反转, 然后再对于每一个单词翻转. 最后去除多余的空格.</p>
<p>这么简单的思路竟然没想到, 太不应该了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        wholeReverse(s);</span><br><span class="line">        partialReverse(s);</span><br><span class="line">        trimSpace(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wholeReverse</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(s[i], s[j]);</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partialReverse</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> <span class="built_in">begin</span> = i;</span><br><span class="line">                <span class="keyword">int</span> <span class="built_in">end</span> = j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::swap(s[<span class="built_in">begin</span>], s[<span class="built_in">end</span>]);</span><br><span class="line">                    ++<span class="built_in">begin</span>;</span><br><span class="line">                    --<span class="built_in">end</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trimSpace</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[i++] = s[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[j] == <span class="string">&#x27; &#x27;</span> &amp;&amp; s[j<span class="number">-1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    s[i++] = s[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.erase(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// erase the last space if exists</span></span><br><span class="line">        <span class="comment">// because &quot;a   &quot; becomes &quot;a &quot; after above process</span></span><br><span class="line">        <span class="keyword">if</span>(s.back() == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 150 Evaluate Reverse Polish Notation</title>
    <url>/2020/10/24/Leetcode/Leetcode%20150%20Evaluate%20Reverse%20Polish%20Notation/</url>
    <content><![CDATA[<p>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</p>
<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Division between two integers should truncate toward zero.</li>
<li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: </span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>感觉是很基础的题了, 难度设为medium有点不合适. 学数据结构的时候肯定学过这个题!!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stk = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String token : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isSymbol(token))</span><br><span class="line">            &#123;</span><br><span class="line">                stk.offerFirst(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> b = stk.pollFirst();</span><br><span class="line">                <span class="keyword">int</span> a = stk.pollFirst();</span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(token))</span><br><span class="line">                    res = a + b;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;-&quot;</span>.equals(token))</span><br><span class="line">                    res = a - b;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(token))</span><br><span class="line">                    res = a * b;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res = a / b;</span><br><span class="line">                stk.offerFirst(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(String i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;+&quot;</span>.equals(i) || <span class="string">&quot;-&quot;</span>.equals(i) || <span class="string">&quot;*&quot;</span>.equals(i) || <span class="string">&quot;/&quot;</span>.equals(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 153 Find Minimum In Rotated Sorted Array</title>
    <url>/2020/07/20/Leetcode/Leetcode%20153%20Find%20Minimum%20In%20Rotated%20Sorted%20Array/</url>
    <content><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,4,5,1,2] </span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,5,6,7,0,1,2]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>如果数组的第一个元素小于最后一个元素，那么这个数组是未被rotated的，第一个值肯定是最小值</p>
<p>如果将这个数组从中间分开,左边和右边两个子数组肯定有一个是未被rotated的，能直接计算出最小值，另外一个rotated的数组可以再递归的分为两个数组来计算最小值，最后，取（左数组最小值，中间值，右数组最小值）的最小值作为数组最小值。</p>
<p>复杂度有<code>T(n) = T(n/2) + O(1)</code>, 即O(log n)的复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findMin(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> &gt; <span class="built_in">end</span>) <span class="keyword">return</span> INT_MAX; <span class="comment">//recursion boundary</span></span><br><span class="line">        <span class="comment">//check if sorted with no rotation</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="built_in">begin</span>] &lt; nums[<span class="built_in">end</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="built_in">begin</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMin = findMin(nums, <span class="built_in">begin</span>, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> midMin = nums[mid];</span><br><span class="line">        <span class="keyword">int</span> rightMin = findMin(nums,mid + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(midMin, <span class="built_in">min</span>(leftMin, rightMin));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 155 Min Stack</title>
    <url>/2020/10/07/Leetcode/Leetcode%20155%20Min%20Stack/</url>
    <content><![CDATA[<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin(); &#x2F;&#x2F; return -3</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();    &#x2F;&#x2F; return 0</span><br><span class="line">minStack.getMin(); &#x2F;&#x2F; return -2</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li>
</ul>
<a id="more"></a>
<h2 id="1-辅助栈"><a href="#1-辅助栈" class="headerlink" title="1 辅助栈"></a>1 辅助栈</h2><p>这题一开始想了很长时间, 思路被限制在哈希表和优先队列上面了. 实际上用两个栈就ok了</p>
<p>第一个栈就存储各个元素x1, x2, x3,…,xn, 第二个栈就存储M1, M2, M3,…., Mn. 其中Mi为x1到xi的最小值.</p>
<p>然后就很容易进行操作了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; stk;</span><br><span class="line">    Deque&lt;Integer&gt; stkAux;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stkAux = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stkAux.offerFirst(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stk.offerFirst(x);</span><br><span class="line">        stkAux.offerFirst(Math.min(x,stkAux.peekFirst()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.pollFirst();</span><br><span class="line">        stkAux.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stkAux.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2-O-1-空间复杂度"><a href="#2-O-1-空间复杂度" class="headerlink" title="2 O(1)空间复杂度"></a>2 O(1)空间复杂度</h2><p>这次要改变一下思路, stack不储存各个元素了, 而是存储各个元素与min的差值.</p>
<p>参考自<a href="https://zhuanlan.zhihu.com/p/49854919">https://zhuanlan.zhihu.com/p/49854919</a>, 具体如下: </p>
<ol>
<li>第一次push的时候，把该元素作为最小元素min。</li>
<li>在后面的push操作中，首先判断当前元素<code>num</code>是否小于<code>min</code>,如果不小于<code>min</code>，就向栈中存入元素值<code>data = num-min</code>(这个值肯定大于0，因为num大于min)；如果num小于min，也向栈中存入<code>data = num-min</code>(<code>data</code>小于0)，同时记得更新<code>min</code>值。</li>
<li>pop的时候，首先判断栈顶的元素data是否大于0，如果大于0，则pop的值应该是<code>num=data +min</code>（因为存的时候是<code>data = num-min</code>);如果小于0，则pop的时候应该是<code>min</code>，同时要更新min，<code>min = min- data</code>。</li>
<li>同时get_min时直接返回min的值就是整个栈元素中的最小值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Long&gt; stk;</span><br><span class="line">    <span class="keyword">long</span> min;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            min = x;</span><br><span class="line">            stk.offerFirst((<span class="keyword">long</span>) <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            stk.offerFirst(x - min);</span><br><span class="line">            <span class="keyword">if</span>(x &lt; min)</span><br><span class="line">                min = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.peekFirst() &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min = min - stk.peekFirst();</span><br><span class="line">            stk.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            stk.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (stk.peekFirst() &lt; <span class="number">0</span>) ? (<span class="keyword">int</span>) min : (<span class="keyword">int</span>) (stk.peekFirst() +  min);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 160 Intersection Of Two Linked Lists</title>
    <url>/2020/10/05/Leetcode/Leetcode%20160%20Intersection%20Of%20Two%20Linked%20Lists/</url>
    <content><![CDATA[<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt="img"></a></p>
<p>begin to intersect at node c1.</p>
<p><strong>Example 1:</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2020/06/29/160_example_1_1.png"><img src="https://assets.leetcode.com/uploads/2020/06/29/160_example_1_1.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">Output: Reference of the node with value &#x3D; 8</span><br><span class="line">Input Explanation: The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2020/06/29/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2020/06/29/160_example_2.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">Output: Reference of the node with value &#x3D; 2</span><br><span class="line">Input Explanation: The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</span><br></pre></td></tr></table></figure>



<p><strong>Example 3:</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">Output: null</span><br><span class="line">Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.</span><br><span class="line">Explanation: The two lists do not intersect, so return null.</span><br></pre></td></tr></table></figure>



<p><strong>Notes:</strong></p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Each value on each linked list is in the range <code>[1, 10^9]</code>.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
<a id="more"></a>
<h2 id="1-求链表长度"><a href="#1-求链表长度" class="headerlink" title="1 求链表长度"></a>1 求链表长度</h2><p>先求出两个链表的长度, len1和len2, 这里假设len1大. diff = abs(len1 - len2).</p>
<p>然后指向list1的指针先走diff步, 然后指向list1的指针和list2的指针再一起走. 当某一步两个指针指向的元素相同时, 就返回. 当某个指针指向了null, 就返回null.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">        ListNode tmp1 = headA;</span><br><span class="line">        ListNode tmp2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(tmp1 != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++len1;</span><br><span class="line">            tmp1 = tmp1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tmp2 != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++len2;</span><br><span class="line">            tmp2 = tmp2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isListALonger = (len1 &gt;= len2);</span><br><span class="line">        <span class="keyword">int</span> diff = Math.abs(len1 - len2);</span><br><span class="line">        ListNode p1 = headA;</span><br><span class="line">        ListNode p2 = headB;</span><br><span class="line">        <span class="keyword">if</span>(isListALonger)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(diff != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">                --diff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(diff != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">                --diff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 == <span class="keyword">null</span> || p2 == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">                <span class="keyword">return</span> p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2 双指针"></a>2 双指针</h2><p>这是一种更巧妙的方法. </p>
<p>指针a和指针b同时走, 指针a走到null时就指向链表b的开头, 指针b走到null时就指向链表a的开头. 最后, 如果他们在某一点相遇(之前都没相遇), 这个点肯定是链表相交的点!</p>
<p>一开始可能难以理解, 但是我们假设, 链表a和链表b的不相交部分的长度为a和b, 公共部分长度为c. 并且假设链表a长</p>
<p>当两个指针开始走的时候, 首先指针b先走完, 走了b+c步. 然后转移到链表a的开头. 然后两个指针再继续走, 指针a走完, 走了a+c步, 指向b的开头. 当a再走完b步的时候, a和b都走了a+c+b步. 正好处于相交处(可以画图, 更容易理解).</p>
<p>但是感觉比方法1并没有快多少…. 复杂度都是O(m+n), 只是代码少, 但是难以想到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode a = headA;</span><br><span class="line">        ListNode b = headB;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a == b)</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            a = (a == <span class="keyword">null</span>) ? headB : a.next;</span><br><span class="line">            b = (b == <span class="keyword">null</span>) ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 165 Compare Version Numbers</title>
    <url>/2020/10/25/Leetcode/Leetcode%20165%20Compare%20Version%20Numbers/</url>
    <content><![CDATA[<p>Given two version numbers, <code>version1</code> and <code>version2</code>, compare them.</p>
<p>Version numbers consist of <strong>one or more revisions</strong> joined by a dot <code>&#39;.&#39;</code>. Each revision consists of <strong>digits</strong> and may contain leading <strong>zeros</strong>. Every revision contains <strong>at least one character</strong>. Revisions are <strong>0-indexed from left to right</strong>, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example <code>2.5.33</code> and <code>0.1</code> are valid version numbers.</p>
<p>To compare version numbers, compare their revisions in <strong>left-to-right order</strong>. Revisions are compared using their <strong>integer value ignoring any leading zeros</strong>. This means that revisions <code>1</code> and <code>001</code> are considered <strong>equal</strong>. If a version number does not specify a revision at an index, then <strong>treat the revision as <code>0</code></strong>. For example, version <code>1.0</code> is less than version <code>1.1</code> because their revision 0s are the same, but their revision 1s are <code>0</code> and <code>1</code> respectively, and <code>0 &lt; 1</code>.</p>
<p><em>Return the following:</em></p>
<ul>
<li>If <code>version1 &lt; version2</code>, return <code>-1</code>.</li>
<li>If <code>version1 &gt; version2</code>, return <code>1</code>.</li>
<li>Otherwise, return <code>0</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: version1 &#x3D; &quot;1.01&quot;, version2 &#x3D; &quot;1.001&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Ignoring leading zeroes, both &quot;01&quot; and &quot;001&quot; represent the same integer &quot;1&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: version1 &#x3D; &quot;1.0&quot;, version2 &#x3D; &quot;1.0.0&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: version1 does not specify revision 2, which means it is treated as &quot;0&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: version1 &#x3D; &quot;0.1&quot;, version2 &#x3D; &quot;1.1&quot;</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: version1&#39;s revision 0 is &quot;0&quot;, while version2&#39;s revision 0 is &quot;1&quot;. 0 &lt; 1, so version1 &lt; version2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: version1 &#x3D; &quot;1.0.1&quot;, version2 &#x3D; &quot;1&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: version1 &#x3D; &quot;7.5.2.4&quot;, version2 &#x3D; &quot;7.5.3&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= version1.length, version2.length &lt;= 500</code></li>
<li><code>version1</code> and <code>version2</code> only contain digits and <code>&#39;.&#39;</code>.</li>
<li><code>version1</code> and <code>version2</code> <strong>are valid version numbers</strong>.</li>
<li>All the given revisions in <code>version1</code> and <code>version2</code> can be stored in a <strong>32-bit integer</strong>.</li>
</ul>
<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>对于这两个字符串, 用两个双指针, 从左到右地每一次都获取一个版本号, 比较这两个版本号. 如果相等, 就比较下一个版本号.</p>
<p>如果某个字符串结束了, 就只比较另外一个字符串中剩余版本号和0的关系即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> begin2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = version1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = version2.length();</span><br><span class="line">        <span class="keyword">while</span>(end1 &lt; len1 || end2 &lt; len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(end1 &lt; len1 &amp;&amp; version1.charAt(end1) == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++begin1;</span><br><span class="line">                ++end1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(end2 &lt; len2 &amp;&amp; version2.charAt(end2) == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++begin2;</span><br><span class="line">                ++end2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end1 &gt;= len1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(end2 &lt; len2 &amp;&amp; version2.charAt(end2) != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++end2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> v2 = Integer.parseInt(version2.substring(begin2, end2));</span><br><span class="line">                begin2 = end2 = end2 + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(v2 &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(end2 &gt;= len2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(end1 &lt; len1 &amp;&amp; version1.charAt(end1) != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++end1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> v1 = Integer.parseInt(version1.substring(begin1, end1));</span><br><span class="line">                begin1 = end1 = end1 + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(v1 &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(end1 &lt; len1 &amp;&amp; version1.charAt(end1) != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++end1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> v1 = Integer.parseInt(version1.substring(begin1, end1));</span><br><span class="line">                begin1 = end1;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(end2 &lt; len2 &amp;&amp; version2.charAt(end2) != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++end2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> v2 = Integer.parseInt(version2.substring(begin2, end2));</span><br><span class="line">                begin2 = end2;</span><br><span class="line">                <span class="keyword">if</span>(v1 &lt; v2)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(v1 &gt; v2)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 167 Two Sum II Input Array Is Sorted</title>
    <url>/2020/07/20/Leetcode/Leetcode%20167%20Two%20Sum%20II%20Input%20Array%20Is%20Sorted/</url>
    <content><![CDATA[<p>Given an array of integers that is already <strong><em>sorted in ascending order\</em></strong>, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Your returned answers (both index1 and index2) are not zero-based.</li>
<li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 &#x3D; 1, index2 &#x3D; 2.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1 暴力法"></a>1 暴力法</h2><p>两个指针i,j从两边开始判断两数和是否等于target，相等就返回两个指针</p>
<p>若大于tar，右边指针递减，小于tar，左边指针递增</p>
<p>假如这个numbers不是排好序的，也能用hashtable在O(n)时间算出，既然这个是已经排好序的，应该有低于O(n)的方法，但我想了半天没想出来低于O(n)的方法，假如有高人想到，欢迎指点.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] + numbers[j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i + <span class="number">1</span>,j + <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] + numbers[j] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 16 Three Sum Closest</title>
    <url>/2020/07/31/Leetcode/Leetcode%2016%20Three%20Sum%20Closest/</url>
    <content><![CDATA[<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 &#x3D; 2).</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 10^3</code></li>
<li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li>
<li><code>-10^4 &lt;= target &lt;= 10^4</code></li>
</ul>
<a id="more"></a>
<h2 id="双指针扫描"><a href="#双指针扫描" class="headerlink" title="双指针扫描"></a>双指针扫描</h2><p>和leetcode15思路基本相同, 甚至比leetcode15还简单(因为不用去重). </p>
<p>先排序nums</p>
<p>设三个指针ijk</p>
<p>先固定i, j从i+1开始向右移动, k从nums.size() - 1开始向左移动. 当j == k时结束循环. 对于每一个i, j, k, 计算nums[i] + nums[j] + nums[k] 到target的距离, 并将历次的最小距离和对应的sum储存到minDist和minSum中. </p>
<ul>
<li>当nums[i] + nums[j] + nums[k] == target时,直接返回0即可</li>
<li>当nums[i] + nums[j] + nums[k] &gt; target, –k. 因为如果k不递减的话, 只递增j, j越大sum越大, 到target的距离越大.不可能找到更优的解了.</li>
<li>当nums[i] + nums[j] + nums[k] &lt; target, ++j. 因为如果j不递增的话, 只递减k, k越小sum越小, 到target的距离越大.不可能找到更优的解了.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> minDist = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> b = nums[j];</span><br><span class="line">                <span class="keyword">int</span> c = nums[k];</span><br><span class="line">                <span class="keyword">int</span> sum = a + b + c;</span><br><span class="line">                <span class="keyword">int</span> dist = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">                <span class="keyword">if</span>(minDist &gt; dist)</span><br><span class="line">                &#123;</span><br><span class="line">                    minDist = dist;</span><br><span class="line">                    minSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum == target)</span><br><span class="line">                    <span class="keyword">return</span> sum;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 162 Find Peak Element</title>
    <url>/2020/07/20/Leetcode/Leetcode%20162%20Find%20Peak%20Element/</url>
    <content><![CDATA[<p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array <code>nums</code>, where <code>nums[i] ≠ nums[i+1]</code>, find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">Output: 1 or 5 </span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, </span><br><span class="line">             or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong> Your solution should be in logarithmic complexity.</p>
<a id="more"></a>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>首先对于两个端点begin和end,计算mid</p>
<p>这里要利用一个重要的性质</p>
<p><strong>如果<code>nums[mid - 1] &gt; nums[mid]</code>，那么在左边的数组nums[begin]到nums[mid]中，一定存在一个peak！</strong></p>
<p><strong>如果<code>nums[mid + 1] &gt; nums[mid]</code>，那么在右边的数组nums[mid]到nums[end]中，一定存在一个peak！</strong></p>
<p>因为假如<code>nums[mid - 1] &gt; nums[mid]</code>的话，那么必然这个子数组的最后一段是递减的（因为如果一直递增的话<code>nums[mid - 1] &gt; nums[mid]</code>肯定不成立），那么开始递减的第一个元素的前一个元素就是peak。</p>
<p>例如</p>
<ul>
<li>5 6 7 8 <strong>9</strong> 2, 其中nums[mid] = 2, nums[mid - 1] = 9, peak = indexOf(9)</li>
<li><strong>9</strong> 8 7 6 5 4, 其中nums[mid] = 4, nums[mid - 1] = 5, peak = indexOf(5)</li>
<li>4 5 <strong>6</strong> 3 2 1, 其中nums[mid] = 1, nums[mid - 1] = 2, peak = indexOf(6)</li>
</ul>
<p>而当<code>nums[mid - 1] &lt; nums[mid]</code>时，可能有peak 也可能没有peak，我们直接不考虑这一部分，因为即使不考虑这一个可能出现的peak，也能保证最后找到至少1个peak</p>
<ul>
<li>1 2 3 4 5 6, 其中nums[mid] = 6, nums[mid - 1] = 5, 不存在peak</li>
<li>2 <strong>3</strong> 1 4 5 6, 其中nums[mid] = 6, nums[mid - 1] = 5, peak = indexOf(3)</li>
</ul>
<p>所以，根据上面的讨论</p>
<ul>
<li>如果<code>nums[mid] &gt; nums[mid - 1] &amp;&amp; nums[mid] &gt; nums[mid + 1]</code>,那么显然mid是一个peak</li>
<li>如果<code>nums[mid] &lt; nums[mid - 1]</code>， peak在左边的数组nums[begin]到nums[mid]中</li>
<li>如果<code>nums[mid] &gt; nums[mid - 1]</code>，peak在右边的数组nums[mid]到nums[end]中</li>
</ul>
<p>这里，为了保证mid-1和mid+1不越界，所以要保证end - begin &gt;=2</p>
<p>当end - begin == 1 或end - begin == 0时，显然peak = nums[begin] &gt; nums[end] ? begin : end;</p>
<p>这样的算法每次花常数时间使数组规模减少一半，<code>T(n) = T(n/2) +O(1)</code>，显然是对数复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findPeakElement(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span> || <span class="built_in">end</span> - <span class="built_in">begin</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="built_in">begin</span>] &gt; nums[<span class="built_in">end</span>] ? <span class="built_in">begin</span> : <span class="built_in">end</span>;  <span class="comment">//recursion boundary</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midLeft = nums[mid - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> midRight = nums[mid + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(midLeft &lt; nums[mid] &amp;&amp; midRight &lt; nums[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(midLeft &gt; nums[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findPeakElement(nums,<span class="built_in">begin</span>,mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(midRight &gt; nums[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findPeakElement(nums,mid,<span class="built_in">end</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;recursion should return before!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 169 Majority Element</title>
    <url>/2020/08/14/Leetcode/Leetcode%20169%20Majority%20Element/</url>
    <content><![CDATA[<p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>



<a id="more"></a>
<h2 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1 暴力法"></a>1 暴力法</h2><p>维护一个hashmap,对应数组中的值和出现的次数, 遍历数组后, 然后找map中出现次数最高的元素的值,</p>
<p>由于创建这个hashmap的复杂度为n，map中找最大的也为n 所以总复杂度为O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(i) == mp.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                mp.insert(&#123;i,<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++mp.<span class="built_in">find</span>(i)-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; i : mp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second &gt; count)</span><br><span class="line">            &#123;</span><br><span class="line">                count = i.second;</span><br><span class="line">                res = i.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-摩尔投票"><a href="#2-摩尔投票" class="headerlink" title="2 摩尔投票"></a>2 摩尔投票</h2><p>观察到，如果有一个出现次数大于n/2的数，那么从左到右遍历一遍，只要发现两个不一样的数就划掉这两个数，最后剩下的数一定是最多的数。</p>
<p>所以构造一个值current记录当前的数值，和一个计数器count；如果读到下一个值和current相同，计数器加一，如果和current不同，就令count - 1，当count &lt; 0时，更新current的值为nums[i]，同时将count置为0</p>
<p>遍历完后的current即为所求.虽然时间复杂度也为O(n)，但是只需要O(1)的空间复杂度。而暴力法则需要O(m)的空间复杂度，其中m为数组中不一样的数的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == current)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --count;</span><br><span class="line">            <span class="keyword">if</span>(count &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                current = nums[i];</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 17 Letter Combinations Of A Phone Number</title>
    <url>/2020/09/24/Leetcode/Leetcode%2017%20Letter%20Combinations%20Of%20A%20Phone%20Number/</url>
    <content><![CDATA[<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt="img"></p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<a id="more"></a>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>直接使用DFS枚举出所有的可能性, 不需要任何条件的判断和剪枝.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution()</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">string</span> tmpString;</span><br><span class="line">        letterCombinations(ans, tmpString, digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; int2char;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        int2char.insert(&#123;<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;&#125;);</span><br><span class="line">        int2char.insert(&#123;<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&#123;<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;&#125;);</span><br><span class="line">        int2char.insert(&#123;<span class="number">4</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;&#125;);</span><br><span class="line">        int2char.insert(&#123;<span class="number">5</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&#123;<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>&#125;&#125;);</span><br><span class="line">        int2char.insert(&#123;<span class="number">6</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&#123;<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;&#125;);</span><br><span class="line">        int2char.insert(&#123;<span class="number">7</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&#123;<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>&#125;&#125;);</span><br><span class="line">        int2char.insert(&#123;<span class="number">8</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&#123;<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;&#125;);</span><br><span class="line">        int2char.insert(&#123;<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&#123;<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">letterCombinations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans,<span class="built_in">string</span>&amp; curr, <span class="keyword">const</span> <span class="built_in">string</span>&amp; digits, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == digits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = digits[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch : int2char[tmp])</span><br><span class="line">            &#123;</span><br><span class="line">                curr += ch;</span><br><span class="line">                letterCombinations(ans, curr, digits, i + <span class="number">1</span>);</span><br><span class="line">                curr.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 168 Excel Sheet Column Title</title>
    <url>/2020/10/24/Leetcode/Leetcode%20168%20Excel%20Sheet%20Column%20Title/</url>
    <content><![CDATA[<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;A&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 28</span><br><span class="line">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 701</span><br><span class="line">Output: &quot;ZY&quot;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="特殊的26进制"><a href="#特殊的26进制" class="headerlink" title="特殊的26进制"></a>特殊的26进制</h2><p>这题想了好几天才想明白.</p>
<p>这个26进制是特殊的. 没有0, 但是有26.</p>
<p>首先要计算普通的26进制表示, 有0没26的(在这个题里就是有‘@’没有’Z’)</p>
<p>例如 <code>457002 -&gt; 26^4 + 26^1-&gt; &quot;A@@A@&quot;</code></p>
<p><strong>然后从后向前地借位,</strong> 如果发现某一位是0或者比0小(这里的0就是‘@’), 就从前面的位置借一位</p>
<p>比如, “A@@A@”最后一位就是0, 不满足要求, 从前面借一位变为‘@’ + 26, 即’Z’. 而前面的一位变为A - 1 = @</p>
<p><code>&quot;A@@A@&quot; -&gt; &quot;A@@@Z&quot;</code></p>
<p>倒数第二位现在也不符合要求了, 再借一位变为@ + 26 = Z, 而前面的倒数第三位变为了@ - 1 = ?</p>
<p><code>&quot;A@@@Z&quot; -&gt; &quot;A@?ZZ&quot;</code></p>
<p>倒数第三位再从倒数第二位借位, 变为 ? + 26 = Y, 倒数第四位变为 @ - 1 = ?</p>
<p><code>&quot;A@?ZZ&quot; -&gt; &quot;A?YZZ&quot;</code></p>
<p>最后, 倒数第四位再向第一位借位, 变为 ? + 26 = Y, 第一位变为 A - 1 = @</p>
<p><code>&quot;A?YZZ&quot; -&gt; &quot;@YYZZ&quot;</code></p>
<p>最后去掉前面的所有0, (所有‘@’)即可</p>
<p><code>&quot;@YYZZ&quot; -&gt; &quot;YYZZ&quot;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = n % <span class="number">26</span>;</span><br><span class="line">            s.push_back(tmp + <span class="string">&#x27;@&#x27;</span>); <span class="comment">// &#x27;@&#x27; equals &#x27;A&#x27; - 1. </span></span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="built_in">string</span>(s.rbegin(), s.rend());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[i] += <span class="number">26</span>;</span><br><span class="line">                s[i<span class="number">-1</span>] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="built_in">std</span>::find_if(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), [](<span class="keyword">char</span> ch)&#123;<span class="keyword">return</span> ch != <span class="string">&#x27;@&#x27;</span>;&#125;), s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 173 Binary Search Tree Iterator</title>
    <url>/2020/10/26/Leetcode/Leetcode%20173%20Binary%20Search%20Tree%20Iterator/</url>
    <content><![CDATA[<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling <code>next()</code> will return the next smallest number in the BST.</p>
<p><strong>Example:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BSTIterator iterator &#x3D; new BSTIterator(root);</span><br><span class="line">iterator.next();    &#x2F;&#x2F; return 3</span><br><span class="line">iterator.next();    &#x2F;&#x2F; return 7</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; return true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; return 9</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; return true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; return 15</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; return true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; return 20</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; return false</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ul>
<li><code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.</li>
<li>You may assume that <code>next()</code> call will always be valid, that is, there will be at least a next smallest number in the BST when <code>next()</code> is called.</li>
</ul>
<a id="more"></a>
<h2 id="非递归形式的中序遍历"><a href="#非递归形式的中序遍历" class="headerlink" title="非递归形式的中序遍历"></a>非递归形式的中序遍历</h2><p>其实就是把中序遍历非递归形式拆解下来. </p>
<p>首先令tmp = root, 然后循环的进行push(tmp), tmp = tmp-&gt;left. 直到tmp为null. 初始工作结束.</p>
<p>每从栈中取出一个值top, 返回top-&gt;val, 并且令tmp = top-&gt;right. 然后循环的进行push(tmp), tmp = tmp-&gt;left.</p>
<p>当栈为空时即可完成中序遍历的过程. 由于只push了n个节点, 所以平均时间复杂度是O(1). 栈中保存的最大也只是二叉树的高度. 满足空间复杂度O(h).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stk = <span class="keyword">new</span> ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode tmp = root;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stk.offerFirst(tmp);</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode top = stk.pollFirst();</span><br><span class="line">        <span class="keyword">int</span> ans = top.val;</span><br><span class="line">        TreeNode tmp = top.right;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stk.offerFirst(tmp);</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next();</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 172 Factorial Trailing Zeroes</title>
    <url>/2020/10/15/Leetcode/Leetcode%20172%20Factorial%20Trailing%20Zeroes/</url>
    <content><![CDATA[<p>Given an integer <code>n</code>, return <em>the number of trailing zeroes in <code>n!</code></em>.</p>
<p><strong>Follow up:</strong> Could you write a solution that works in logarithmic time complexity?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: 3! &#x3D; 6, no trailing zero.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 5! &#x3D; 120, one trailing zero.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 104</code></li>
</ul>
<a id="more"></a>
<h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><p>首先n!中0的个数为含有5的因子的个数. </p>
<p>例如, 10!里面有5和10两个数含有因子5, 所以是2.</p>
<p>25!中, 5, 10, 15, 20, 25都含有因子5, 但是25含有2个因子5, 所以这里有6个因子5. 以此类推125含有3个5, 625含有4个因子5…</p>
<p>所以, 我们先从(5, 10, 15,20, 25, ..)这些数中取出1个因子5来(一共n/5个数), 然后将 n 除以 5, 这样, 25就变成了5, 即含有多个因子5的数还能再被除一次.以此类推直到n == 0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            ans += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 171 Excel Sheet Column Number</title>
    <url>/2020/10/15/Leetcode/Leetcode%20171%20Excel%20Sheet%20Column%20Number/</url>
    <content><![CDATA[<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;A&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;AB&quot;</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;ZY&quot;</span><br><span class="line">Output: 701</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 7</code></li>
<li><code>s</code> consists only of uppercase English letters.</li>
<li><code>s</code> is between “A” and “FXSHRXW”.</li>
</ul>
<a id="more"></a>
<h2 id="26进制"><a href="#26进制" class="headerlink" title="26进制"></a>26进制</h2><p>本质上就是26进制. 只不过这种方式没法表示0. 因为是从1开始的</p>
<p>所以要注意计算的时候有<code>int tmp = s.charAt(i) - &#39;A&#39; + 1;</code> 而不是<code>int tmp = s.charAt(i) - &#39;A&#39;;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans *= <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &lt; <span class="string">&#x27;A&#x27;</span> || s.charAt(i) &gt; <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;string has non-uppercase char.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = s.charAt(i) - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">            ans += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 176 Second Highest Salary</title>
    <url>/2020/10/25/Leetcode/Leetcode%20176%20Second%20Highest%20Salary/</url>
    <content><![CDATA[<p>Write a SQL query to get the second highest salary from the <code>Employee</code> table.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>

<p>For example, given the above Employee table, the query should return <code>200</code> as the second highest salary. If there is no second highest salary, then the query should return <code>null</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-LIMIT-OFFSET"><a href="#1-LIMIT-OFFSET" class="headerlink" title="1 LIMIT OFFSET"></a>1 LIMIT OFFSET</h2><p>第一次尝试以失败告终, 原因是因为不知道怎么处理null的情况. 当表中只有1行时, SELECT只会返回empty set 而不是 NULL.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># error when occur the table contains only one row.</span></span><br><span class="line"><span class="keyword">SELECT</span> Salary <span class="keyword">AS</span> SecondHighestSalary <span class="keyword">FROM</span> Employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-ISNULL-函数"><a href="#2-ISNULL-函数" class="headerlink" title="2 ISNULL()函数"></a>2 ISNULL()函数</h2><p>ISNULL(A, B) 当A为NULL的时候返回B. 这样就解决了返回NULL的情况了. 注意, 为了避免并列第一, 要用DISTINCT关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IFNULL</span>((<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary <span class="keyword">FROM</span> Employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>), <span class="literal">NULL</span>) <span class="keyword">AS</span> SecondHighestSalary;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 179 Largest Number</title>
    <url>/2020/10/31/Leetcode/Leetcode%20179%20Largest%20Number/</url>
    <content><![CDATA[<p>Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number.</p>
<p><strong>Note:</strong> The result may be very large, so you need to return a string instead of an integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [10,2]</span><br><span class="line">Output: &quot;210&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,30,34,5,9]</span><br><span class="line">Output: &quot;9534330&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [10]</span><br><span class="line">Output: &quot;10&quot;</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<a id="more"></a>
<h2 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h2><p>很明显的发现, 字典序越大的数, 越应该放前面. 例如[9, 88, 777]肯定是988777最大</p>
<p>但是, 有一些特殊情况需要处理. 比如前缀相同的字符串的排序</p>
<p>例如 [34, 343]. 这样因为343 34 &lt; 34 343 所以34应该放前面</p>
<p>但是这个例子[32, 323]. 就变成了32 323 &lt; 323 32 所以323应该放在前面</p>
<p><strong>所以问题转变成了, 相同前缀的字符串, 哪个应该放前面呢?</strong></p>
<p><strong>所以应该判断 a + b 和 b + a的大小.</strong> </p>
<p><strong>如果a+b大, a就放到前面. 反之b放在前面.</strong></p>
<p>上面的判断方式我一开始没想到, 自己想的方法是按位判断的. 又麻烦又难以理解. 还是太菜了😭😭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            strings[i] = nums[i] + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Comparator&lt;String&gt; cmp = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">                String s1 = a + b;</span><br><span class="line">                String s2 = b + a;</span><br><span class="line">                <span class="keyword">if</span>(s1.compareTo(s2) &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s1.compareTo(s2) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(strings, cmp);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = strings.length - <span class="number">1</span>; i &gt; -<span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = sb.toString();</span><br><span class="line">        <span class="keyword">if</span>(ans.length() &lt; <span class="number">1</span> || ans.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 178 Rank Scores</title>
    <url>/2020/10/25/Leetcode/Leetcode%20178%20Rank%20Scores/</url>
    <content><![CDATA[<p>Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no “holes” between ranks.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Score |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | 3.50  |</span><br><span class="line">| 2  | 3.65  |</span><br><span class="line">| 3  | 4.00  |</span><br><span class="line">| 4  | 3.85  |</span><br><span class="line">| 5  | 4.00  |</span><br><span class="line">| 6  | 3.65  |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>

<p>For example, given the above <code>Scores</code> table, your query should generate the following report (order by highest score):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+---------+</span><br><span class="line">| score | Rank    |</span><br><span class="line">+-------+---------+</span><br><span class="line">| 4.00  | 1       |</span><br><span class="line">| 4.00  | 1       |</span><br><span class="line">| 3.85  | 2       |</span><br><span class="line">| 3.65  | 3       |</span><br><span class="line">| 3.65  | 3       |</span><br><span class="line">| 3.50  | 4       |</span><br><span class="line">+-------+---------+</span><br></pre></td></tr></table></figure>

<p><strong>Important Note:</strong> For MySQL solutions, to escape reserved words used as column names, you can use an apostrophe before and after the keyword. For example <strong><code>Rank</code></strong>.</p>
<a id="more"></a>
<h2 id="1-利用count-distinct"><a href="#1-利用count-distinct" class="headerlink" title="1 利用count(distinct)"></a>1 利用count(distinct)</h2><p><strong>对于任意一个值a, 这个值的排名就等于大于等于a的所有值去重之后的个数.</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> score, (<span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> score) <span class="keyword">from</span> Scores <span class="keyword">where</span> score &gt;= t1.score) <span class="keyword">as</span> <span class="string">&#x27;Rank&#x27;</span> <span class="keyword">from</span> Scores <span class="keyword">as</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>



<h2 id="2-窗口函数"><a href="#2-窗口函数" class="headerlink" title="2 窗口函数"></a>2 窗口函数</h2><p>不得不说, 窗口函数是真香</p>
<p>在MySQL里Rank是保留字, 所以要用<code>as &#39;Rank&#39;</code>而不是 <code>as Rank</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> Score, <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="string">&#x27;Rank&#x27;</span> <span class="keyword">from</span> Scores;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 180 Consecutive Numbers</title>
    <url>/2020/10/25/Leetcode/Leetcode%20180%20Consecutive%20Numbers/</url>
    <content><![CDATA[<p>Write a SQL query to find all numbers that appear at least three times consecutively.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-----+</span><br><span class="line">| Id | Num |</span><br><span class="line">+----+-----+</span><br><span class="line">| 1  |  1  |</span><br><span class="line">| 2  |  1  |</span><br><span class="line">| 3  |  1  |</span><br><span class="line">| 4  |  2  |</span><br><span class="line">| 5  |  1  |</span><br><span class="line">| 6  |  2  |</span><br><span class="line">| 7  |  2  |</span><br><span class="line">+----+-----+</span><br></pre></td></tr></table></figure>

<p>For example, given the above <code>Logs</code> table, <code>1</code> is the only number that appears consecutively for at least three times.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+</span><br><span class="line">| ConsecutiveNums |</span><br><span class="line">+-----------------+</span><br><span class="line">| 1               |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>连接2次, 找到连续出现3次的值之后去重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> t1.Num <span class="keyword">as</span> ConsecutiveNums <span class="keyword">from</span> <span class="keyword">logs</span> <span class="keyword">as</span> t1, <span class="keyword">logs</span> <span class="keyword">as</span> t2, <span class="keyword">logs</span> <span class="keyword">as</span> t3 <span class="keyword">where</span> t1.num = t2.num <span class="keyword">and</span> t2.num = t3.num <span class="keyword">and</span> t1.Id + <span class="number">1</span> = t2.Id <span class="keyword">and</span> t2.Id + <span class="number">1</span> = t3.Id;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 18 Four Sum</title>
    <url>/2020/07/31/Leetcode/Leetcode%2018%20Four%20Sum/</url>
    <content><![CDATA[<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate quadruplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given array nums &#x3D; [1, 0, -1, 0, -2, 2], and target &#x3D; 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>完全参考leetcode15 3sum的双指针法,只不过在外面又加了一层循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvc;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> vvc;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> a = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> b = nums[j];</span><br><span class="line">                <span class="keyword">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> m = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &lt; m)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k &gt; j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        ++k;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(m &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[m] == nums[m+<span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        --m;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> c = nums[k];</span><br><span class="line">                    <span class="keyword">int</span> d = nums[m];</span><br><span class="line">                    <span class="keyword">int</span> sum = a + b + c + d;</span><br><span class="line">                    <span class="keyword">if</span>(sum == target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = &#123;a,b,c,d&#125;;</span><br><span class="line">                        vvc.push_back(tmp);</span><br><span class="line">                        ++k;</span><br><span class="line">                        --m;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                        ++k;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        --m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 175 Combine Two Tables</title>
    <url>/2020/10/25/Leetcode/Leetcode%20175%20Combine%20Two%20Tables/</url>
    <content><![CDATA[<p>Table: <code>Person</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">PersonId is the primary key column for this table.</span><br></pre></td></tr></table></figure>

<p>Table: <code>Address</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">AddressId is the primary key column for this table.</span><br></pre></td></tr></table></figure>



<p>Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FirstName, LastName, City, State</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h2><p>如果使用INNER JOIN, 在测试样例中, 有的PersonId只在表Person中出现, 但是答案要求没在Address中出现的要用NULL. 所以只能用表Person LEFT OUTER JOIN Address.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">SELECT</span> FirstName, LastName, City, State <span class="keyword">FROM</span> Person <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Address <span class="keyword">ON</span> Person.PersonId = Address.PersonId;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 181 Employees Earning More Than Their Managers</title>
    <url>/2020/10/25/Leetcode/Leetcode%20181%20Employees%20Earning%20More%20Than%20Their%20Managers/</url>
    <content><![CDATA[<p>The <code>Employee</code> table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+----+-------+--------+-----------+</span><br></pre></td></tr></table></figure>

<p>Given the <code>Employee</code> table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| Employee |</span><br><span class="line">+----------+</span><br><span class="line">| Joe      |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h2><p>自联结即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">SELECT</span> p1.Name <span class="keyword">AS</span> Employee <span class="keyword">FROM</span> Employee <span class="keyword">AS</span> p1, Employee <span class="keyword">AS</span> p2 </span><br><span class="line"><span class="keyword">WHERE</span> p1.ManagerId = p2.Id <span class="keyword">AND</span> p1.Salary &gt; p2.Salary;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 183 Customers Who Never Order</title>
    <url>/2020/10/25/Leetcode/Leetcode%20183%20Customers%20Who%20Never%20Order/</url>
    <content><![CDATA[<p>Suppose that a website contains two tables, the <code>Customers</code> table and the <code>Orders</code> table. Write a SQL query to find all customers who never order anything.</p>
<p>Table: <code>Customers</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>

<p>Table: <code>Orders</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br></pre></td></tr></table></figure>

<p>Using the above tables as example, return the following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| Customers |</span><br><span class="line">+-----------+</span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>先从<code>Orders</code>里面找出所有购买过东西的顾客id组成一个集合A, 然后再判断customer里的每个顾客是否在A中.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span> <span class="keyword">AS</span> Customers <span class="keyword">FROM</span> Customers <span class="keyword">WHERE</span> <span class="keyword">Id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> CustomerId <span class="keyword">FROM</span> Orders</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 184 Department Highest Salary</title>
    <url>/2020/10/27/Leetcode/Leetcode%20184%20Department%20Highest%20Salary/</url>
    <content><![CDATA[<p>The <code>Employee</code> table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Jim   | 90000  | 1            |</span><br><span class="line">| 3  | Henry | 80000  | 2            |</span><br><span class="line">| 4  | Sam   | 60000  | 2            |</span><br><span class="line">| 5  | Max   | 90000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure>

<p>The <code>Department</code> table holds all departments of the company.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure>

<p>Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, your SQL query should return the following rows (order of rows does not matter).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| IT         | Jim      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></table></figure>

<p><strong>Explanation:</strong></p>
<p>Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department.</p>
<a id="more"></a>
<h2 id="1-窗口函数"><a href="#1-窗口函数" class="headerlink" title="1 窗口函数"></a>1 窗口函数</h2><p>不得不说窗口函数真的很好用, 好用的让人上瘾. 尤其是分组求top n.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> t2.Name <span class="keyword">as</span> Department, t1.Name <span class="keyword">as</span> Employee, </span><br><span class="line">t1.Salary <span class="keyword">from</span> (<span class="keyword">select</span> DepartmentId, <span class="keyword">Name</span>, Salary, <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> DepartmentId <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>) <span class="keyword">as</span> rnk <span class="keyword">from</span> Employee) <span class="keyword">as</span> t1 </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> Department <span class="keyword">as</span> t2 <span class="keyword">on</span> t1.DepartmentId = t2.Id <span class="keyword">where</span> t1.rnk = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-聚合函数-group-by"><a href="#2-聚合函数-group-by" class="headerlink" title="2 聚合函数 + group by"></a>2 聚合函数 + group by</h2><p>用max和group by也能解决问题. 但是换个题, 比如求每个部门前两名高的salary就无能为力了</p>
<p><strong>同时要注意两字段的IN</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t2.Name <span class="keyword">as</span> Department, t1.Name <span class="keyword">as</span> Employee, t1.Salary </span><br><span class="line"><span class="keyword">from</span> Employee <span class="keyword">as</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> Department <span class="keyword">as</span> t2 <span class="keyword">on</span> t1.DepartmentId = t2.Id </span><br><span class="line"><span class="keyword">where</span> (t1.Salary, t1.DepartmentId) <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">max</span>(Salary), DepartmentId <span class="keyword">from</span> Employee <span class="keyword">group</span> <span class="keyword">by</span> DepartmentId);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 182 Duplicate Emails</title>
    <url>/2020/10/25/Leetcode/Leetcode%20182%20Duplicate%20Emails/</url>
    <content><![CDATA[<p>Write a SQL query to find all duplicate emails in a table named <code>Person</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure>

<p>For example, your query should return the following for the above table:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>: All emails are in lowercase.</p>
<a id="more"></a>
<h2 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h2><p>先根据Email自联结<code>select t1.Email from Person as t1, Person as t2 where t1.Email = t2.Email; </code></p>
<table>
<thead>
<tr>
<th>Id1</th>
<th>Email1</th>
<th align="left">Id2</th>
<th>Email2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a href="mailto:&#97;&#x40;&#98;&#x2e;&#x63;&#111;&#x6d;">&#97;&#x40;&#98;&#x2e;&#x63;&#111;&#x6d;</a></td>
<td align="left">1</td>
<td><a href="mailto:&#x61;&#x40;&#x62;&#x2e;&#x63;&#111;&#x6d;">&#x61;&#x40;&#x62;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>1</td>
<td><a href="mailto:&#x61;&#x40;&#98;&#x2e;&#99;&#x6f;&#109;">&#x61;&#x40;&#98;&#x2e;&#99;&#x6f;&#109;</a></td>
<td align="left">3</td>
<td><a href="mailto:&#97;&#64;&#x62;&#46;&#99;&#111;&#x6d;">&#97;&#64;&#x62;&#46;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>2</td>
<td><a href="mailto:&#x63;&#64;&#x64;&#x2e;&#x63;&#111;&#x6d;">&#x63;&#64;&#x64;&#x2e;&#x63;&#111;&#x6d;</a></td>
<td align="left">2</td>
<td><a href="mailto:&#x63;&#x40;&#x64;&#x2e;&#99;&#x6f;&#x6d;">&#x63;&#x40;&#x64;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>3</td>
<td><a href="mailto:&#97;&#x40;&#x62;&#x2e;&#99;&#111;&#109;">&#97;&#x40;&#x62;&#x2e;&#99;&#111;&#109;</a></td>
<td align="left">1</td>
<td><a href="mailto:&#97;&#64;&#x62;&#x2e;&#99;&#111;&#x6d;">&#97;&#64;&#x62;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>3</td>
<td><a href="mailto:&#97;&#x40;&#98;&#x2e;&#99;&#111;&#x6d;">&#97;&#x40;&#98;&#x2e;&#99;&#111;&#x6d;</a></td>
<td align="left">3</td>
<td><a href="mailto:&#97;&#x40;&#98;&#46;&#x63;&#x6f;&#x6d;">&#97;&#x40;&#98;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
</tbody></table>
<p>再加上条件判断两个id是不是相等. 去掉相等的id, 就只剩下重复的了</p>
<table>
<thead>
<tr>
<th>Id1</th>
<th>Email1</th>
<th>Id2</th>
<th>Email2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a href="mailto:&#97;&#64;&#x62;&#46;&#99;&#x6f;&#109;">&#97;&#64;&#x62;&#46;&#99;&#x6f;&#109;</a></td>
<td>3</td>
<td><a href="mailto:&#x61;&#64;&#98;&#x2e;&#99;&#x6f;&#109;">&#x61;&#64;&#98;&#x2e;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>3</td>
<td><a href="mailto:&#x61;&#64;&#98;&#46;&#x63;&#111;&#x6d;">&#x61;&#64;&#98;&#46;&#x63;&#111;&#x6d;</a></td>
<td>1</td>
<td><a href="mailto:&#97;&#64;&#98;&#x2e;&#x63;&#111;&#109;">&#97;&#64;&#98;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>最后再加一个distinct即可</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> t1.Email <span class="keyword">from</span> Person <span class="keyword">as</span> t1, Person <span class="keyword">as</span> t2 </span><br><span class="line"><span class="keyword">where</span> t1.Email = t2.Email <span class="keyword">and</span> t1.Id != t2.Id; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 185 Department Top Three Salaries</title>
    <url>/2020/10/29/Leetcode/Leetcode%20185%20Department%20Top%20Three%20Salaries/</url>
    <content><![CDATA[<p>The <code>Employee</code> table holds all employees. Every employee has an Id, and there is also a column for the department Id.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 85000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">| 5  | Janet | 69000  | 1            |</span><br><span class="line">| 6  | Randy | 85000  | 1            |</span><br><span class="line">| 7  | Will  | 70000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure>

<p>The <code>Department</code> table holds all departments of the company.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure>

<p>Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| IT         | Randy    | 85000  |</span><br><span class="line">| IT         | Joe      | 85000  |</span><br><span class="line">| IT         | Will     | 70000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">| Sales      | Sam      | 60000  |</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></table></figure>

<p><strong>Explanation:</strong></p>
<p>In IT department, Max earns the highest salary, both Randy and Joe earn the second highest salary, and Will earns the third highest salary. There are only two employees in the Sales department, Henry earns the highest salary while Sam earns the second highest salary.</p>
<a id="more"></a>
<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>就五个字, <strong>窗口函数真香</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> t2.Name <span class="keyword">as</span> Department, t1.name <span class="keyword">as</span> Employee, t1.Salary </span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">Id</span>, <span class="keyword">Name</span>, Salary, DepartmentId, <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> DepartmentId <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>) <span class="keyword">as</span> rank_ <span class="keyword">from</span> Employee</span><br><span class="line">) <span class="keyword">as</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> Department <span class="keyword">as</span> t2 <span class="keyword">on</span> t1.DepartmentId = t2.Id <span class="keyword">where</span> t1.rank_ &lt;= <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 19 Remove Nth Node From End Of List</title>
    <url>/2020/09/24/Leetcode/Leetcode%2019%20Remove%20Nth%20Node%20From%20End%20Of%20List/</url>
    <content><![CDATA[<p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>Given <em>n</em> will always be valid.</p>
<p><strong>Follow up:</strong></p>
<p>Could you do this in one pass?</p>
<a id="more"></a>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>因为是删除倒数第n个点. 我们可以设置2个指针, 快指针比慢指针快n个节点. 所以, 当我们再次遍历快慢指针时(快慢指针每一次都走1步), <strong>当快指针走到链表尾部的时候, 慢指针正好走到倒数第n个节点的前一个节点</strong>, 记为prev. 我们只需要令<code>prev-&gt;next = prev-&gt;next-&gt;next</code>即可删去倒数第n个节点.</p>
<p>Tips, 这个题给的链表是不带头结点的. 为了处理特殊情况, 比如链表只有1个元素要删除倒数第1个元素, 假如用上述方法会产生异常. 所以可以先添加链表头节点<code>ListNode* listHead = new ListNode(0, head);</code>, 再进行操作.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* listHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* fast = listHead;</span><br><span class="line">        ListNode* slow = listHead;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> listHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 189 Rotate Array</title>
    <url>/2020/07/20/Leetcode/Leetcode%20189%20Rotate%20Array/</url>
    <content><![CDATA[<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>
<li>Could you do it in-place with O(1) extra space?</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">Output: [3,99,-1,-100]</span><br><span class="line">Explanation: </span><br><span class="line">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class="line">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li>
<li>It’s guaranteed that <code>nums[i]</code> fits in a 32 bit-signed integer.</li>
<li><code>k &gt;= 0</code></li>
</ul>
<a id="more"></a>
<h2 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1 暴力法"></a>1 暴力法</h2><p>以下均假设k &lt; nums.size()，否则令 k %= nums.size()即可，因为对数组进行k = nums.size()次rotate数组保持不变</p>
<p>先备份后k个值, 再从前部将后k个值插入nums首部，再截取掉最后k个值，即为所求。但是这样需要O(2k)的空间复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        k = k % nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> origin_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator shift_begin = nums.<span class="built_in">end</span>() - k;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">new_vc</span><span class="params">(shift_begin, nums.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        nums.insert(nums.<span class="built_in">begin</span>(), new_vc.<span class="built_in">begin</span>(), new_vc.<span class="built_in">end</span>());</span><br><span class="line">        nums.resize(origin_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-数组翻转"><a href="#2-数组翻转" class="headerlink" title="2 数组翻转"></a>2 数组翻转</h2><p>注意到这样一个事实，我们假设数组a的前nums.size() - k个元素组成的子数组为a1, 后k个元素组成的子数组a2，则将a1,a2翻转后变为数组[a1’,a2’]，再将这个数组翻转变为[a2’,a1’]这个新数组即为所求！</p>
<p>举例说明一下, nums.size() = 10, k = 4</p>
<p>则划分为两个子数组[0,1,2,3,4,5,<strong>6,7,8,9</strong>].(加粗的是一个不加粗的是另一个)</p>
<p>对这两个数组分别翻转，变为[5,4,3,2,1,0,<strong>9,8,7,6</strong>]</p>
<p>再对整体的数组翻转[<strong>6,7,8,9</strong>,0,1,2,3,4,5]就得到了正确答案.并且空间占用为O(1)。不得不感叹想到这个解法的人的聪明！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        k = k % nums.<span class="built_in">size</span>();</span><br><span class="line">        reverse(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>() - k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums,nums.<span class="built_in">size</span>() - k, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums[<span class="built_in">begin</span>], nums[<span class="built_in">end</span>]);</span><br><span class="line">            ++<span class="built_in">begin</span>;</span><br><span class="line">            --<span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 190 Reverse Bits</title>
    <url>/2020/10/15/Leetcode/Leetcode%20190%20Reverse%20Bits/</url>
    <content><![CDATA[<p>Reverse bits of a given 32 bits unsigned integer.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li>
<li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two's_complement">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>
</ul>
<p><strong>Follow up</strong>:</p>
<p>If this function is called many times, how would you optimize it?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 00000010100101000001111010011100</span><br><span class="line">Output:    964176192 (00111001011110000010100101000000)</span><br><span class="line">Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 11111111111111111111111111111101</span><br><span class="line">Output:   3221225471 (10111111111111111111111111111111)</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The input must be a <strong>binary string</strong> of length <code>32</code></li>
</ul>
<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1 暴力"></a>1 暴力</h2><p>对于i从 0 到 31, j = 31 - i, 我们需要交换第i位和第j位. </p>
<p>首先求出第i位和第j位的值a和b. 然后设置第j位为a, 设置第i位为b.重复16次这样的操作.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">31</span> - i;</span><br><span class="line">            <span class="keyword">int</span> a = ((<span class="number">1</span> &lt;&lt; i) &amp; n) &gt;&gt;&gt; i;</span><br><span class="line">            <span class="keyword">int</span> b = ((<span class="number">1</span> &lt;&lt; j) &amp; n) &gt;&gt;&gt; j;</span><br><span class="line">            n = (a == <span class="number">0</span>) ? (n &amp; ~(<span class="number">1</span> &lt;&lt; j)) : (n | (<span class="number">1</span> &lt;&lt; j));</span><br><span class="line">            n = (b == <span class="number">0</span>) ? (n &amp; ~(<span class="number">1</span> &lt;&lt; i)) : (n | (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-分治"><a href="#2-分治" class="headerlink" title="2 分治"></a>2 分治</h2><p>首先要注意java里面一定要用无符号右移!!! 不然负数的右移会出现最左侧补1的错误而不是最左侧补0. </p>
<p>首先先交换前16位和后16位. 即 <code>n = (n &gt;&gt;&gt; 16) | (n &lt;&lt; 16)</code></p>
<p>然后在前16位中, 交换前8位和后8位, 后16位中, 也是交换前8位和后8位.</p>
<p>具体的做法如下</p>
<blockquote>
<p><strong>首先定义两个数, 可以把前8位的元素和后8位的元素提取出来.</strong></p>
<p>a1 = 0000 0000 1111 1111 0000 0000 1111 1111</p>
<p>a2 = 1111 1111 0000 0000 1111 1111 0000 0000</p>
<p>这样, n &amp; a1就是后8位的元素, n &amp; a2就是前8位的元素. 然后交换. </p>
<p><code>n = ((n &amp; a1) &lt;&lt; 8) | ((n &amp; a2) &gt;&gt;&gt; 8)</code></p>
</blockquote>
<p>然后每8位一组, 交换前4个元素和后4个元素.</p>
<blockquote>
<p>此时的a1和a2应该为:</p>
<p>a1 = 0000 1111 0000 1111 0000 1111 0000 1111</p>
<p>a2 = 1111 0000 1111 0000 1111 0000 1111 0000</p>
<p><code>n = ((n &amp; a1) &lt;&lt; 4) | ((n &amp; a2) &gt;&gt;&gt; 4)</code></p>
</blockquote>
<p>然后每4位一组, 交换前2个元素和后2个元素</p>
<blockquote>
<p>此时的a1和a2应该为:</p>
<p>a1 = 0011 0011 0011 0011 0011 0011 0011 0011</p>
<p>a2 = 1100 1100 1100 1100 1100 1100 1100 1100</p>
<p><code>n = ((n &amp; a1) &lt;&lt; 2) | ((n &amp; a2) &gt;&gt;&gt; 2)</code></p>
</blockquote>
<p>然后每2位一组, 交换前1个元素和后1个元素</p>
<blockquote>
<p>此时的a1和a2应该为:</p>
<p>a1 = 0101 0101 0101 0101 0101 0101 0101 0101</p>
<p>a2 = 1010 1010 1010 1010 1010 1010 1010 1010</p>
<p><code>n = ((n &amp; a1) &lt;&lt; 1) | ((n &amp; a2) &gt;&gt;&gt; 1)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n = (n &gt;&gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">int</span> a1 = <span class="number">0b00000000111111110000000011111111</span>;</span><br><span class="line">        <span class="keyword">int</span> a2 = <span class="number">0b11111111000000001111111100000000</span>;</span><br><span class="line">        n = ((n &amp; a1) &lt;&lt; <span class="number">8</span>) | ((n &amp; a2) &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">        a1 = <span class="number">0b00001111000011110000111100001111</span>;</span><br><span class="line">        a2 = <span class="number">0b11110000111100001111000011110000</span>;</span><br><span class="line">        n = ((n &amp; a1) &lt;&lt; <span class="number">4</span>) | ((n &amp; a2) &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">        a1 = <span class="number">0b00110011001100110011001100110011</span>;</span><br><span class="line">        a2 = <span class="number">0b11001100110011001100110011001100</span>;</span><br><span class="line">        n = ((n &amp; a1) &lt;&lt; <span class="number">2</span>) | ((n &amp; a2) &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">        a1 = <span class="number">0b01010101010101010101010101010101</span>;</span><br><span class="line">        a2 = <span class="number">0b10101010101010101010101010101010</span>;</span><br><span class="line">        n = ((n &amp; a1) &lt;&lt; <span class="number">1</span>) | ((n &amp; a2) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 191 Number Of 1 Bits</title>
    <url>/2020/09/26/Leetcode/Leetcode%20191%20Number%20Of%201%20Bits/</url>
    <content><![CDATA[<p>Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight">Hamming weight</a>).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 00000000000000000000000000001011</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#39;1&#39; bits.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 00000000000000000000000010000000</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#39;1&#39; bit.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 11111111111111111111111111111101</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#39;1&#39; bits.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ul>
<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.</li>
<li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two's_complement">2’s complement notation</a>. Therefore, in <strong>Example 3</strong> above the input represents the signed integer <code>-3</code>.</li>
</ul>
<a id="more"></a>
<h2 id="1-位运算1"><a href="#1-位运算1" class="headerlink" title="1 位运算1"></a>1 位运算1</h2><p>对于一个数n, 如果和1做位与运算, 结果是1, 那说明这个数的二进制表示末尾位为1, 反之为0.</p>
<p>再将这个数右移1位与1做位与运算, 计算出这个数的二进制表示倒数第2位是不是1, 以此类推….</p>
<p>直到把这个数右移成0.</p>
<p>要注意, 假如n为负数的话, n&gt;&gt;1会在首位补1, 导致死循环. 所以要用无符号右移 n&gt;&gt;&gt;1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = n &amp; <span class="number">1</span>;</span><br><span class="line">            ans += tmp;</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-位运算2"><a href="#2-位运算2" class="headerlink" title="2 位运算2"></a>2 位运算2</h2><p>使用技巧, 不断更新<code>n = n &amp; (n - 1)</code>. 直到n == 0. 中间更新的次数即为1的个数.</p>
<p>这个方法看上去难理解, 但是从纸上写一写就清楚了. 每做一次<code>n = n &amp; (n - 1)</code>的操作, 1的总个数就会减1.</p>
<p>这两种位运算的方法在速度上没有区别.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 197 Rising Temperature</title>
    <url>/2020/10/25/Leetcode/Leetcode%20197%20Rising%20Temperature/</url>
    <content><![CDATA[<p>Table: <code>Weather</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| recordDate    | date    |</span><br><span class="line">| temperature   | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id is the primary key for this table.</span><br><span class="line">This table contains information about the temperature in a certain day.</span><br></pre></td></tr></table></figure>



<p>Write an SQL query to find all dates’ <code>id</code> with higher temperature compared to its previous dates (yesterday).</p>
<p>Return the result table in <strong>any order</strong>.</p>
<p>The query result format is in the following example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Weather</span><br><span class="line">+----+------------+-------------+</span><br><span class="line">| id | recordDate | Temperature |</span><br><span class="line">+----+------------+-------------+</span><br><span class="line">| 1  | 2015-01-01 | 10          |</span><br><span class="line">| 2  | 2015-01-02 | 25          |</span><br><span class="line">| 3  | 2015-01-03 | 20          |</span><br><span class="line">| 4  | 2015-01-04 | 30          |</span><br><span class="line">+----+------------+-------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">| 2  |</span><br><span class="line">| 4  |</span><br><span class="line">+----+</span><br><span class="line">In 2015-01-02, temperature was higher than the previous day (10 -&gt; 25).</span><br><span class="line">In 2015-01-04, temperature was higher than the previous day (30 -&gt; 20).</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h2><p>思路是连接两个表, 第n天的信息去和第n-1天的信息连接. 如果第n-1天的温度小于第n天的温度, 那么就返回这个值.否则不返回这个值</p>
<p>注意date类型的加减法是用<code>date_add()</code>实现的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.id <span class="keyword">FROM</span> Weather <span class="keyword">AS</span> t1, Weather <span class="keyword">AS</span> t2 <span class="keyword">WHERE</span> t1.recordDate = <span class="keyword">date_add</span>(t2.recordDate, <span class="built_in">interval</span> <span class="number">1</span> <span class="keyword">day</span>) <span class="keyword">AND</span> t1.Temperature &gt; t2.Temperature;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 196 Delete Duplicate Emails</title>
    <url>/2020/10/25/Leetcode/Leetcode%20196%20Delete%20Duplicate%20Emails/</url>
    <content><![CDATA[<p>Write a SQL query to <strong>delete</strong> all duplicate email entries in a table named <code>Person</code>, keeping only unique emails based on its <em>smallest</em> <strong>Id</strong>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">| 3  | john@example.com |</span><br><span class="line">+----+------------------+</span><br><span class="line">Id is the primary key column for this table.</span><br></pre></td></tr></table></figure>

<p>For example, after running your query, the above <code>Person</code> table should have the following rows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">+----+------------------+</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>Your output is the whole <code>Person</code> table after executing your sql. Use <code>delete</code> statement.</p>
<a id="more"></a>
<h2 id="1-子查询1-报错"><a href="#1-子查询1-报错" class="headerlink" title="1 子查询1(报错)"></a>1 子查询1(报错)</h2><p>先构造一个集合, 这个集合包含所有的重复邮箱的Id <code>SELECT p1.Id FROM Person AS p1, Person AS p2 WHERE p1.Email = p2.Email AND p1.Id &gt; p2.Id</code></p>
<p>然后再删除在这个集合中的邮箱.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># error You cant specify target table &#x27;p&#x27; for update in FROM clause</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Person <span class="keyword">WHERE</span> <span class="keyword">Id</span> <span class="keyword">IN</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> p1.Id <span class="keyword">FROM</span> Person <span class="keyword">AS</span> p1, Person <span class="keyword">AS</span> p2 <span class="keyword">WHERE</span> p1.Email = p2.Email <span class="keyword">AND</span> p1.Id &gt; p2.Id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>错误的原因是子查询和删除操作不能使用同一张表!</strong></p>
<h2 id="2-子查询2"><a href="#2-子查询2" class="headerlink" title="2 子查询2"></a>2 子查询2</h2><p>解决子查询1的做法是, 把子查询的结果重命名一下, 重命名到<code>Tmp</code>上, 这样就不会产生问题了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Person <span class="keyword">WHERE</span> <span class="keyword">Id</span> <span class="keyword">IN</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">Id</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> p1.Id <span class="keyword">FROM</span> Person <span class="keyword">AS</span> p1, Person <span class="keyword">AS</span> p2 <span class="keyword">WHERE</span> p1.Email = p2.Email <span class="keyword">AND</span> p1.Id &gt;</span><br><span class="line">                    p2.Id) <span class="keyword">AS</span> Tmp</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 199 Binary Tree Right Side View</title>
    <url>/2020/10/25/Leetcode/Leetcode%20199%20Binary%20Tree%20Right%20Side%20View/</url>
    <content><![CDATA[<p>Given a binary tree, imagine yourself standing on the <em>right</em> side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-层序遍历"><a href="#1-层序遍历" class="headerlink" title="1 层序遍历"></a>1 层序遍历</h2><p>没什么好解释的, 就直接把每层的最后一个add进结果中就ok了</p>
<p>但是空间复杂度高, 为O(n), n是二叉树中最多的一层的节点个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span>(size != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode tmp = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(size == <span class="number">1</span>)</span><br><span class="line">                    ans.add(tmp.val);</span><br><span class="line">                --size;</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-改进的中序遍历"><a href="#2-改进的中序遍历" class="headerlink" title="2 改进的中序遍历"></a>2 改进的中序遍历</h2><p>对于下面的二叉树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   3</span><br><span class="line">   &#x2F;\    \</span><br><span class="line">  4  5    6</span><br><span class="line"> &#x2F;</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p>如果按照<strong>每层最右边的节点先于左侧的节点得到遍历</strong>, 那么问题就解决了.</p>
<p>因为可以设置一个计数currDepth, 遍历的时候遍历该点的值和计数.</p>
<p><strong>如果遍历的计数大于list的长度, 就说明这一层还没有任何一个节点加到list中.</strong></p>
<p>再根据遍历的规则, 每层最右边的节点要先于左边的节点, 所以最右边的节点会被add进list中, 此时list长度增加1.</p>
<p>然后这一层左边的那些节点再次判断的时候, 就不满足currDepth大于list的长度了, 不会被计算进去.</p>
<p>这样的遍历怎么实现呢, 根节点-&gt;右子树-&gt;左子树这样的方式就可以实现了.</p>
<p>空间复杂度O(m), m 是树的深度. <strong>通常情况下</strong>比上面的BFS复杂度要低. 极端情况下不一定.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        dfs(ans, root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; ans, TreeNode root, <span class="keyword">int</span> currDepth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(currDepth &gt; ans.size())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(ans, root.right, currDepth + <span class="number">1</span>);</span><br><span class="line">        dfs(ans, root.left, currDepth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 198 House Robber</title>
    <url>/2020/09/26/Leetcode/Leetcode%20198%20House%20Robber/</url>
    <content><![CDATA[<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">             Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).</span><br><span class="line">             Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
<a id="more"></a>
<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1 动态规划"></a>1 动态规划</h2><p>首先规定, dp[i] 代表 从i到n-1的子数组中, 可以抢劫(rob)的最大财产.</p>
<p>显然有dp[n-1] = nums[n-1], dp[n-2] = max(nums[n-2], nums[n-1])</p>
<p>下面根据dp[i+1]和dp[i+2]推导出dp[i]的表达式</p>
<p>对于从i到n-1的子数组中, 有2种情况, </p>
<ul>
<li>第i家不抢, 那么第i+1及之后的这些家可抢可不抢. 所以从第i+1家到第n-1家抢的最大财产就是dp[i+1]</li>
<li>抢第i家, 那么第i+1家一定不能抢(否则就进局子了), 而第i+2家及之后的这些可以自行决定抢不抢. 所以从第i+2家到第n-1家抢的最大财产就是dp[i+2], 加上抢的第i家的财产就是nums[i] + dp[i+2]</li>
</ul>
<p>所以 <code>dp[i] = max(dp[i+1], nums[i] + dp[i+2])</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[n-<span class="number">1</span>] = nums[n-<span class="number">1</span>];</span><br><span class="line">        dp[n-<span class="number">2</span>] = Math.max(nums[n-<span class="number">2</span>], nums[n-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">3</span>; i &gt;= <span class="number">0</span> ; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i+<span class="number">1</span>], nums[i] + dp[i+<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划-优化空间"><a href="#2-动态规划-优化空间" class="headerlink" title="2 动态规划(优化空间)"></a>2 动态规划(优化空间)</h2><p>经过上面的分析, 计算dp[i]只需要dp[i+1]和dp[i+2], 发现根本不需要一整个数组来存储. 只需要3个变量储存当前i的值, i+1的值, i+2的值即可. </p>
<p>多了一步的判断条件<code>if(n == 2)  return Math.max(nums[n-2], nums[n-1]);</code>是防止nums只有2个元素然后没有经过for循环, 返回了未计算的<code>dp_i</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[n-<span class="number">2</span>], nums[n-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> dp_iplus1 = Math.max(nums[n-<span class="number">2</span>], nums[n-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> dp_iplus2 = nums[n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> dp_i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">3</span>; i &gt;= <span class="number">0</span> ; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp_i = Math.max(dp_iplus1, nums[i] + dp_iplus2);</span><br><span class="line">            dp_iplus2 = dp_iplus1;</span><br><span class="line">            dp_iplus1 = dp_i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 2 Add Two Numbers</title>
    <url>/2020/08/14/Leetcode/Leetcode%202%20Add%20Two%20Numbers/</url>
    <content><![CDATA[<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="常规做法"><a href="#常规做法" class="headerlink" title="常规做法"></a>常规做法</h2><p>设置变量isOverflow判断是否要进位</p>
<p>先计算两个list的个位数和, <code>x = l1-&gt;val, y = l2-&gt;val</code>加起来, <code>tmp = x + y</code></p>
<ul>
<li><p>若tmp &gt; 9 说明要进位, isOverflow设为true, 并new一个新的ListNode(tmp)</p>
</li>
<li><p>否则, 直接new新的ListNode(tmp)</p>
</li>
</ul>
<p>最后, 更新x, y的值, 更新ListNode(tmp)将要插入的位置</p>
<p>在计算十位数的和, <code>tmp = x + y + ?</code> 其中若前面产生进位, <code>?</code>为1, 否则为0</p>
<p>以此类推直至两个list遍历到nullptr,并且isOverflow为false</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* i = l1;</span><br><span class="line">        ListNode* j = l2;</span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> ListNode(<span class="number">-1</span>); <span class="comment">//let -1 indicate the head node</span></span><br><span class="line">        ListNode* tail = ans;</span><br><span class="line">        <span class="keyword">bool</span> isOverflow = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(i != <span class="literal">nullptr</span> || j != <span class="literal">nullptr</span> || isOverflow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (i == <span class="literal">nullptr</span>) ? <span class="number">0</span> : i-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> y = (j == <span class="literal">nullptr</span>) ? <span class="number">0</span> : j-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> tmp = x + y + (isOverflow ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp -= <span class="number">10</span>;</span><br><span class="line">                isOverflow = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                isOverflow = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> ListNode(tmp);</span><br><span class="line">            tail = tail -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="literal">nullptr</span>)</span><br><span class="line">                i = i-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(j != <span class="literal">nullptr</span>)</span><br><span class="line">                j = j-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans -&gt; next != <span class="literal">nullptr</span>)</span><br><span class="line">            ans = ans-&gt;next; <span class="comment">//delete the head node</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 20 Valid Parentheses</title>
    <url>/2020/09/20/Leetcode/Leetcode%2020%20Valid%20Parentheses/</url>
    <content><![CDATA[<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> consists of parentheses only <code>&#39;()[]&#123;&#125;&#39;</code>.</li>
</ul>
<a id="more"></a>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>实际上就是用stack模拟括号. 思路简单, 但是细节多.</p>
<p>首先要判断是左括号还是右括号. 左括号直接push到栈里面, 右括号要先<strong>检查栈是不是空的, 是空的直接返回false</strong>. 不是空的检查栈顶元素和右括号是否匹配, 如果不匹配直接返回false. 匹配就pop.</p>
<p>遍历完string中每一个元素后, 要<strong>检查栈是否为空, 如果非空返回false, 空的返回true.</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> a : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isLeftBracket(a))</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.empty())</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">                <span class="keyword">bool</span> doesMatch = isMatched(stk.top(), a);</span><br><span class="line">                <span class="keyword">if</span>(doesMatch)</span><br><span class="line">                    stk.pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stk.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeftBracket</span><span class="params">(<span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="string">&#x27;(&#x27;</span> || a == <span class="string">&#x27;[&#x27;</span> || a == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatched</span><span class="params">(<span class="keyword">char</span> left, <span class="keyword">char</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((left == <span class="string">&#x27;(&#x27;</span> &amp;&amp; right == <span class="string">&#x27;)&#x27;</span>) ||</span><br><span class="line">           (left == <span class="string">&#x27;[&#x27;</span> &amp;&amp; right == <span class="string">&#x27;]&#x27;</span>) ||</span><br><span class="line">           (left == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; right == <span class="string">&#x27;&#125;&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 202 Happy Number</title>
    <url>/2020/10/15/Leetcode/Leetcode%20202%20Happy%20Number/</url>
    <content><![CDATA[<p>Write an algorithm to determine if a number <code>n</code> is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1. Those numbers for which this process <strong>ends in 1</strong> are happy numbers.</p>
<p>Return True if <code>n</code> is a happy number, and False if not.</p>
<p><strong>Example:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-hashset"><a href="#1-hashset" class="headerlink" title="1 hashset"></a>1 hashset</h2><p>这题的算法很简单, 按照要求一次次的模拟即可.</p>
<p>重点是判断是不是最后以1结束. 不是以1结束肯定是个链式循环. 要判断有没有这样的循环, 可以用快慢指针, 也可以利用一个集合存储遍历过的元素, 如果再次计算出了遍历过的元素, 那么肯定在循环中. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getDigitSquareSum(n);</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(!set.contains(n));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDigitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = n % <span class="number">10</span>;</span><br><span class="line">            sum += tmp * tmp;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="2 快慢指针"></a>2 快慢指针</h2><p>写完快慢指针竟然发现代码比用set还要少. 一开始还以为用快慢指针肯定复杂. </p>
<p>看来以后判断是否有环这种问题还是快慢指针好用.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = n;</span><br><span class="line">        <span class="keyword">int</span> slow = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = getDigitSquareSum(getDigitSquareSum(fast));</span><br><span class="line">            slow = getDigitSquareSum(slow);</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="number">1</span> || slow == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDigitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = n % <span class="number">10</span>;</span><br><span class="line">            sum += tmp * tmp;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 200 Number Of Islands</title>
    <url>/2020/10/19/Leetcode/Leetcode%20200%20Number%20Of%20Islands/</url>
    <content><![CDATA[<p>Given an <code>m x n</code> 2d <code>grid</code> map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>
<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
<a id="more"></a>
<h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><p>肯定是挨个遍历二维数组的元素值了.</p>
<p>对于每一个遍历的位置(i, j), 如果该位置是1, 那么说明找到了一个岛屿, cnt自加, 并且把和这个1相连的所有1都置为2. 表示这个岛屿已经遍历过了, 接下来不应该再被计算一次. 用深度优先遍历所有与这个1相连的1即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                    traverseIsland(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverseIsland</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLocationValid(grid, i, j))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            traverseIsland(grid, i - <span class="number">1</span>, j);</span><br><span class="line">            traverseIsland(grid, i + <span class="number">1</span>, j);</span><br><span class="line">            traverseIsland(grid, i, j - <span class="number">1</span>);</span><br><span class="line">            traverseIsland(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLocationValid</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> i &gt; -<span class="number">1</span> &amp;&amp; i &lt; m &amp;&amp; j &gt; -<span class="number">1</span> &amp;&amp; j &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 203 Remove Linked List Elements</title>
    <url>/2020/10/27/Leetcode/Leetcode%20203%20Remove%20Linked%20List%20Elements/</url>
    <content><![CDATA[<p>Remove all elements from a linked list of integers that have value <strong><em>val\</em></strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>直接做即可, 注意添上头节点更简单. 还要注意两个val相邻的情况. 如果进行了删除操作<code>i.next = i.next.next</code>,就不要<code>i = i.next</code>了. 否则会错</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode i = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(i != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i.next.val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                i.next = i.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i = i.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 205 Isomorphic Strings</title>
    <url>/2020/10/24/Leetcode/Leetcode%20205%20Isomorphic%20Strings/</url>
    <content><![CDATA[<p>Given two strings <strong><em>s\</em></strong> and <strong><em>t\</em></strong>, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in <strong><em>s\</em></strong> can be replaced to get <strong><em>t\</em></strong>.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume both <strong><em>s\</em></strong> and <strong><em>t\</em></strong> have the same length.</p>
<a id="more"></a>
<h2 id="1-hashmap"><a href="#1-hashmap" class="headerlink" title="1 hashmap"></a>1 hashmap</h2><p>考虑所有的字符从s到t的映射.</p>
<p>如果对于某个i, s[i]映射到t[i], 并且这个映射在map中没有, 就把这个映射<code>s[i]-&gt;t[i]</code>加入到map中</p>
<p>如果键s[i]在map中存在, 并且该键对应的值<strong>不等于</strong>t[i], 就说明做映射s肯定变换不到t上去. 所以返回false. 例如(<code>aa -&gt; ab</code>, 没法构造一个映射既有<code>a-&gt;a</code>又有<code>a-&gt;b</code>)</p>
<p>如果键s[i]在map中存在, 并且该键对应的值<strong>等于</strong>t[i], 跳过, 判断i+1的映射.</p>
<p>同时, 要双向判断映射是否存在. 例如<code>aa 和 ab</code> 如果只判断<code>ab</code>是否能映射到<code>aa</code>是成立的, 但是<code>aa</code>却没办法映射到<code>ab</code>. 所以要双向判断, 只有在都能互相映射的时候才返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isIsomorphic0(s, t) &amp;&amp; isIsomorphic0(t, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic0</span><span class="params">(String s, String t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch1 = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> ch2 = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(ch1))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(ch1) != ch2)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                map.put(ch1, ch2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用字符本身作为hash"><a href="#2-使用字符本身作为hash" class="headerlink" title="2 使用字符本身作为hash"></a>2 使用字符本身作为hash</h2><p>即对于ch1 = s[i]和ch2 = t[i], 获取ch1在s中第一次出现的位置, 和ch2在t中第一次出现的位置, 如果两者不相等的话, 就返回false. </p>
<p><strong>这个方法和上面的方法相比, 不占用额外空间, 但是时间复杂度会高. 上面的是O(n), 这一个最坏情况下是O(n^2)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.indexOf(s.charAt(i)) != t.indexOf(t.charAt(i)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 204 Count Primes</title>
    <url>/2020/10/16/Leetcode/Leetcode%20204%20Count%20Primes/</url>
    <content><![CDATA[<p>Count the number of prime numbers less than a non-negative number, <code>n</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 5 * 106</code></li>
</ul>
<a id="more"></a>
<h2 id="1-暴力-超时"><a href="#1-暴力-超时" class="headerlink" title="1 暴力(超时)"></a>1 暴力(超时)</h2><p>对于1到n-1这些数, 每一个数都判断一次. 时间复杂度O(n^1.5)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime(i))</span><br><span class="line">                ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(n); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-打表"><a href="#2-打表" class="headerlink" title="2 打表"></a>2 打表</h2><p><strong>埃拉托斯特尼筛法</strong>. </p>
<p>首先对于质数2, 把所有的2的倍数(4,6,8…)标记为非质数, 然后再把所有的3的倍数(6,9,12…)标记为非质数, 以此类推….</p>
<p>所有的没有被标记的数即为质数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] isNotPrime = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        isNotPrime[<span class="number">0</span>] = isNotPrime[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isNotPrime[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt; n; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    isNotPrime[i * j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 206 Reverse Linked List</title>
    <url>/2020/09/30/Leetcode/Leetcode%20206%20Reverse%20Linked%20List/</url>
    <content><![CDATA[<p>Reverse a singly linked list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<a id="more"></a>
<h2 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1 迭代"></a>1 迭代</h2><p>对于链表1,2,3,4,5</p>
<p>创建一个新的空链表dummyHead,</p>
<p>遍历到1的时候, 把1加入到空链表头部, 空链表为head -&gt;1</p>
<p>遍历到2的时候, 把2加入到链表头部, 变为head -&gt; 2 -&gt; 1</p>
<p>以此类推….</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">for</span>(ListNode i = head; i != <span class="keyword">null</span>; i = i.next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tail = dummyHead.next;</span><br><span class="line">            dummyHead.next = <span class="keyword">new</span> ListNode(i.val, tail);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2 递归"></a>2 递归</h2><p>参考于 <a href="https://blog.csdn.net/SoulOH/article/details/81062223">https://blog.csdn.net/SoulOH/article/details/81062223</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode p = reverseList(head.next);</span><br><span class="line">            ListNode tail = head.next;</span><br><span class="line">            tail.next = head;</span><br><span class="line">            head.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-原地迭代reverse"><a href="#3-原地迭代reverse" class="headerlink" title="3 原地迭代reverse"></a>3 原地迭代reverse</h2><p>同样参考于 <a href="https://blog.csdn.net/SoulOH/article/details/81062223">https://blog.csdn.net/SoulOH/article/details/81062223</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head.next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 21 Merge Two Sorted Lists</title>
    <url>/2020/09/24/Leetcode/Leetcode%2021%20Merge%20Two%20Sorted%20Lists/</url>
    <content><![CDATA[<p>Merge two sorted linked lists and return it as a new <strong>sorted</strong> list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>和归并排序方法一样, 2个链表就创立2个指针. 比较哪个指针指向的元素小再插入, 同时该指针要向后移一位.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* listHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode* tail = listHead;</span><br><span class="line">        ListNode* p1 = l1;</span><br><span class="line">        ListNode* p2 = l2;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="literal">nullptr</span> || p2!= <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> ListNode(p2-&gt;val);</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> ListNode(p1-&gt;val);</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p1-&gt;val &gt; p2-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    tail-&gt;next = <span class="keyword">new</span> ListNode(p2-&gt;val);</span><br><span class="line">                    p2 = p2-&gt;next;</span><br><span class="line">                    tail = tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tail-&gt;next = <span class="keyword">new</span> ListNode(p1-&gt;val);</span><br><span class="line">                    p1 = p1-&gt;next;</span><br><span class="line">                    tail = tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 213 House Robber II</title>
    <url>/2020/10/25/Leetcode/Leetcode%20213%20House%20Robber%20II/</url>
    <content><![CDATA[<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money &#x3D; 2) and then rob house 3 (money &#x3D; 2), because they are adjacent houses.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>和leetcode 198 一样, 只是多了个条件, 第一家和最后一家不能同时抢.</p>
<p>所以分别计算nums从0到n-1的子数组最大抢劫数量, 和从1到n的子数组最大抢劫数量, 两者取最大值即可</p>
<p>同leetcode 198, 这里的第i个状态只和第i-1个状态和第i-2个状态有关, 所以不需要一个数组来储存. 单独设两个变量即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] dp0 = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - <span class="number">1</span>];</span><br><span class="line">        dp0[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp0[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp0[i] = Math.max(dp0[i-<span class="number">1</span>], dp0[i-<span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp1[<span class="number">0</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp1[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp1[i] = Math.max(dp1[i-<span class="number">1</span>], dp1[i-<span class="number">2</span>] + nums[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp0[nums.length - <span class="number">2</span>], dp1[nums.length - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 209 Minimum Size Subarray Sum</title>
    <url>/2020/08/11/Leetcode/Leetcode%20209%20Minimum%20Size%20Subarray%20Sum/</url>
    <content><![CDATA[<p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p>
<p><strong>Example:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: the subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>If you have figured out the <em>O</em>(<em>n</em>) solution, try coding another solution of which the time complexity is <em>O</em>(<em>n</em> log <em>n</em>). </p>
<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>两个指针i,j记录子数组开始和结束.</p>
<ul>
<li>若子数组范围[i,j]的和sumTmp小于s, 那么j右移</li>
<li>若子数组范围[i,j]的和sumTmp大于等于s, 记录此刻子数组的长度 j - i + 1, i右移</li>
</ul>
<p>返回所有记录的长度中的最小值. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sumTmp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> minLenGlobal = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sumTmp &lt; s)</span><br><span class="line">            &#123;</span><br><span class="line">                ++right;</span><br><span class="line">                <span class="keyword">if</span>(right == nums.<span class="built_in">size</span>())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                sumTmp += nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmpLen = right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(tmpLen &lt; minLenGlobal)</span><br><span class="line">                    minLenGlobal = tmpLen;</span><br><span class="line">                sumTmp -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLenGlobal == INT_MAX ? <span class="number">0</span> : minLenGlobal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 215 Kth Largest Element In An Array</title>
    <url>/2020/10/30/Leetcode/Leetcode%20215%20Kth%20Largest%20Element%20In%20An%20Array/</url>
    <content><![CDATA[<p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k &#x3D; 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k &#x3D; 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<a id="more"></a>
<h2 id="1-优先队列"><a href="#1-优先队列" class="headerlink" title="1 优先队列"></a>1 优先队列</h2><p>维护一个k个元素组成的优先队列(小根堆), 如果遍历的元素i比优先队列里最小的元素大, 就poll掉最小的元素, 再把i加入到队列中.</p>
<p>最后, 优先队列中最小的元素即为第k大的元素.</p>
<p>复杂度 O(n * logk)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = pq.peek();</span><br><span class="line">                <span class="keyword">if</span>(i &gt; tmp)</span><br><span class="line">                &#123;</span><br><span class="line">                    pq.poll();</span><br><span class="line">                    pq.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-快速排序的思想"><a href="#2-快速排序的思想" class="headerlink" title="2 快速排序的思想"></a>2 快速排序的思想</h2><p>利用快速排序的思想, 随机选取一个哨兵sentinel = nums[begin]</p>
<p>然后将其partition两部分, 比sentinel小的在数组左边, 比sentinel大的在数组右边.</p>
<p>这样, 我们就能求出sentinel在数组中的排名是第<code>end - j + 1</code>大的元素了. j为sentinel经过partition后最终的位置</p>
<p>如果k == sentinel_rank, 那么直接返回sentinel即可.</p>
<p>如果k &gt; sentinel_rank, 那么说明第k大的数在sentinel左边的子数组中, 从nums[begin], 到nums[j - 1]中寻找第k - j大的元素即可</p>
<p>如果k &lt; sentinel_rank, 那么说明第k大的数在sentinel右边的子数组中, 从nums[j+1]到nums[end]中寻找第k大的数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kth(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sentinel = nums[begin];</span><br><span class="line">        <span class="keyword">int</span> i = begin;</span><br><span class="line">        <span class="keyword">int</span> j = end;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; end &amp;&amp; nums[i] &lt;= sentinel)</span><br><span class="line">                ++i;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; begin &amp;&amp; nums[j] &gt;= sentinel)</span><br><span class="line">                --j;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//swap nums[begin] and nums[j]</span></span><br><span class="line">                <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                nums[j] = nums[begin];</span><br><span class="line">                nums[begin] = tmp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//swap nums[i] and nums[j]</span></span><br><span class="line">            <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sentinel_rank = end - j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sentinel_rank == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sentinel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sentinel_rank &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> kth(nums, begin, j - <span class="number">1</span>, k - sentinel_rank);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> kth(nums, j + <span class="number">1</span>, end, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 216 Combination Sum III</title>
    <url>/2020/08/11/Leetcode/Leetcode%20216%20Combination%20Sum%20III/</url>
    <content><![CDATA[<p>Find all possible combinations of <strong><em>k</em></strong> numbers that add up to a number <strong><em>n</em></strong>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">Output: [[1,2,4]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">Output: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><p>beginNumber从1到9依次判断</p>
<ul>
<li>若含有beginNumber, 则需寻找所有的长度为k-1, 和为n-beginNumber的vector, 再从所有满足条件的vector上push_back(gebinNumber).</li>
<li>若不含有beginNumber, 则需要寻找所有长度为k, 和为n的vector</li>
</ul>
<p>两个vector取并集即为所得</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> combinationSum3(<span class="number">1</span>,k,n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> beginNumber, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;()&#125;);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span> || beginNumber &gt; <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; containsBeginNumber = combinationSum3(beginNumber + <span class="number">1</span>, k - <span class="number">1</span>, n - beginNumber);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : containsBeginNumber)</span><br><span class="line">        &#123;</span><br><span class="line">            i.push_back(beginNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; notContainsBeginNumber = combinationSum3(beginNumber + <span class="number">1</span>, k, n);</span><br><span class="line">        containsBeginNumber.insert(containsBeginNumber.<span class="built_in">begin</span>(),notContainsBeginNumber.<span class="built_in">begin</span>(), notContainsBeginNumber.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> containsBeginNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dfs2"><a href="#dfs2" class="headerlink" title="dfs2"></a>dfs2</h2><p>贴一个我觉得更清晰的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> sum, <span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; sum == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.push_back(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (idx &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cur.push_back(idx);</span><br><span class="line">    dfs(k - <span class="number">1</span>, sum - idx, idx + <span class="number">1</span>, cur, ans); <span class="comment">// 选择1</span></span><br><span class="line">    cur.pop_back();</span><br><span class="line"></span><br><span class="line">    dfs(k, sum, idx + <span class="number">1</span>, cur, ans); <span class="comment">// 不选择1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">    dfs(k, n, <span class="number">1</span>, cur, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：<span class="number">62E64</span>ArP6T</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/combination-sum-iii/solution/2chong-di-gui-hui-su-de-bi-jiao-by-62e64arp6t/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 219 Contains Duplicate II</title>
    <url>/2020/07/23/Leetcode/Leetcode%20219%20Contains%20Duplicate%20II/</url>
    <content><![CDATA[<p>Given an array of integers and an integer <em>k</em>, find out whether there are two distinct indices <em>i</em> and <em>j</em> in the array such that <strong>nums[i] = nums[j]</strong> and the <strong>absolute</strong> difference between <em>i</em> and <em>j</em> is at most <em>k</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-hash-map1"><a href="#1-hash-map1" class="headerlink" title="1 hash map1"></a>1 hash map1</h2><p>使用一个从int映射到vector&lt;int&gt;的map，i从0遍历到n-1，</p>
<blockquote>
<p> 如果在map中出现与nums[i]相同的键，则当前的下标和vector中最后一个下标对比，若两者之差小于等于k，则返回true，否则把最新的下标i加入到vector中</p>
</blockquote>
<blockquote>
<p>如果在map中没有出现与nums[i]相同的键，则直接在map中insert {nums[i], vector{i}}</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = mp.<span class="built_in">find</span>(nums[i]);</span><br><span class="line">            <span class="keyword">bool</span> isFound_nums_i = (it != mp.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(isFound_nums_i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> last_index = it -&gt; second.back();</span><br><span class="line">                <span class="keyword">if</span>(i - last_index &lt;= k) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    it -&gt; second.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mp.insert(&#123;nums[i], <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-hash-map2"><a href="#2-hash-map2" class="headerlink" title="2 hash map2"></a>2 hash map2</h2><p>发现方法1并不需要一个vector作为值, 因为在迭代过程中只需要比较最后一个出现的index和当前的i的大小关系. 所以设&lt;key, value&gt;为&lt;int, int&gt;，如果出现了相同的值，并且i和前一个index的差大于k，则直接把前一个index替换为i即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(nums[i]);</span><br><span class="line">            <span class="keyword">bool</span> isFound_nums_i = (it != mp.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(isFound_nums_i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> last_index = it -&gt; second;</span><br><span class="line">                <span class="keyword">if</span>(i - last_index &lt;= k) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    it -&gt; second = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mp.insert(&#123;nums[i], i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 217 Contains Duplicate</title>
    <url>/2020/07/23/Leetcode/Leetcode%20217%20Contains%20Duplicate/</url>
    <content><![CDATA[<p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="hash-set"><a href="#hash-set" class="headerlink" title="hash set"></a>hash set</h2><p>i从1遍历到nums.size() - 1, 使用一个hash set 储存已经出现过的元素, 如果再次出现返回true.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> isFound = (st.<span class="built_in">find</span>(nums[i]) != st.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(isFound) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                st.insert(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 221 Maximal Square</title>
    <url>/2020/10/27/Leetcode/Leetcode%20221%20Maximal%20Square/</url>
    <content><![CDATA[<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>第一次做这种二维数组最大矩阵的题还真没什么思路. 甚至连暴力可能都写不出来. 看了网上的解析之后才有思路. 希望以后这样的题会做吧.</p>
<p><code>dp[i][j]</code>表示以坐标(i, j)为右下角元素的最大正方形.</p>
<p>那么显然如果<code>matrix[i][j] = &#39;0&#39;</code>, 那么就有<code>dp[i][j] = 0</code>. </p>
<p>如果<code>matrix[i][j] = &#39;1&#39;</code>, 但是<code>matrix[i-1][j-1]</code>超出数组边界或者<code>matrix[i-1][j-1] = &#39;0&#39;</code> 就有<code>dp[i][j] = 1</code></p>
<p>如果<code>matrix[i][j] = &#39;1&#39;</code> 并且<code>matrix[i-1][j-1]</code>没有数组边界, 我们假设<code>dp[i-1][j-1] = m</code>, 即在(i,j)的左上方有一个边长为m的正方形. </p>
<p>为了以(i, j)也可以组成正方形, 左上角有一个m的正方形还不够, 还要左侧的矩形A域上方的矩形B也是1. 如图所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m m m m m B</span><br><span class="line">m m m m m B</span><br><span class="line">m m m m m B</span><br><span class="line">m m m m m B</span><br><span class="line">m m m m m B</span><br><span class="line">A A A A A 1  最后一个1的坐标为(i,j)</span><br></pre></td></tr></table></figure>

<p>矩行A和矩行B只要有0的中断就不行. 只要中断, 正方形的size到这里就截止了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m m m m m 1</span><br><span class="line">m m m m m 0</span><br><span class="line">m m m m m 1</span><br><span class="line">m m m m m 1</span><br><span class="line">m m m m m 1</span><br><span class="line">1 1 0 1 1 1</span><br></pre></td></tr></table></figure>

<p>例如, 左侧的矩阵A在距离(i, j)为2的地方截止了. 即使上方的矩阵截止的地方为3, 左上方的正方形边长为5也没有用.</p>
<p>只取最小值2. 再加上本身的(i,j), 所以<code>dp[i][j] = 3</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(n1 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1][n2];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> tmp = matrix[i][j];</span><br><span class="line">                <span class="keyword">if</span>(tmp == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!isValid(matrix, i-<span class="number">1</span>, j-<span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> m = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">int</span> leftBarSize = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= m; ++s)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(matrix[i][j-s] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                                ++leftBarSize;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span> aboveBarSize = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= m; ++s)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(matrix[i-s][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                                ++aboveBarSize;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span> size = Math.min(aboveBarSize, leftBarSize);</span><br><span class="line">                        dp[i][j] = size + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                maxSize = Math.max(maxSize, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSize * maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> i &gt; -<span class="number">1</span> &amp;&amp; j &gt; -<span class="number">1</span> &amp;&amp; i &lt; n1 &amp;&amp; j &lt; n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 22 Generate Parentheses</title>
    <url>/2020/09/20/Leetcode/Leetcode%2022%20Generate%20Parentheses/</url>
    <content><![CDATA[<p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given <em>n</em> = 3, a solution set is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-回溯-剪枝"><a href="#1-回溯-剪枝" class="headerlink" title="1 回溯 + 剪枝"></a>1 回溯 + 剪枝</h2><p>考虑到一共有n个左括号, n个右括号. string长度为2n</p>
<p>所以每个位置都可以有放置”(“和”)”两种选择. <strong>然后要注意传递两个参数(左括号剩余数量, 右括号剩余数量). 如果左括号用完了就只能放置右括号了. 两个括号都用完了就把字符串current加入到结果ans中</strong></p>
<p><strong>对于剪枝, 如果发现放置了k个括号的字符串中, 右括号多于左括号, 那么就剪枝掉它. 因为无论第k个括号之后的括号怎么放, 都不是合法的括号字符串!</strong> 例如, n = 3, 前三个括号为”())”, 无论剩下的的括号(2个”(“, 1个’’)’’)怎么排序都不对了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        generateParenthesis(<span class="string">&quot;&quot;</span>, ans, n, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateParenthesis</span><span class="params">(<span class="built_in">string</span> current, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="keyword">int</span> leftParenthesis, <span class="keyword">int</span> rightParenthesis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftParenthesis + rightParenthesis == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!precheck(current))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftParenthesis &gt; <span class="number">0</span>)</span><br><span class="line">            generateParenthesis(current + <span class="string">&quot;(&quot;</span>, ans, leftParenthesis - <span class="number">1</span>, rightParenthesis);</span><br><span class="line">        <span class="keyword">if</span>(rightParenthesis &gt; <span class="number">0</span>)</span><br><span class="line">            generateParenthesis(current + <span class="string">&quot;)&quot;</span>, ans, leftParenthesis, rightParenthesis - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">precheck</span><span class="params">(<span class="built_in">string</span> current)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (count(current.<span class="built_in">begin</span>(), current.<span class="built_in">end</span>(), <span class="string">&#x27;(&#x27;</span>) &lt; count(current.<span class="built_in">begin</span>(), current.<span class="built_in">end</span>(), <span class="string">&#x27;)&#x27;</span>)) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-回溯-剪枝-改进"><a href="#2-回溯-剪枝-改进" class="headerlink" title="2 回溯 + 剪枝 (改进)"></a>2 回溯 + 剪枝 (改进)</h2><p>观察上面的剪枝过程, 每一次都要计算current字符串中的左括号数量和右括号数量. <strong>事实上这两个根本不用计算, 直接从参数leftParenthesis和rightParenthesis中获得即可!</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        generateParenthesis(<span class="string">&quot;&quot;</span>, ans, n, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateParenthesis</span><span class="params">(<span class="built_in">string</span> current, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="keyword">int</span> leftParenthesis, <span class="keyword">int</span> rightParenthesis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftParenthesis + rightParenthesis == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftParenthesis &gt; rightParenthesis)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftParenthesis &gt; <span class="number">0</span>)</span><br><span class="line">            generateParenthesis(current + <span class="string">&quot;(&quot;</span>, ans, leftParenthesis - <span class="number">1</span>, rightParenthesis);</span><br><span class="line">        <span class="keyword">if</span>(rightParenthesis &gt; <span class="number">0</span>)</span><br><span class="line">            generateParenthesis(current + <span class="string">&quot;)&quot;</span>, ans, leftParenthesis, rightParenthesis - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-直接生成"><a href="#3-直接生成" class="headerlink" title="3 直接生成"></a>3 直接生成</h2><p>这个答案摘自leetcode官网(<a href="https://leetcode.com/problems/generate-parentheses/solution/">https://leetcode.com/problems/generate-parentheses/solution/</a>). </p>
<p>它没有用回溯法一个元素一个元素的构造, 而是观察解的结构. </p>
<p>发现任意一个解都能用 <code>&#39;(&#39; + left + &#39;)&#39; + right</code>来表示. 其中, left是含有<code>c</code>组括号组成的所有合法字符串, right是含有<code>n - c - 1</code>组括号组成的所有合法字符串. c 属于 [0, n - 1]. </p>
<p>下面举例说明, n = 5,</p>
<blockquote>
<p><code>()()((()))</code>可以表示为 left = “”, right = <code>()((()))</code> , c = 0</p>
<p><code>((()()()))</code>可以表示为 left = <code>(()()())</code> , right = “”, c = 4</p>
<p><code>(()(()))()</code>可以表示为 left = <code>()(())</code>, right = <code>()</code> ,   c = 3</p>
</blockquote>
<p>所以只需要遍历c, 即可得到所有的解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c)</span><br><span class="line">                <span class="keyword">for</span> (String left: generateParenthesis(c))</span><br><span class="line">                    <span class="keyword">for</span> (String right: generateParenthesis(n-<span class="number">1</span>-c))</span><br><span class="line">                        ans.add(<span class="string">&quot;(&quot;</span> + left + <span class="string">&quot;)&quot;</span> + right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 225 Implement Stack Using Queues</title>
    <url>/2020/10/29/Leetcode/Leetcode%20225%20Implement%20Stack%20Using%20Queues/</url>
    <content><![CDATA[<p>Implement a last in first out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal queue (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyStack</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>
<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>
<li><code>int top()</code> Returns the element on the top of the stack.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a queue, which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue), as long as you use only a queue’s standard operations.</li>
</ul>
<p><strong>Follow-up:</strong> Can you implement the stack such that each operation is <strong><a href="https://en.wikipedia.org/wiki/Amortized_analysis">amortized</a></strong> <code>O(1)</code> time complexity? In other words, performing <code>n</code> operations will take overall <code>O(n)</code> time even if one of those operations may take longer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyStack myStack &#x3D; new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); &#x2F;&#x2F; return 2</span><br><span class="line">myStack.pop(); &#x2F;&#x2F; return 2</span><br><span class="line">myStack.empty(); &#x2F;&#x2F; return False</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>empty</code>.</li>
<li>All the calls to <code>pop</code> and <code>top</code> are valid.</li>
</ul>
<a id="more"></a>
<h2 id="1-2个队列-push-O-1-pop-O-n"><a href="#1-2个队列-push-O-1-pop-O-n" class="headerlink" title="1 2个队列. push O(1), pop O(n)"></a>1 2个队列. push O(1), pop O(n)</h2><p>2个队列互相交替, 插入的时候维持原有顺序, pop的时候把含有element的队列的前n-1个元素转移到另外一个队列, 第n个元素pop出来.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; a;</span><br><span class="line">    Queue&lt;Integer&gt; b;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        b = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; full;</span><br><span class="line">        Queue&lt;Integer&gt; empty;</span><br><span class="line">        <span class="keyword">if</span>(!a.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            full = a;</span><br><span class="line">            empty = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            full = b;</span><br><span class="line">            empty = a;</span><br><span class="line">        &#125;</span><br><span class="line">        full.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; full;</span><br><span class="line">        Queue&lt;Integer&gt; empty;</span><br><span class="line">        <span class="keyword">if</span>(!a.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            full = a;</span><br><span class="line">            empty = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            full = b;</span><br><span class="line">            empty = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(full.size() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = full.poll();</span><br><span class="line">            empty.offer(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> full.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; full;</span><br><span class="line">        Queue&lt;Integer&gt; empty;</span><br><span class="line">        <span class="keyword">if</span>(!a.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            full = a;</span><br><span class="line">            empty = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            full = b;</span><br><span class="line">            empty = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(full.size() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = full.poll();</span><br><span class="line">            empty.offer(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = full.peek();</span><br><span class="line">        empty.offer(full.poll());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.isEmpty() &amp;&amp; b.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2个队列-push-O-n-pop-O-1"><a href="#2-2个队列-push-O-n-pop-O-1" class="headerlink" title="2 2个队列. push O(n), pop O(1)"></a>2 2个队列. push O(n), pop O(1)</h2><p>插入的时候就把顺序导致过来, 通过两个队列的交替始终保持最新插入的元素在队列第一个位置. pop和top只需要O(1)的操作</p>
<p>感觉这一种方法比第一种好一些.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; a;</span><br><span class="line">    Queue&lt;Integer&gt; b;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        b = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; full;</span><br><span class="line">        Queue&lt;Integer&gt; empty;</span><br><span class="line">        <span class="keyword">if</span>(!a.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            full = a;</span><br><span class="line">            empty = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            full = b;</span><br><span class="line">            empty = a;</span><br><span class="line">        &#125;</span><br><span class="line">        empty.offer(x);</span><br><span class="line">        <span class="keyword">while</span>(!full.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            empty.offer(full.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; full;</span><br><span class="line">        Queue&lt;Integer&gt; empty;</span><br><span class="line">        <span class="keyword">if</span>(!a.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            full = a;</span><br><span class="line">            empty = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            full = b;</span><br><span class="line">            empty = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> full.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; full;</span><br><span class="line">        Queue&lt;Integer&gt; empty;</span><br><span class="line">        <span class="keyword">if</span>(!a.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            full = a;</span><br><span class="line">            empty = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            full = b;</span><br><span class="line">            empty = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> full.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.isEmpty() &amp;&amp; b.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="3-1个队列"><a href="#3-1个队列" class="headerlink" title="3 1个队列"></a>3 1个队列</h2><p>这种方法真是妙啊.</p>
<p>还是插入的时候就要颠倒次序.</p>
<p>假如已经插入了1,2,3,4.</p>
<p>这时队列为 4,3,2,1.</p>
<p>当插入5的时候, 先记录队列的大小size.</p>
<p>然后插入5, 队列变为4,3,2,1,5</p>
<p><strong>然后队列首元素出队列再进队列size次</strong></p>
<p>即4,3,2,1,5 -&gt; 3,2,1,5,4 -&gt; 2,1,5,4,3 -&gt; 1,5,4,3,2 -&gt; 5,4,3,2,1</p>
<p>这样就完成了队列到栈的转换.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; a;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = a.size();</span><br><span class="line">        a.offer(x);</span><br><span class="line">        <span class="keyword">while</span>(size &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a.offer(a.poll());</span><br><span class="line">            --size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 229 Majority Element II</title>
    <url>/2020/08/15/Leetcode/Leetcode%20229%20Majority%20Element%20II/</url>
    <content><![CDATA[<p>Given an integer array of size <em>n</em>, find all elements that appear more than <code>⌊ n/3 ⌋</code> times.</p>
<p><strong>Note:</strong> The algorithm should run in linear time and in O(1) space.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: [3]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,1,1,3,3,2,2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-错误的摩尔投票"><a href="#1-错误的摩尔投票" class="headerlink" title="1 错误的摩尔投票"></a>1 错误的摩尔投票</h2><p>因为超过n/3的值只能是1个或2个. </p>
<p>若<strong>已经找到一个超过n/3的值A</strong>, 可以先”剔除”这个值, 然后在剩下的值里面通过摩尔投票 (摩尔投票参考leetcode169)寻找超过nn/2的值B, (其中nn为n - count(A); )</p>
<p>若找到的B的个数大于n/3, 那么返回[A, B]</p>
<p>找到的B的个数小于n/3, 那么返回[A]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)  <span class="comment">//相当于&quot;剔除&quot;了A</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(nums[i] == A)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    doSometingElse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但关键是如何找到一个超过n/3的值A, 我的所有尝试都失败了</strong>. 本来想在摩尔投票上做一个修改找超过n/3的元素, 即一个元素通过2个不同的元素消去,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = nums.front();</span><br><span class="line"><span class="keyword">int</span> count_x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] == x)</span><br><span class="line">        count_x += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        count_x -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count_x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = nums[i];</span><br><span class="line">        count_x = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但是这样是不行的</strong>, 反例[1,3,3,4].</p>
<p>所以只能用hashmap了 (再次流下了菜的泪水😭😭😭)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vc;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">            ++mp[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; i : mp)</span><br><span class="line">            <span class="keyword">if</span>(i.second &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>)</span><br><span class="line">                vc.push_back(i.first);</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-正确的摩尔投票"><a href="#2-正确的摩尔投票" class="headerlink" title="2 正确的摩尔投票"></a>2 正确的摩尔投票</h2><p>思路是, 对于三个互不同的值, 三三消去. 最后剩下的, 就是超过n/3的元素</p>
<p>思路很简单, 但是代码上有细节需要注意.</p>
<p>首先设置两个candidate和count记录出现的值和个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> candidate1 = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> candidate2 = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>若nums[i] == candidate1 或nums[i] == candidate2, 则相应的count++. <strong>然后conitune</strong></li>
<li>若count1 == 0,  要及时地更换相应的candidate1并设置count为1, candidaite2不变, 若count2 == 0,  要及时地更换相应的candidate2并设置count为1, candidaite1不变. 这样就保证了只要有一个count是0, 那么另外一个count不会受三者不相等的影响导致count–<strong>. 这一点很重要, 之前写n/2的摩尔投票的时候都是nums[i]和candidiate不相等的时候count直接减1, 然后检查count是否小于0, 如果小于0, 再更新candidate和count. 但是这个例子中不行! 反例[1 1 1 3 3 2 2 2], 如果先判断不相等都减1的话, 前面的3个1会被第3个元素3抵消1个, 抵消后的1就达不到n/3的标准了</strong></li>
<li>最后检查两个candidate是否真的大于n/3.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vc;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;    <span class="comment">//nums:[] =&gt; [], nums:[a] =&gt; [a]</span></span><br><span class="line">        <span class="keyword">int</span> candidate1 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> candidate2 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candidate1)</span><br><span class="line">                ++count1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)</span><br><span class="line">                ++count2;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count1 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                candidate1 = nums[i];</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count2 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                candidate2 = nums[i];</span><br><span class="line">                count2 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --count1;</span><br><span class="line">                --count2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), candidate1) &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>)</span><br><span class="line">            vc.push_back(candidate1);</span><br><span class="line">        <span class="keyword">if</span>(candidate2 != candidate1 &amp;&amp; count(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), candidate2) &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>)</span><br><span class="line">            vc.push_back(candidate2);</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 226 Invert Binary Tree</title>
    <url>/2020/10/05/Leetcode/Leetcode%20226%20Invert%20Binary%20Tree/</url>
    <content><![CDATA[<p>Invert a binary tree.</p>
<p><strong>Example:</strong></p>
<p>Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p><strong>Trivia:</strong><br>This problem was inspired by <a href="https://twitter.com/mxcl/status/608682016205344768">this original tweet</a> by <a href="https://twitter.com/mxcl">Max Howell</a>:</p>
<blockquote>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
</blockquote>
<a id="more"></a>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><p>这太简单了…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2 队列"></a>2 队列</h2><p>再放一个非递归用队列实现的吧. 其实楼主在刻意的练习二叉树的非递归算法, 怕面试的时候简单题不让用递归, 不会的话就gg了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span>(size != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode tmp = q.poll();</span><br><span class="line">                TreeNode dummy = tmp.left;</span><br><span class="line">                tmp.left = tmp.right;</span><br><span class="line">                tmp.right = dummy;</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    q.offer(tmp.right);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 228 Summary Ranges</title>
    <url>/2020/08/14/Leetcode/Leetcode%20228%20Summary%20Ranges/</url>
    <content><![CDATA[<p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:  [0,1,2,4,5,7]</span><br><span class="line">Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:  [0,2,3,4,6,8,9]</span><br><span class="line">Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>指针begin记录continuous range第一个数, end记录continuous range的最后一个数. 若发现某个i和前面的不连续, 将begin和end统计成字符串存储到vector中, 并更新begin和end为nums[i]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">summaryRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vc;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> vc;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">begin</span> = nums.front();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = nums.front();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++<span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vc.push_back(to_string(<span class="built_in">begin</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    vc.push_back(to_string(<span class="built_in">begin</span>) + <span class="string">&quot;-&gt;&quot;</span> + to_string(<span class="built_in">end</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == nums.<span class="built_in">size</span>())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">end</span> = <span class="built_in">begin</span> = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 23 Merge K Sorted Lists</title>
    <url>/2020/09/24/Leetcode/Leetcode%2023%20Merge%20K%20Sorted%20Lists/</url>
    <content><![CDATA[<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>
<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br><span class="line">Explanation: The linked-lists are:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">merging them into one sorted list:</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: lists &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: lists &#x3D; [[]]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>k == lists.length</code></li>
<li><code>0 &lt;= k &lt;= 10^4</code></li>
<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>
<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>
<li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li>
<li>The sum of <code>lists[i].length</code> won’t exceed <code>10^4</code>.</li>
</ul>
<a id="more"></a>
<h2 id="1-k指针"><a href="#1-k指针" class="headerlink" title="1 k指针"></a>1 k指针</h2><p>首先创建一个空链表result, 对于lists中的k个指针, 选出指向元素最小的指针minIndex(空指针跳过不参加比较), 然后将这个元素添加到链表result中. 然后指针minIndex指向下一个元素, 其他指针不动. 再从这k个指针指向的元素中找到最小的, 以此类推…..直到所有指针全部为null.</p>
<p>时间复杂度O(kn), k是lists数量, n是链表长度和.</p>
<p><strong>这个方法慢的原因就是, 每一次添加一个元素之后都要从k个指针中找到最小的那一个!</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode* listHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode* tail = listHead;</span><br><span class="line">        <span class="keyword">while</span>(!areAllNull(lists))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lists[i] == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(lists[i]-&gt;val &lt; <span class="built_in">min</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    minIndex = i;</span><br><span class="line">                    <span class="built_in">min</span> = lists[i]-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> ListNode(lists[minIndex]-&gt;val);</span><br><span class="line">            lists[minIndex] = lists[minIndex]-&gt;next;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areAllNull</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* <span class="built_in">list</span> : lists)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">list</span> != <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-优先队列"><a href="#2-优先队列" class="headerlink" title="2 优先队列"></a>2 优先队列</h2><p>因为每一次都是从k个指针指向的元素里面选最小的, 所以可以用优先队列来优化, 构建一个大小为k的优先队列, 可以将复杂度变为O(nlogk).</p>
<p>首先, 把所有的非空指针加入到队列中, 然后pop一个元素最小的指针min, 插入到返回队列中, 如果min-&gt;next非空, 就再继续把min-&gt;next加入到优先队列中. 直到优先队列为空.</p>
<p>这里要吐槽一下c++的STL, 几乎所有的操作都比Java的Collection好用, 就是自定义优先队列的时候不方便. 要新写一个<code>struct</code>, 重载<code>()</code>运算符. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> ListNode* a, <span class="keyword">const</span> ListNode* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>return a-&gt;val &gt; b-&gt;val</code>指的是, 如果函数返回值是true，则证明函数中第一个参数的优先级比第二个参数小，优先级小的就该放到后面去.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode* listHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode* tail = listHead;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, ListNodeCmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* <span class="built_in">list</span> : lists)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">list</span> != <span class="literal">nullptr</span>)</span><br><span class="line">                pq.push(<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* <span class="built_in">min</span> = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> ListNode(<span class="built_in">min</span>-&gt;val);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">min</span>-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">                pq.push(<span class="built_in">min</span>-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNodeCmp</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> ListNode* a, <span class="keyword">const</span> ListNode* b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 231 Power Of Two</title>
    <url>/2020/10/22/Leetcode/Leetcode%20231%20Power%20Of%20Two/</url>
    <content><![CDATA[<p>Given an integer <code>n</code>, write a function to determine if it is a power of two.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 20 &#x3D; 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 16</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 24 &#x3D; 16</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 4</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>-231 &lt;= n &lt;= 231 - 1</code></li>
</ul>
<a id="more"></a>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>直接判断二进制的n 是不是 <strong>开头一个1, 后面n个0</strong>的形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(n != <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 230 Kth Smallest Element In A Bst</title>
    <url>/2020/10/27/Leetcode/Leetcode%20230%20Kth%20Smallest%20Element%20In%20A%20Bst/</url>
    <content><![CDATA[<p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong><br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of elements of the BST is between <code>1</code> to <code>10^4</code>.</li>
<li>You may assume <code>k</code> is always valid, <code>1 ≤ k ≤ BST&#39;s total elements</code>.</li>
</ul>
<a id="more"></a>
<h2 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h2><p>简单来说, 这题就是找到BST中序遍历的第k个值.</p>
<p>由于递归方法不太方便传入一个全局计数器, 所以采用非递归中序遍历.</p>
<p>维持一个变量currRank, 每遍历一个元素就++currRank.</p>
<p>当currRank = k的时候就返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currRank = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        TreeNode tmp = root;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stk.offerFirst(tmp);</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode curr = stk.pollFirst();</span><br><span class="line">            ++currRank;</span><br><span class="line">            <span class="keyword">if</span>(currRank == k)</span><br><span class="line">                <span class="keyword">return</span> curr.val;</span><br><span class="line">            TreeNode tmp1 = curr.right;</span><br><span class="line">            <span class="keyword">while</span>(tmp1 != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.offerFirst(tmp1);</span><br><span class="line">                tmp1 = tmp1.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// if k &gt; tree.size, return -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 232 Implement Queue Using Stacks</title>
    <url>/2020/10/29/Leetcode/Leetcode%20232%20Implement%20Queue%20Using%20Stacks/</url>
    <content><![CDATA[<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>
<p>Implement the <code>MyQueue</code> class:</p>
<ul>
<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>
<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>
<li><code>int peek()</code> Returns the element at the front of the queue.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</li>
</ul>
<p><strong>Follow-up:</strong> Can you implement the queue such that each operation is <strong><a href="https://en.wikipedia.org/wiki/Amortized_analysis">amortized</a></strong> <code>O(1)</code> time complexity? In other words, performing <code>n</code> operations will take overall <code>O(n)</code> time even if one of those operations may take longer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyQueue myQueue &#x3D; new MyQueue();</span><br><span class="line">myQueue.push(1); &#x2F;&#x2F; queue is: [1]</span><br><span class="line">myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); &#x2F;&#x2F; return 1</span><br><span class="line">myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]</span><br><span class="line">myQueue.empty(); &#x2F;&#x2F; return false</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>peek</code>, and <code>empty</code>.</li>
<li>All the calls to <code>pop</code> and <code>peek</code> are valid.</li>
</ul>
<a id="more"></a>
<h2 id="1-栈模拟1"><a href="#1-栈模拟1" class="headerlink" title="1 栈模拟1"></a>1 栈模拟1</h2><p>设立两个栈stk1和stk2, stk1储存倒置顺序的元素, stk2为空.</p>
<p>push的时候先把stk1所有元素转移到stk2, 然后把x放到stk1栈底, 然后再把stk2剩下的元素返回到stk1, 这样, stk1底部多了元素x, 并且其他元素位置不变.</p>
<blockquote>
<p>初始状态                                 清空stk1                                       push(5)                                   剩下的元素返回stk1</p>
<p>stk1 :  4,3,2,1                          null                                              5                                               5,4,3,2,1</p>
<p>stk2 :  null                               1,2,3,4                                        1,2,3,4                                       null</p>
</blockquote>
<p><strong>但是这种push操作需要O(n)复杂度</strong>. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stk1;</span><br><span class="line">    Stack&lt;Integer&gt; stk2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stk2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stk1.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            stk2.push(stk1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stk1.push(x);</span><br><span class="line">        <span class="keyword">while</span>(!stk2.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            stk1.push(stk2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2-栈模拟2"><a href="#2-栈模拟2" class="headerlink" title="2 栈模拟2"></a>2 栈模拟2</h2><p>上面的方法每push一次都要有O(n)的计算量.</p>
<p>可以改进一下, 设置一个pushstack和popstack.</p>
<p>每次push都直接push到pushstack中. pop或top的时候再把pushtack中的元素全都转移过来. 由于栈的特性, 转移到popstack后自然是队列的顺序了.</p>
<p>这样, 所有操作的复杂度都可以降为O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; pushStk;</span><br><span class="line">    Stack&lt;Integer&gt; popStk;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pushStk = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        popStk = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        pushStk.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!popStk.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> popStk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!pushStk.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                popStk.push(pushStk.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> popStk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!popStk.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> popStk.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!pushStk.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                popStk.push(pushStk.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> popStk.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pushStk.isEmpty() &amp;&amp; popStk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 234 Palindrome Linked List</title>
    <url>/2020/10/06/Leetcode/Leetcode%20234%20Palindrome%20Linked%20List/</url>
    <content><![CDATA[<p>Given a singly linked list, determine if it is a palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p>
<a id="more"></a>
<h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><p>首先通过快慢指针, 找到链表的中间节点middle, 然后翻转middle之后的元素. 之后, 从head和middle处逐个开始比较元素.</p>
<p>不知道为什么只超过了5%的时间. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode middle = slow;</span><br><span class="line">        <span class="comment">//reverse the second half part of the linked list</span></span><br><span class="line">        ListNode p1 = middle.next;</span><br><span class="line">        ListNode p2 = middle.next.next;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        middle.next.next = <span class="keyword">null</span>;</span><br><span class="line">        middle.next = p1;</span><br><span class="line">        middle = middle.next;</span><br><span class="line">        ListNode head1 = head;</span><br><span class="line">        <span class="keyword">for</span>(ListNode i = head; i != <span class="keyword">null</span>; i = i.next)</span><br><span class="line">            System.out.print(i.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(middle != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val != middle.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">            middle = middle.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 235 Lowest Common Ancestor Of A Binary Search Tree</title>
    <url>/2020/11/05/Leetcode/Leetcode%20235%20Lowest%20Common%20Ancestor%20Of%20A%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [2,1], p &#x3D; 2, q &#x3D; 1</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[2, 105]</code>.</li>
<li><code>-109 &lt;= Node.val &lt;= 109</code></li>
<li>All <code>Node.val</code> are <strong>unique</strong>.</li>
<li><code>p != q</code></li>
<li><code>p</code> and <code>q</code> will exist in the BST.</li>
</ul>
<a id="more"></a>
<h2 id="1-hashmap"><a href="#1-hashmap" class="headerlink" title="1 hashmap"></a>1 hashmap</h2><p>其实第一眼我看成了求一颗普通的二叉树的两个节点最近公共祖先节点了. <strong>可能是受到剑指offer里面最后一题的影响吧, 在那里面的题就是普通树而不是BST. 再次提醒我们做题前一定要看清题意, 不要想当然</strong></p>
<p>储存每个孩子节点的父节点. 这样问题就变成了两条相交链表求第一个交点了. 但是又慢空间占用也大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;TreeNode, TreeNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        initMap(root);</span><br><span class="line">        map.put(root, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode a = p;</span><br><span class="line">        TreeNode b = q;</span><br><span class="line">        <span class="keyword">while</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            a = (map.get(a) == <span class="keyword">null</span>) ? q : map.get(a);</span><br><span class="line">            b = (map.get(b) == <span class="keyword">null</span>) ? p : map.get(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMap</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(root.left, root);</span><br><span class="line">            initMap(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(root.right, root);</span><br><span class="line">            initMap(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">getAncestor</span><span class="params">(TreeNode child)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h2><p>其实利用BST的条件之后就很简单了.</p>
<p>分类讨论如下:</p>
<ul>
<li><p>如果p, q有一个节点等于当前的节点root, 那么就返回root即可.</p>
</li>
<li><p>如果p, q的值在root两侧, 那么公共节点也肯定是root. 因为从root开始这两个节点一左一右的就分道扬镳了</p>
</li>
<li><p>如果p, q的值都小于root, 那么他们的最近公共祖先肯定至少是root.left, 所以从root.left开始找. 如果都大于root, 同理, 从root.right开始找</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> rootVal = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val == rootVal || q-&gt;val == rootVal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val &gt; rootVal &amp;&amp; q-&gt;val &lt; rootVal || p-&gt;val &lt; rootVal &amp;&amp; q-&gt;val &gt; rootVal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val &gt; rootVal &amp;&amp; q-&gt;val &gt; rootVal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-递归改循环"><a href="#3-递归改循环" class="headerlink" title="3. 递归改循环"></a>3. 递归改循环</h2><p>发现上面的迭代过程可以改成循环. 可以将空间复杂度O(log n)降为O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            <span class="keyword">int</span> rootVal = root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val == rootVal || q-&gt;val == rootVal)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val &gt; rootVal &amp;&amp; q-&gt;val &lt; rootVal || p-&gt;val &lt; rootVal &amp;&amp; q-&gt;val &gt; rootVal)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val &gt; rootVal &amp;&amp; q-&gt;val &gt; rootVal)</span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 237 Delete Node In A Linked List</title>
    <url>/2020/10/15/Leetcode/Leetcode%20237%20Delete%20Node%20In%20A%20Linked%20List/</url>
    <content><![CDATA[<p>Write a function to <strong>delete a node</strong> in a singly-linked list. You will <strong>not</strong> be given access to the <code>head</code> of the list, instead you will be given access to <strong>the node to be deleted</strong> directly.</p>
<p>It is <strong>guaranteed</strong> that the node to be deleted is <strong>not a tail node</strong> in the list.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/01/node2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 1</span><br><span class="line">Output: [4,5,9]</span><br><span class="line">Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4], node &#x3D; 3</span><br><span class="line">Output: [1,2,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [0,1], node &#x3D; 0</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [-3,5,-99], node &#x3D; -3</span><br><span class="line">Output: [5,-99]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The number of the nodes in the given list is in the range <code>[2, 1000]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>The value of each node in the list is <strong>unique</strong>.</li>
<li>The <code>node</code> to be deleted is <strong>in the list</strong> and is <strong>not a tail</strong> node</li>
</ul>
<a id="more"></a>
<h2 id="交换节点的值"><a href="#交换节点的值" class="headerlink" title="交换节点的值"></a>交换节点的值</h2><p>一开始想这个题总想不出来, 感觉必须要获得这个节点前面的一个节点才能删除.</p>
<p>后来看了答案才发现只需要交换值就可以!!!</p>
<p><strong>把这个节点的后一个节点的值覆盖到这个节点上, 然后删除后一个节点就可以了!!</strong></p>
<p>可能是之前做链表题, 有很多链表题都要求只能进行指针的计算不能交换值这个条件限制了思路.</p>
<p>还是应该打开思路, 多多创新.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.next.next == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node.val = node.next.val;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node.val = node.next.val;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 238 Product Of Array Except Self</title>
    <url>/2020/08/16/Leetcode/Leetcode%20238%20Product%20Of%20Array%20Except%20Self/</url>
    <content><![CDATA[<p>Given an array <code>nums</code> of <em>n</em> integers where <em>n</em> &gt; 1,  return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:  [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<p><strong>Constraint:</strong> It’s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.</p>
<p><strong>Note:</strong> Please solve it <strong>without division</strong> and in O(<em>n</em>).</p>
<p><strong>Follow up:</strong><br>Could you solve it with constant space complexity? (The output array <strong>does not</strong> count as extra space for the purpose of space complexity analysis.)</p>
<a id="more"></a>
<h2 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h2><p>主要想法就是花费O(n)的时间构造2个数组<code>prev</code> 和 <code>next</code>. <code>prev[i]</code> 存储nums从0到i的积, <code>next[i]</code>存储nums从i到size-1的积. 所以结果<code>ans[i] = prev[i-1] * next[i+1]</code>. **但是这个方法还是我断断续续想了一天才想出来的. 之前都在纠结于 <em>在不用除法的情况下</em> 怎样根据算出来的第i个值ans[i]和数组nums来推算第i+1个值 **.可见一开始就在错误的道路上越走越远了😠😠</p>
<p>但是这个需要花费2n的额外空间. 一个很自然的想法就是, <strong>利用原数组nums储存一个数组prev, 利用返回的数组ans储存另一个数组next</strong>.</p>
<p>首先在ans中储存next, 在nums中储存prev</p>
<p>然后从0到size-1地计算 <code>ans[i] = nums[i-1] * ans[i+1]</code>. 当i = 0 或 i = size - 1 时退化为<code>ans[0] = ans[1] </code> 或 <code>ans[size-1] =nums[size-2] </code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">-1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp *= nums[i];</span><br><span class="line">            ans[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp *= nums[i];</span><br><span class="line">            nums[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                ans[i] = ans[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                ans[i] = nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans[i] = nums[i<span class="number">-1</span>] * ans[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 24 Swap Nodes In Pairs</title>
    <url>/2020/09/25/Leetcode/Leetcode%2024%20Swap%20Nodes%20In%20Pairs/</url>
    <content><![CDATA[<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="三指针"><a href="#三指针" class="headerlink" title="三指针"></a>三指针</h2><p>首先照常是为了方便加上头节点.</p>
<p>对于第2k个节点和第2k+1个节点, 要交换他们, 需要三个节点的指针. before(2k-1), curr(2k), after(2k+1).</p>
<p>然后执行下面的命令达到交换的目的. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode tmp = after.next;</span><br><span class="line">before.next = after;</span><br><span class="line">after.next = curr;</span><br><span class="line">curr.next = tmp;</span><br></pre></td></tr></table></figure>

<p>指针交换完之后要判断是不是要继续往下交换. 我们用tmp保存了交换前的after.next变量. 如果tmp != null 并且 tmp.next != null 就说明链表后面至少还有2个节点, 要继续交换, 要更新before, curr, after 的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before = curr;</span><br><span class="line">curr = tmp;</span><br><span class="line">after = tmp.next;</span><br></pre></td></tr></table></figure>

<p>在纸上画链表图之后很容易看出这两个代码块的操作是怎么回事了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode headList = <span class="keyword">new</span> ListNode(<span class="number">500</span>, head);</span><br><span class="line">        ListNode before = headList;</span><br><span class="line">        ListNode curr = headList.next;</span><br><span class="line">        <span class="keyword">if</span>(curr == null || curr.next == null)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode after = curr.next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = after.next;</span><br><span class="line">            before.next = after;</span><br><span class="line">            after.next = curr;</span><br><span class="line">            curr.next = tmp;</span><br><span class="line">            <span class="keyword">if</span>(tmp == null || tmp.next == null)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            before = curr;</span><br><span class="line">            curr = tmp;</span><br><span class="line">            after = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headList.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 242 Valid Anagram</title>
    <url>/2020/08/11/Leetcode/Leetcode%20242%20Valid%20Anagram/</url>
    <content><![CDATA[<p>Given two strings <em>s</em> and <em>t</em> , write a function to determine if <em>t</em> is an anagram of <em>s</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p>
<p><strong>Follow up:</strong><br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<a id="more"></a>
<h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><p>构造2个hashmap 存放s中哪个字符出现多少次, t中哪个字符出现多少次</p>
<p>然后判断这两个hashmap是否相等即可</p>
<p>官方题解是构造整个字符集大小的数组储存出现次数, 个人感觉不是太好. 如果是unicode肯定gg</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; smap;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; tmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i : s)</span><br><span class="line">        &#123;</span><br><span class="line">            ++smap[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i : t)</span><br><span class="line">        &#123;</span><br><span class="line">            ++tmap[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; i : smap)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second != tmap[i.first])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 240 Search A 2d Matrix II</title>
    <url>/2020/11/15/Leetcode/Leetcode%20240%20Search%20A%202d%20Matrix%20II/</url>
    <content><![CDATA[<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p><strong>Example:</strong></p>
<p>Consider the following matrix:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Given target = <code>5</code>, return <code>true</code>.</p>
<p>Given target = <code>20</code>, return <code>false</code>.</p>
<a id="more"></a>
<h2 id="1-分治"><a href="#1-分治" class="headerlink" title="1. 分治"></a>1. 分治</h2><p><strong>这是我看答案之前想出来的方法. 这个方法贼麻烦.</strong> 但是复杂度并不高</p>
<p>对于一个矩阵, 我们考虑对角线元素.</p>
<p>对对角线元素组成的数组进行二分查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,   4,  7, 11, 15],</span><br><span class="line">[2,   5,  8, 12, 19],</span><br><span class="line">[3,   6,  9, 16, 22],</span><br><span class="line">[10, 13, 14, 17, 24],</span><br><span class="line">[18, 21, 23, 26, 30]</span><br></pre></td></tr></table></figure>

<p>例如在上面这个矩阵中, 我们要寻找15. 对角线数组为[1, 5, 9, 17, 30]. 15位于9和17之间. (如果对角线中含有15, 就直接返回15即可. 不用继续查找了)</p>
<p>那么可以把矩阵分为4部分, 左上角为小于等于9的, 右下角为大于17的, 左下角和右上角的元素可能是9到17中间的, 也可能大于17. 所以元素15只有可能出现在左下和右上的子矩阵中.</p>
<blockquote>
<p>  [<strong>1,   4,  7</strong>,  ==11, 15==],<br>  [<strong>2,   5,  8</strong>,  ==12, 19==],<br>  [<strong>3,   6,  9,</strong>  ==16, 22==],<br>  [==10, 13, 14==, <strong>17, 24</strong>],<br>  [==18, 21, 23==, <strong>26,</strong> <strong>30</strong>]</p>
</blockquote>
<p>所以, 接下来就可以从这两个子矩阵中递归地查找元素15了. 递归边界为矩阵退化为行向量或列向量. 这时只需要用普通的二分查找即可.</p>
<p>这里还有个要注意的点, 就是对角线的二分查找问题.</p>
<p>如果矩阵是不是方阵, 那么如果target小于对角线第一个元素, target肯定小于这个子矩阵的所有元素. 但是, 如果target大于对角线最后一个元素, target却不一定大于这个子矩阵所有元素. </p>
<blockquote>
<p> [<strong>1</strong>,   4,  7, ==11, 15==],<br>  [2,   <strong>5</strong>,  8, ==12, 19==],<br>  [3,   6,  <strong>9</strong>, ==16, 22==],           如果target = 10, 大于对角线最后一个元素9, 就要从后面的元素中开始找</p>
</blockquote>
<blockquote>
<p>[<strong>1</strong>,   4,  7],<br>[2,   <strong>5</strong>,  8],<br>[3,   6,  <strong>9</strong>],<br>[==10, 13, 14==],<br>[==18, 21, 23==]                   如果target = 10, 大于对角线最后一个元素9, 就要从后面的元素中开始找</p>
</blockquote>
<blockquote>
<p>[1,   4,  7]<br>[2,   5,  8]<br>[3,   6,  9]                    如果矩阵是方阵, target = 10 大于对角线最后一个元素9, 那么矩阵中不可能存在target</p>
</blockquote>
<p>复杂度分析: 为了简单起见, 设矩阵为方阵, 有<code>n</code>个元素. <strong>注意, 这里是假设矩阵的元素个数为n, 而不是矩阵的维数为n.</strong> <strong>矩阵的维数应该为<code>sqrt(n) * sqrt(n)</code></strong></p>
<p>那么每一次对size为<code>sqrt(n)</code>的矩阵进行查找, 就需要先进行一次对角线的二分查找. 花费<code>log(sqrt(n))</code>, 然后对2个size为<code>n / 4</code>的矩阵进行查找.</p>
<p>故有<code>T(n) = log(sqrt(n)) + 2T(n/4)</code></p>
<p>做个换元, <code>n = 2 ^ k</code>, 得到<code>T(2^k) = k/2 + 2*T(2^(k-2))</code> 然后经过漫长的推到, 得到结果是<code>T(n) ~ sqrt(n)</code>.</p>
<p>即时间复杂度和矩阵大小成正比例.</p>
<p>如果矩阵是a * b的话, 复杂度应该为<code>sqrt(a*b)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> searchMatrix(matrix, target, <span class="number">0</span>, matrix.length - <span class="number">1</span>, <span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target, <span class="keyword">int</span> beginRow, <span class="keyword">int</span> endRow, <span class="keyword">int</span> beginColumn, <span class="keyword">int</span> endColumn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beginRow == endRow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearchRow(matrix, target, beginColumn, endColumn, beginRow);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(beginColumn == endColumn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearchColumn(matrix, target, beginRow, endRow, beginColumn);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = endRow - beginRow + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = endColumn - beginColumn + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> diagonalLen = Math.min(m, n);</span><br><span class="line">        <span class="keyword">int</span> minDiagonal = matrix[beginRow][beginColumn];</span><br><span class="line">        <span class="keyword">int</span> maxDiagonal = matrix[beginRow + diagonalLen - <span class="number">1</span>][beginColumn + diagonalLen - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target &lt; minDiagonal)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; maxDiagonal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m == n)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m &gt; n)</span><br><span class="line">                <span class="keyword">return</span> searchMatrix(matrix, target, beginRow + n, endRow, beginColumn, endColumn);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> searchMatrix(matrix, target, beginRow, endRow, beginColumn + m, endColumn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = diagonalLen - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[beginRow + mid][beginColumn + mid] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[beginRow + mid][beginColumn + mid] &lt; target)</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> searchMatrix(matrix, target, beginRow, beginRow + j, beginColumn + i, endColumn) || searchMatrix(matrix, target, beginRow + i, endRow, beginColumn, beginColumn + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">binarySearchRow</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target, <span class="keyword">int</span> beginColumn, <span class="keyword">int</span> endColumn, <span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = beginColumn;</span><br><span class="line">        <span class="keyword">int</span> end = endColumn;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][mid] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">binarySearchColumn</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target, <span class="keyword">int</span> beginRow, <span class="keyword">int</span> endRow, <span class="keyword">int</span> column)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = beginRow;</span><br><span class="line">        <span class="keyword">int</span> end = endRow;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid][column] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[mid][column] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-线性搜索法"><a href="#2-线性搜索法" class="headerlink" title="2. 线性搜索法"></a>2. 线性搜索法</h2><p><strong>这种方法真的是又简单又快! 但是感觉如果第一次做应该想不出来.</strong></p>
<p>从左下或右上开始找, 不妨假设从左下开始.</p>
<p>找的时候只能向上或向右. 原因如下, 记当前的坐标为(row, column)初始为左下角. </p>
<blockquote>
<p>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],            target = 12, curr = 18 &gt; target.  因为curr是最后一行的最小值<br>  [==18, 21, 23, 26, 30==]             所以最底下一整行都不可能是target, 全部排除掉. curr向上移动变为10</p>
</blockquote>
<blockquote>
<p>  [==1==,   4,  7, 11, 15],<br>  [==2==,   5,  8, 12, 19],<br>  [==3==,   6,  9, 16, 22],<br>  [==10==, 13, 14, 17, 24],            target = 12, curr = 10 &lt; target. 因为curr是第一行的最大值<br>  [==18, 21, 23, 26, 30==]             所以最左侧一整列都不可能是target, 全部排除掉. curr向右移动变为13</p>
</blockquote>
<blockquote>
<p>  [==1==,   4,  7, 11, 15],<br>  [==2==,   5,  8, 12, 19],<br>  [==3==,   6,  9, 16, 22],<br>  [==10==, ==13, 14, 17, 24==],            target = 12, curr = 13 &gt; target. 因为curr是倒数第二行的最小值<br>  [==18, 21, 23, 26, 30==]             所以倒数第二行都不可能是target, 全部排除掉. curr向上移动变为6</p>
</blockquote>
<blockquote>
<p> [==1==,   ==4==,  7, 11, 15],<br>  [==2==,   ==5==,  8, 12, 19],<br>  [==3==,   ==6==,  9, 16, 22],<br>  [==10==, ==13, 14, 17, 24==],            target = 12, curr = 6 &lt; target. 因为curr是第二列的最大值<br>  [==18, 21, 23, 26, 30==]             所以第二列都不可能是target, 全部排除掉. curr向右移动变为9</p>
</blockquote>
<blockquote>
<p> [==1==,   ==4==,  ==7==, 11, 15],<br>  [==2==,   ==5==,  ==8==, 12, 19],<br>  [==3==,   ==6==,  ==9==, 16, 22],<br>  [==10==, ==13, 14, 17, 24==],            target = 12, curr = 9 &lt; target. 因为curr是第三列的最大值<br>  [==18, 21, 23, 26, 30==]             所以第三列都不可能是target, 全部排除掉. curr向右移动变为16</p>
</blockquote>
<blockquote>
<p> [==1==,   ==4==,  ==7==, 11, 15],<br>  [==2==,   ==5==,  ==8==, 12, 19],<br>  [==3==,   ==6==,  ==9==, ==16, 22==],<br>  [==10==, ==13, 14, 17, 24==],            target = 12, curr = 16 &gt; target. 因为curr是第三行的最大值<br>  [==18, 21, 23, 26, 30==]             所以第三行都不可能是target, 全部排除掉. curr向上移动变为12, 找到解了!</p>
</blockquote>
<p>时间复杂度O(a + b). 虽然时间复杂度一样, 但是这种方法空间复杂度是O(1). 并且代码<strong>极其简洁</strong>!!!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; -<span class="number">1</span> &amp;&amp; j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = matrix[i][j];</span><br><span class="line">            <span class="keyword">if</span>(curr == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curr &lt; target)</span><br><span class="line">                ++j;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 257 Binary Tree Paths</title>
    <url>/2020/10/22/Leetcode/Leetcode%20257%20Binary%20Tree%20Paths/</url>
    <content><![CDATA[<p>Given a binary tree, return all root-to-leaf paths.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class="line"></span><br><span class="line">Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>直接DFS到每一个叶子节点即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; ans1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans1;</span><br><span class="line">        List&lt;Integer&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        binaryTreePaths(ans, curr, root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; integers : ans)</span><br><span class="line">        &#123;</span><br><span class="line">            ans1.add(integersToString(integers));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">binaryTreePaths</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; curr, TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curr.add(root.val);</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curr.add(root.val);</span><br><span class="line">            binaryTreePaths(ans, curr, root.left);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curr.add(root.val);</span><br><span class="line">            binaryTreePaths(ans, curr, root.right);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">integersToString</span><span class="params">(List&lt;Integer&gt; integers)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integers.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            s.append(integers.get(i));</span><br><span class="line">            <span class="keyword">if</span>(i != integers.size() - <span class="number">1</span>)</span><br><span class="line">                s.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 26 Remove Duplicates From Sorted Array</title>
    <url>/2020/07/16/Leetcode/Leetcode%2026%20Remove%20Duplicates%20From%20Sorted%20Array/</url>
    <content><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>

<p>注意，要判断nums的长度，如果是0则会报错</p>
<a id="more"></a>
<h2 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1.暴力解法"></a>1.暴力解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> nextInteger = nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> bg = nextInteger;</span><br><span class="line">        <span class="keyword">auto</span> ed = nextInteger;</span><br><span class="line">        <span class="keyword">while</span>(bg != nums.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>((ed != nums.<span class="built_in">end</span>()) &amp;&amp; (*bg == *ed)) <span class="comment">//get the range of same integer</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++ed;</span><br><span class="line">            &#125;</span><br><span class="line">            ++bg;</span><br><span class="line">            nextInteger = nums.erase(bg,ed);</span><br><span class="line">            bg = nextInteger;                       <span class="comment">//find the next integer range</span></span><br><span class="line">            ed = nextInteger;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造两个指针bg ed, 通过不断比较找到相同的数字范围，删除两个指针之间的重复元素. 然后去比较下一个相同的数字的范围并删除。以此类推。 由于每一次调用erase的开销太大，复杂度高O(n^2)</p>
<h2 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2. 双指针"></a>2. 双指针</h2><p>思路是两个指针i，j  指针i遍历数组判断是否读取的是一个新的整数，指针j维护数组前j个互不相同的整数，判断出新的整数之后就将这个新的整数添加到j+1的位置。同时更新j。复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++j] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 263 Ugly Number</title>
    <url>/2020/10/27/Leetcode/Leetcode%20263%20Ugly%20Number/</url>
    <content><![CDATA[<p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are <strong>positive numbers</strong> whose prime factors only include <code>2, 3, 5</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 6 &#x3D; 2 × 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 8 &#x3D; 2 × 2 × 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 14</span><br><span class="line">Output: false </span><br><span class="line">Explanation: 14 is not ugly since it includes another prime factor 7.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>1</code> is typically treated as an ugly number.</li>
<li>Input is within the 32-bit signed integer range: [−231, 231 − 1].</li>
</ol>
<a id="more"></a>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>直接按照题意判断即可. 注意小于等于1的数的判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num /= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num /= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num /= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 25 Reverse Nodes In K Group</title>
    <url>/2020/09/30/Leetcode/Leetcode%2025%20Reverse%20Nodes%20In%20K%20Group/</url>
    <content><![CDATA[<p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>
<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>
<p><strong>Example:</strong></p>
<p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For <em>k</em> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For <em>k</em> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>Note:</strong></p>
<ul>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ul>
<a id="more"></a>
<h2 id="构造辅助函数-reverseFrom"><a href="#构造辅助函数-reverseFrom" class="headerlink" title="构造辅助函数(reverseFrom)"></a>构造辅助函数(reverseFrom)</h2><p>这个题看上去和leetcode 24 很像, 只不过把reverse 2换成了reverse k. 实际上不然. 这题和 leetcode 92更像.</p>
<p>在leetcode 92中, 我们reverse了从第m到第n个节点. 在这个题中, 只要求出了链表长度len, 那么就需要执行cnt = len/k次reverse.</p>
<p>每一次reverse都是reverse第<code>i*k</code>个到第<code>i*k + k-1</code>个节点. </p>
<p>所以构造函数<code>ListNode reverseFrom(ListNode prev, int k)</code></p>
<p>这个函数交换从prev.next开始之后的k个节点(从prev.next + 0到prev.next + k-1), 并返回被reverse的第k个节点ret. 作为下一次函数调用的输入.</p>
<p>例如 head-&gt;1 -&gt; 2 -&gt;3 -&gt; 4,</p>
<p>我们调用完 <code>reverseFrom(head, 2)</code>之后, 链表变为head-&gt;2 -&gt; <strong>1</strong> -&gt;3 -&gt; 4, 返回值ret指向新链表中的1. 那么当我们再调用<code>reverseFrom(ret, 2)</code>后, 链表就变为了head-&gt;2 -&gt; 1 -&gt;4 -&gt; <strong>3</strong>. 此时ret指向3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, head);</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = length / k;</span><br><span class="line">        ListNode prev = dummyHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            prev = reverseFrom(prev, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseFrom</span><span class="params">(ListNode prev, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = prev.next;</span><br><span class="line">        ListNode p2 = p1.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next.next = p2;</span><br><span class="line">        ListNode ret = prev.next;</span><br><span class="line">        prev.next = p1;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 268 Missing Number</title>
    <url>/2020/07/23/Leetcode/Leetcode%20268%20Missing%20Number/</url>
    <content><![CDATA[<p>Given an array containing <em>n</em> distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,0,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<a id="more"></a>
<h2 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1 暴力法"></a>1 暴力法</h2><p>使用一个hash set储存数组的所有元素，再查找从0到n哪个元素没有在set中，这样做时间和空间复杂度为O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> notFound = (s.<span class="built_in">find</span>(i) == s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(notFound)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-求sum"><a href="#2-求sum" class="headerlink" title="2 求sum"></a>2 求sum</h2><p>假如一个都不缺的话，那么这个数组的和一定为n*(n+1)/2,</p>
<p>先计算这个数组的和sum，那么n*(n+1)/2 - sum一定为缺少的元素！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> n * (n + <span class="number">1</span>) /<span class="number">2</span> - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-异或"><a href="#3-异或" class="headerlink" title="3 异或"></a>3 异或</h2><p>先考虑异或的性质  a^b=b^a  (a^b)^c = a^(b^c) a^b^b = a</p>
<p>即满足交换律和结合律，并且<strong>一个数异或两次相同的数等于不异或</strong></p>
<p>可以利用这一点，找到缺失的那个值。</p>
<p>对于变量n = 0，n先异或从0到n的所有值，再异或数组中的所有值</p>
<p>假如0到n的任意一个数，在数组中出现过，那么根据交换律和异或两次相同的数等于不异或</p>
<p>那么这个数就相当于被消去了，只有数组中不存在的那个数只被异或了一次。</p>
<p>消去后只剩n = 0 ^ j = j 其中j是数组中消失的数，返回n即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            n ^= i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            n ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 287 Find The Duplicate Number</title>
    <url>/2020/08/16/Leetcode/Leetcode%20287%20Find%20The%20Duplicate%20Number/</url>
    <content><![CDATA[<p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>You <strong>must not</strong> modify the array (assume the array is read only).</li>
<li>You must use only constant, <em>O</em>(1) extra space.</li>
<li>Your runtime complexity should be less than <em>O</em>(<em>n</em>2).</li>
<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>
</ol>
<a id="more"></a>
<h2 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1 暴力法"></a>1 暴力法</h2><p>我知道肯定会超时, 但是找出又满足不能modify数组的, 又要常数复杂度的, 又要小于n^2的实在做不到(流下了不学无术的泪水😭)</p>
<p>本来想用分治做的,但是没想出来(一直在想分为两个子数组之后如何在O(n)时间内找出两个子数组的重复元素?后来看答案发现这个思路错了)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[j])</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-分治"><a href="#2-分治" class="headerlink" title="2 分治"></a>2 分治</h2><p>这个题用分治确实可以做， 但是不是将数组划分为两个子数组，而是将duplicate的元素所在的区间一步步划分。</p>
<p>假设low = 1, high = n, mid= (low + high)/2</p>
<p>现在统计各个段的元素个数，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt_smaller_than_mid = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> cnt_larger_than_mid = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> cnt_equal_mid = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(i &lt; mid &amp;&amp; i &gt;= low)</span><br><span class="line">                 ++cnt_smaller_than_mid;</span><br><span class="line">             <span class="keyword">if</span>(i &gt; mid &amp;&amp; i &lt;= high)</span><br><span class="line">                 ++cnt_larger_than_mid;</span><br><span class="line">             <span class="keyword">if</span>(i == mid)</span><br><span class="line">                 ++cnt_equal_mid;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<p>如果等于mid的元素个数大于1，那么mid肯定是duplicate的</p>
<p>如果小于mid但大于等于low的元素个数 大于 mid - low，那么重复的元素肯定在[low,mid)中</p>
<p>如果大于mid但小于等于high的元素个数大于high - mid，那么重复的元素肯定在(mid,low]中，</p>
<p>再对[low,mid-1]或[mid  + 1,low]采取相同的分治方法，最后求出答案，复杂度O(nlogn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt_smaller_than_mid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt_larger_than_mid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt_equal_mid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; mid &amp;&amp; i &gt;= low)</span><br><span class="line">                    ++cnt_smaller_than_mid;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; mid &amp;&amp; i &lt;= high)</span><br><span class="line">                    ++cnt_larger_than_mid;</span><br><span class="line">                <span class="keyword">if</span>(i == mid)</span><br><span class="line">                    ++cnt_equal_mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt_equal_mid &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt_smaller_than_mid &gt; mid - low)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt_larger_than_mid &gt; high - mid)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-快慢指针"><a href="#3-快慢指针" class="headerlink" title="3 快慢指针"></a>3 快慢指针</h2><p>将这个数组看成一个链表, 第i个元素的下一个元素是位于nums[i]的元素.</p>
<p>例如 [1,3,4,2,2] 看作 1-&gt;3-&gt;2-&gt;4-&gt;2-&gt;4-&gt;2 …… 这个例子中, 有2个2, 即有2个指向元素4的指针. 4为环中第一个元素.</p>
<p>因为数组中存在重复的元素, 即两个值同时指向数组中的某个值. 所以, 这个链表中一定存在环. 类似于”6”这样的链表</p>
<p>利用快慢指针法 <strong>leetcode 142</strong> 即可找到环的起点.然后找到它的下标即可</p>
<p><strong>不得不感叹想出这个方法的人的聪明, 完美的利用了0 &lt; nums[i] &lt; n的特点. 看样子同一个物种的🧠差距还是非常大的</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">        &#125;<span class="keyword">while</span>(fast != slow);</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 260 Single Number III</title>
    <url>/2020/11/15/Leetcode/Leetcode%20260%20Single%20Number%20III/</url>
    <content><![CDATA[<p>Given an integer array <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in <strong>any order</strong>.</p>
<p><strong>Follow up:</strong> Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,1,3,2,5]</span><br><span class="line">Output: [3,5]</span><br><span class="line">Explanation:  [5, 3] is also a valid answer.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,0]</span><br><span class="line">Output: [-1,0]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: [1,0]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 30000</code></li>
<li>Each integer in <code>nums</code> will appear twice, only two integers will appear once.</li>
</ul>
<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1 暴力"></a>1 暴力</h2><p>这题我也不会, 只能暴力哈希表了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            map.putIfAbsent(i,<span class="number">0</span>);</span><br><span class="line">            map.put(i,map.get(i) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue() == <span class="number">1</span>)</span><br><span class="line">                list.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="number">0</span>] = list.get(<span class="number">0</span>);</span><br><span class="line">        a[<span class="number">1</span>] = list.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2 位运算"></a>2 位运算</h2><p>首先还是老样子异或, 异或最后的结果是diff = a^b, a和b为两个出现一次的数. diff的每一位为1的位就表明a和b在这一位上不同. 然后执行diff = diff &amp; (-diff). 这一步是为了求出diff从右到左第一个不是0的位.</p>
<p>例如, diff = 14 = 0b1110. 那么经过运算后diff = 0b010. 即从右到左第一个不是0的是第2位.</p>
<p>那么, 重点来了, <strong>a和b其中必有一个第二位是1, 另一个第二位是0!</strong></p>
<p>所以可以根据这个条件, 和diff做与运算为0的放一类, 和diff做与运算为1的放一类, 这样, a和b一定会在不同的类里面!!</p>
<p>再异或即可.</p>
<p>想出这个方法的人真的是天才!!!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">            xor ^= i;</span><br><span class="line">        <span class="keyword">int</span> diff = xor &amp; (-xor);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">            <span class="keyword">if</span>((i &amp; diff) != <span class="number">0</span>)</span><br><span class="line">                a ^= i;</span><br><span class="line">        <span class="keyword">int</span> b = xor ^ a;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 28 Implement Strstr</title>
    <url>/2020/07/19/Leetcode/Leetcode%2028%20Implement%20Strstr/</url>
    <content><![CDATA[<p>Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/">strStr()</a>.</p>
<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p><strong>Clarification:</strong></p>
<p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a>.</p>
<a id="more"></a>
<h2 id="1-调用c-string-find"><a href="#1-调用c-string-find" class="headerlink" title="1 调用c++ string::find"></a>1 调用c++ string::find</h2><p>注意当返回值为<code>string::npos</code>时返回-1即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a =  haystack.<span class="built_in">find</span>(needle);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="built_in">string</span>::npos)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-KMP算法"><a href="#2-KMP算法" class="headerlink" title="2 KMP算法"></a>2 KMP算法</h2><p>假设i为被查找字符串的指针，j为pattern的指针</p>
<p>kmp算法的关键在于如何求得数组next，其中next[i] 表示 pattern中从0到i的子数组中最大相同前后缀的长度</p>
<p>例如 pattern= “abcabcd”的next数组为[0,0,0,1,2,3,0]</p>
<p>next[3] = 1 因为 next[0]到next[3]中最大相同前后缀长度为1 <del>a</del>bc<del>a</del></p>
<p>next[4] = 2 因为 next[0]到next[4]最大相同前后缀长度为2 <del>ab</del>c<del>ab</del></p>
<p>next[5] = 3 因为 next[0]到next[5]最大相同前后缀长度为3 <del>abc</del> <del>abc</del></p>
<p>next[6] = 0 因为next[0]到next[6] 没有公共的前后缀 </p>
<p>对于任意的pattern，只要构造出next数组，就可以很容易的使用kmp算法（如何递推的构造next见下文）</p>
<p>在字符串str <code>abcabcabcd</code> 中查找pattern <code>abcabcd</code> ，对于<code>str[i] == pattern[j]</code>的情况，同时自加i和j，当查找到<code>str[i] ！= pattern[j]</code>的时候，i指针不动，j指针减为next[j-1]继续查找</p>
<blockquote>
<p>abcabc<strong>a</strong>bcd       若第i个元素不同，则指针i不动，指针j回退到next[j-1] </p>
<p>abcabc**d **             此例中i仍然指向str中第二个a，j回退到pattern的第3个元素</p>
</blockquote>
<blockquote>
<p>abcabc<strong>a</strong>bcd 此时直接从pattern第3个元素开始比较，至于前三个元素不用比较也能判断相等，next的性质使得这样的移动是安全的</p>
<p>​      abc<strong>a</strong>bcd       j此时变为3，</p>
</blockquote>
<p>下面还有一个问题，如此一来，pattern相对str向右偏移了3位，那么相对于暴力解法少了下面两种检查的情况，会不会落下这两种可能的解？</p>
<blockquote>
<p>　a<strong>b</strong>cabcabcd      ab<strong>c</strong>abcabcd</p>
<p>​      <strong>a</strong>bcabcd   　　　<strong>a</strong>bcabcd</p>
</blockquote>
<p>事实上，中间少比较的两种情况也不可能是问题的解（可以证明，如果pattern前j -1位如果和str匹配，并且错后1位也匹配的话，那么前j-1位肯定是全一个相同的字符，如果是错后2位后也完全相同，那么前j-1位肯定是全是一个包含单一的2位子字符串的字符串e.g. “ababababa”，而这样的字符串向右偏移与str配对时偏移量必然小于等于2，因此不可能错后大于2位）</p>
<p>以上证明了kmp算法的正确性，下面描述如何求next数组</p>
<p>递推的求next，假如next[k - 1]已知，求next[k] 。</p>
<p>以下将字符串pattern简写为P</p>
<p>假设next[k-1] = j，这也就意味着 (P[0],…,P[j-1]) == (P[k-j],…,P[k-1])，最理想的情况是P[k] == P[j]，那这样显然next[k] = j+1</p>
<h4 id="下面是递推求next数组的精髓所在，也是kmp算法最大的难点"><a href="#下面是递推求next数组的精髓所在，也是kmp算法最大的难点" class="headerlink" title="下面是递推求next数组的精髓所在，也是kmp算法最大的难点"></a><strong>下面是递推求next数组的精髓所在，也是kmp算法最大的难点</strong></h4><p>如果P[k] ！= P[j]，那么就意味着next[k] &lt;= next[k - 1] ，相同的前后缀只能从(P[0],…,P[j-1])的子序列中找，则需要找到长度更短的长度s，使得**(P[0],…,P[s-1]) == (P[k-s],…,P[k-1])** , 并且希望P[k] == P[s]。</p>
<p>根据我们假设的条件 (P[0],…,P[j-1]) == (P[k-j],…,P[k-1])，那么取一下子序列，必然有**(P[j - s],…,P[j-1]) == (P[k-s],…,P[k-1])**</p>
<p>所以根据两个加粗的等式，我们得到**(P[0],…,P[s-1]) == (P[j - s],…,P[j-1])**</p>
<p><strong>这个式子说明了对于数组(P[0],…,P[j - 1])，有长度为s的公共前后缀！</strong></p>
<p>所以 **s=next[j - 1]**，对应代码中的<code>len = next[len - 1];</code>,但是这并没有保证公共前后缀的最后一个元素P[s]和P[k]相等，所以要递归的带入s = next[s - 1],直到最后一个元素P[s]和P[k]相等。同时注意s==0时跳出循环，可以直接判断P[s]和P[k]是否相等得到next[k]为0还是1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> KMPfind(haystack,needle);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getNext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(P.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(P.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    next.front() = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; P.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span> &amp;&amp; P[i] != P[len])</span><br><span class="line">        &#123;</span><br><span class="line">            len = next[len - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(P[i] == P[len])</span><br><span class="line">        &#123;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPfind</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pattern.<span class="built_in">size</span>() &gt; str.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pattern.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//str index</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">//pattern index</span></span><br><span class="line">    <span class="keyword">auto</span> next = getNext(pattern);</span><br><span class="line">    <span class="keyword">while</span>(i &lt; str.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == pattern[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == pattern.<span class="built_in">size</span>()) <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 283 Move Zeroes</title>
    <url>/2020/07/24/Leetcode/Leetcode%20283%20Move%20Zeroes/</url>
    <content><![CDATA[<p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>:</p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>构造指针i，k，指针i向前读取nums的元素，当读取的元素不为0时，添加到k指向的空间中，并且k &lt;- k + 1，当i遍历完之后，在数组末尾(k到nums.size() - 1)补上0就可以了，时间复杂度为O(n)，空间为O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">            nums[k++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 27 Remove Element</title>
    <url>/2020/07/16/Leetcode/Leetcode%2027%20Remove%20Element/</url>
    <content><![CDATA[<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="双指针1"><a href="#双指针1" class="headerlink" title="双指针1"></a>双指针1</h2><p>指针i维护不是val的数组元素, 指针j遍历数组判断值是否为val,如果不是就添加到数组前部i维护的子数组中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">size</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i++] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样, 需要做size- s次交换(s为数组中等于val的元素个数)。如果数组中等于val的值较少，效率低</p>
<h2 id="双指针2"><a href="#双指针2" class="headerlink" title="双指针2"></a>双指针2</h2><p>这次，指针j从数组结尾开始遍历，指针i从数组头部记录。</p>
<p>i开始遍历，当nums[i] == val 时，用尾部的值替换nums[i]，同时j自减, nums[i] = nums[–j]。再次判断新的nums[i]是否等于val</p>
<p>当i&gt;=j时停止。（注意nums[j]不是最后一个元素，nums[j-1]是）</p>
<p>这样只需要进行交换s次(s为数组中等于val的元素个数) 如果数组中等于val的值较少，效率高</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[--j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 3 Longest Substring Without Repeating Characters</title>
    <url>/2020/09/21/Leetcode/Leetcode%203%20Longest%20Substring%20Without%20Repeating%20Characters/</url>
    <content><![CDATA[<p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br><span class="line">Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>
</ul>
<a id="more"></a>
<h2 id="滑动窗口-hashmap"><a href="#滑动窗口-hashmap" class="headerlink" title="滑动窗口 + hashmap"></a>滑动窗口 + hashmap</h2><p>窗口边界为begin, end</p>
<p>维护一个hashmap, 储存着对应着从s[begin]到s[end]中所有字符及其在字符串中的位置</p>
<p>对于一个将要进入hashmap中的元素s[end+1], 检查hashmap中是否有这个字符, 如果没有, 将其插入到hashmap中, 并更新hashmap大小和更新end=end+1</p>
<p>如果hashmap中有s[end+1]这个值, 查找这个值出现的位置duplicateLocation, 然后移除掉hashmap中所有从s[begin]到s[duplicateLocation]的值, 最后更改begin = duplicateLocation + 1</p>
<p>时间复杂度 O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span> != s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(s[<span class="built_in">end</span>]);</span><br><span class="line">            <span class="keyword">if</span>(it == mp.<span class="built_in">end</span>()) <span class="comment">// s[end] not in map</span></span><br><span class="line">            &#123;</span><br><span class="line">                mp.insert(&#123;s[<span class="built_in">end</span>],<span class="built_in">end</span>&#125;);</span><br><span class="line">                ++<span class="built_in">end</span>;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(<span class="built_in">end</span> - <span class="built_in">begin</span>, maxLen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> duplicateLocation = it-&gt;second;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt;= duplicateLocation; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    mp.erase(mp.<span class="built_in">find</span>(s[i]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">begin</span> = duplicateLocation + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 289 Game Of Life</title>
    <url>/2020/08/15/Leetcode/Leetcode%20289%20Game%20Of%20Life/</url>
    <content><![CDATA[<p>According to the <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life">Wikipedia’s article</a>: “The <strong>Game of Life</strong>, also known simply as <strong>Life</strong>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p>
<p>Given a <em>board</em> with <em>m</em> by <em>n</em> cells, each cell has an initial state <em>live</em> (1) or <em>dead</em> (0). Each cell interacts with its <a href="https://en.wikipedia.org/wiki/Moore_neighborhood">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<ol>
<li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li>
<li>Any live cell with two or three live neighbors lives on to the next generation.</li>
<li>Any live cell with more than three live neighbors dies, as if by over-population..</li>
<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>
</ol>
<p>Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up</strong>:</p>
<ol>
<li>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.</li>
<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</li>
</ol>
<a id="more"></a>
<h2 id="数组原地修改"><a href="#数组原地修改" class="headerlink" title="数组原地修改"></a>数组原地修改</h2><p>虽然题目长, 但是真心不难. </p>
<p>就是要原地记录下每个cell下一个时刻的状态, 并且不能覆盖当前的状态(因为算后面的cell的状态需要用到这个cell当前的状态)</p>
<p>既然只有0和1, 并且是int数组而不是bool数组, 所以可以在每个int中增加信息量</p>
<p>用二进制表示, 若下一个state变为dead, 就在最高位标记为1, 若下一个state变为alive 则在中间位标记为1, 最后一位仍然是当前的状态不变. </p>
<blockquote>
<p>例如, 现状态为1, 下一个状态死(101). 现状态为0, 下一个状态活(011)</p>
</blockquote>
<p>而从标记的值中提取现状态的值只需要 <code>a = a &amp; 1</code>即可.</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.front().<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> aliveNeighbors = getAliveNeighbors(board, i, j);</span><br><span class="line">                <span class="keyword">if</span>(isCurrentAlive(board[i][j]) &amp;&amp; aliveNeighbors &lt; <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = markDead(board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(isCurrentAlive(board[i][j]) &amp;&amp; (aliveNeighbors == <span class="number">2</span> || aliveNeighbors == <span class="number">3</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = board[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(isCurrentAlive(board[i][j]) &amp;&amp; aliveNeighbors &gt; <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = markDead(board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!isCurrentAlive(board[i][j]) &amp;&amp; aliveNeighbors == <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = markAlive(board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.front().<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(willDie(board[i][j]))</span><br><span class="line">                    board[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(willAlive(board[i][j]))</span><br><span class="line">                    board[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nowAliveMark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nextAliveMark = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nextDeadMark = <span class="number">4</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">markDead</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a | nextDeadMark;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">markAlive</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a | nextAliveMark;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCurrentAlive</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &amp; nowAliveMark; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">willDie</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &amp; nextDeadMark;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">willAlive</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &amp; nextAliveMark;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLocationValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m &gt; <span class="number">-1</span> &amp;&amp; m &lt; board.<span class="built_in">size</span>() &amp;&amp; n &gt; <span class="number">-1</span> &amp;&amp; n &lt; board.front().<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAliveNeighbors</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aliveNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx = &#123;<span class="number">0</span>, <span class="number">0</span>,<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy = &#123;<span class="number">1</span>,<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,<span class="number">-1</span>, <span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dx.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isLocationValid(board,m + dx[i], n + dy[i]) &amp;&amp; isCurrentAlive(board[m+dx[i]][n+dy[i]]))</span><br><span class="line">                ++aliveNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aliveNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 32 Longest Valid Parentheses</title>
    <url>/2020/09/30/Leetcode/Leetcode%2032%20Longest%20Valid%20Parentheses/</url>
    <content><![CDATA[<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()()&quot;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1 暴力"></a>1 暴力</h2><p>对于给定的i, 维护两个变量, left为左括号的数量, right为右括号的数量.</p>
<p>如果对于某个j, 从i到j的右括号数量大于左括号数量, 那么(i,j), (i, j+1), (i, j+2)….这些字串肯定不可能valid.</p>
<p>如果对于某个j, 从i到j的右括号数量等于左括号数量, 那么(i,j)就是valid, 更新maxLen = Math.max(left + right, maxLen);即可.</p>
<p>但是这种方法慢, 复杂度O(n^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.length(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    ++left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(j) == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                    ++right;</span><br><span class="line">                <span class="keyword">if</span>(right &gt; left)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(left == right)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxLen = Math.max(left + right, maxLen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-改进的括号判断"><a href="#2-改进的括号判断" class="headerlink" title="2 改进的括号判断"></a>2 改进的括号判断</h2><p>我们知道, 当从左到右遍历的时候, 如果右括号数量大于左括号数量, 后面无论括号是什么, 都不可能是一个合法的括号.</p>
<p>所以, i从0遍历到length - 1, 每遍历到一个括号, 都统计当前左右括号的数量. </p>
<p>如果left &lt; right, 那么当前的字串肯定不可能成为valid了, 需要从s[i]后面重新统计. 所以要重新赋值<code>left=right=0</code></p>
<p>如果left = right, 那么当前的字串是valid的, 更新maxLen = right * 2.</p>
<p>例如, <code>())()()</code></p>
<p>当遍历到第2个字符时, left = right = 1, 所以更新maxLen = 2;</p>
<p>当遍历到第3个字符时, left = 1, right =2, right &gt; left, 所以<code>left=right=0</code>, 之前的合法括号<code>()</code>由于此次中断不能加入到后面的计算中.</p>
<p>但是这样做有个问题. 考虑<code>()(()()</code>, 一直有left &gt; right, 导致遍历结束了还没有出现left == right, 自然不能更新maxLen. </p>
<p>解决的方法是, 从右往左再遍历一遍, 判断方式和刚才的相反, 时刻保持右括号的数量大于左括号的数量.</p>
<p>取两次遍历结果的最大值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++right;</span><br><span class="line">            <span class="keyword">if</span>(right &gt; left)</span><br><span class="line">            &#123;</span><br><span class="line">                right = <span class="number">0</span>;</span><br><span class="line">                left = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right == left)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLen = Math.max(maxLen, <span class="number">2</span> * right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt; -<span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                ++left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++right;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                right = <span class="number">0</span>;</span><br><span class="line">                left = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right == left)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLen = Math.max(maxLen, <span class="number">2</span> * right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3 动态规划"></a>3 动态规划</h2><p>参考于<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/">https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    dp[i] = (i &gt; <span class="number">1</span>) ? dp[i-<span class="number">2</span>] + <span class="number">2</span> : <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = i - <span class="number">1</span> - dp[i-<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(tmp &gt;= <span class="number">0</span> &amp;&amp; s.charAt(tmp) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span> + ((tmp-<span class="number">1</span> &gt; <span class="number">0</span>) ? dp[tmp-<span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : dp)</span><br><span class="line">            max = Math.max(max,i);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 29 Divide Two Integers</title>
    <url>/2020/09/25/Leetcode/Leetcode%2029%20Divide%20Two%20Integers/</url>
    <content><![CDATA[<p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers without using multiplication, division and mod operator.</p>
<p>Return the quotient after dividing <code>dividend</code> by <code>divisor</code>.</p>
<p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>truncate(8.345) = 8</code> and <code>truncate(-2.7335) = -2</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 10&#x2F;3 &#x3D; truncate(3.33333..) &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">Output: -2</span><br><span class="line">Explanation: 7&#x2F;-3 &#x3D; truncate(-2.33333..) &#x3D; -2.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>Both dividend and divisor will be 32-bit signed integers.</li>
<li>The divisor will never be 0.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function <strong>returns 231 − 1 when the division result overflows</strong>.</li>
</ul>
<a id="more"></a>
<h2 id="1-暴力除法"><a href="#1-暴力除法" class="headerlink" title="1 暴力除法"></a>1 暴力除法</h2><p>首先记录下来结果的正负isNegative, 然后把dividend和divisor全部转为相应的负数. (至于为什么不转换成正数, 因为Integer.MIN_VALUE的绝对值是比Integer.MAX_VALUE大1的, 转成正数麻烦)</p>
<p>然后dividend不断地去减divisor(每减一次ans加1), 直到dividend &gt; divisor为止. 再根据结果的正负添加ans的正负即可.</p>
<p>但是, 如果dividend很大, divisor很小, 非常慢!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">if</span>(dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = (dividend &lt; <span class="number">0</span>) &amp;&amp; (divisor &gt; <span class="number">0</span>) || (dividend &gt; <span class="number">0</span>) &amp;&amp; (divisor &lt; <span class="number">0</span>);</span><br><span class="line">        dividend = (dividend &lt; <span class="number">0</span>) ? dividend : -dividend;</span><br><span class="line">        divisor = (divisor &lt; <span class="number">0</span>) ? divisor : -divisor;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dividend &lt;= divisor)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            dividend -= divisor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2 位运算"></a>2 位运算</h2><p><strong>这题的位运算超难! 思路倒是不难, 难的是各种边界条件!</strong></p>
<p>首先要把所有数转换为正数, 负数的位运算更难!!!</p>
<p><code>divisor_</code>和<code>dividend_</code>均为取正数的long类型, <code>abs_dividend</code>和<code>abs_divisor</code>同理(下面假设dividend和divisor均为正数)</p>
<p>然后将<code>divisor_</code>左移k位, 直到<code>divisor_</code>刚好大于<code>dividend_</code>.</p>
<p>此时, –k, 并且让<code>dividend_</code>除以<code>divisor_</code>, 得到一个商div, 说明<code>dividend_</code>里至少有<code>div * power(2,k)</code>个<code>divisor</code>. 所以更新<code>ans += div * power(2,k)</code> , 更新<code>dividend_ -= div * power(2,k) * divisor</code>. 依次循环, 直到<code>dividend_ &lt; divisor</code>或者<code>divisor_ &lt; divisor </code>.</p>
<p><code>divisor_ &lt; divisor </code> 是保证<code>divisor_</code>在右移的过程中不要小于divisor.</p>
<p>举个例子说明</p>
<blockquote>
<p>dividend = 10 divisor = 3</p>
<p>首先左移divisor直到大于10, 此时k = 2, <code>divisor_ = 12</code></p>
<p>然后右移<code>divisor_ = 6</code>, <code>k = 1</code></p>
<p>这时, 10 里面有1个6, <code>div = 1</code>, 所以 <code>ans += 1 * power(2, 1)</code>, <code>dividend_ -= 1 * power(2, 1) * 3</code> (ans = 2, dividend_ = 10 - 6 = 4)</p>
<p>这时<code>dividend_</code>仍然大于等于divisor, 所以继续进入while</p>
<p>右移<code>divisor_ = 3</code>, k = 0,</p>
<p>这时, 4 里面有1个3, <code>div = 1</code>, 所以 <code>ans += 1 * power(2, 0)</code>, <code>dividend_ -= 1 * power(2, 0) * 3</code> (ans = 3, dividend_ = 4 - 3 = 1)</p>
<p>此时, <code>dividend_ &lt; divisor</code>, 返回ans为3.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">if</span>(dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = (dividend &lt; <span class="number">0</span>) &amp;&amp; (divisor &gt; <span class="number">0</span>) || (dividend &gt; <span class="number">0</span>) &amp;&amp; (divisor &lt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//use long to avoid overflow e.g. (-3 &lt;&lt; 31) will be 1073741824</span></span><br><span class="line">        <span class="keyword">long</span> dividend_ = (dividend &lt; <span class="number">0</span>) ? -(<span class="keyword">long</span>)dividend : (<span class="keyword">long</span>)dividend;</span><br><span class="line">        <span class="keyword">long</span> divisor_ = (divisor &lt; <span class="number">0</span>) ? -(<span class="keyword">long</span>)divisor : (<span class="keyword">long</span>)divisor;</span><br><span class="line">        <span class="keyword">long</span> abs_dividend = dividend_;</span><br><span class="line">        <span class="keyword">long</span> abs_divisor = divisor_;</span><br><span class="line">        <span class="keyword">if</span>(dividend_ &lt; divisor_)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(divisor_ &lt;= dividend_)</span><br><span class="line">        &#123;</span><br><span class="line">            divisor_ = divisor_ &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dividend_);</span><br><span class="line">        System.out.println(divisor_);</span><br><span class="line">        <span class="keyword">while</span>(dividend_ &gt;= abs_divisor &amp;&amp; divisor_ &gt;= abs_divisor)</span><br><span class="line">        &#123;</span><br><span class="line">            divisor_ = divisor_ &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            --k;</span><br><span class="line">            <span class="keyword">int</span> div = div(dividend_, divisor_);</span><br><span class="line">            ans += div &lt;&lt; k;  <span class="comment">//div * power(2,k);</span></span><br><span class="line">            dividend_ -= multiply((div &lt;&lt; k) , abs_divisor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//a and b are both positive.</span></span><br><span class="line">        <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a == b || a &lt; b + b)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">multiply</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> tmp = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; b; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 322 Coin Change</title>
    <url>/2020/11/06/Leetcode/Leetcode%20322%20Coin%20Change/</url>
    <content><![CDATA[<p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coins &#x3D; [1,2,5], amount &#x3D; 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coins &#x3D; [1], amount &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coins &#x3D; [1], amount &#x3D; 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: coins &#x3D; [1], amount &#x3D; 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 104</code></li>
</ul>
<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>回溯是肯定不行的, 太慢了.如果碰到这样的用例, coins = [1,100], amount = 10000就惨了.</p>
<p>首先创建一个dp数组<code>int[] dp = new int[amount + 1];</code></p>
<p><code>dp[i]</code>表示组成<code>amount</code> 为 <code>i</code>的所用最少硬币数. 初始时数组全部为-1.</p>
<p>首先,  边界条件是<code>dp[0] = 0</code></p>
<p>对于<code>dp[i]</code>, 想要找到组成i所需要的最小硬币数, 假设最后一个组成i的硬币为j, 那么通过j组成i的硬币数就为<code>dp[i - j] + 1</code>. 前提是<code>i - j &gt; 0</code>并且<code>dp[i - j] != -1</code>.</p>
<p>对于在coins中的所有满足上述条件的j, 选取一个使得<code>dp[i - j] + 1</code>最小的j, 即为<code>dp[i]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; ++i)</span><br><span class="line">            dp[i] = -<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> minCoins = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j : coins)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = i - j;</span><br><span class="line">                <span class="keyword">if</span>(tmp &lt; <span class="number">0</span> || dp[tmp] == -<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> currCoins = dp[tmp] + <span class="number">1</span>;</span><br><span class="line">                    minCoins = Math.min(minCoins, currCoins);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = minCoins == Integer.MAX_VALUE ? -<span class="number">1</span> : minCoins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 303 Range Sum Query Immutable</title>
    <url>/2020/11/06/Leetcode/Leetcode%20303%20Range%20Sum%20Query%20Immutable/</url>
    <content><![CDATA[<p>Given an integer array <code>nums</code>, find the sum of the elements between indices <code>i</code> and <code>j</code> <code>(i ≤ j)</code>, inclusive.</p>
<p>Implement the <code>NumArray</code> class:</p>
<ul>
<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>
<li><code>int sumRange(int i, int j)</code> Return the sum of the elements of the <code>nums</code> array in the range <code>[i, j]</code> inclusive (i.e., <code>sum(nums[i], nums[i + 1], ... , nums[j])</code>)</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">Output</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)</span><br><span class="line">numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1)) </span><br><span class="line">numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 104</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
<li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li>
<li>At most <code>104</code> calls will be made to <code>sumRange</code>.</li>
</ul>
<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>储存一个数组<code>accumulateSums</code>, 保存从0到i的和. 计算的时候通过<code>accumulateSums</code>来返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] accumulateSums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        accumulateSums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != nums.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            accumulateSums[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;indexException&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> accumulateSums[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> accumulateSums[j] - accumulateSums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 31 Next Permutation</title>
    <url>/2020/09/26/Leetcode/Leetcode%2031%20Next%20Permutation/</url>
    <content><![CDATA[<p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be <strong><a href="http://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3&#96; → &#96;1,3,2&#96;</span><br><span class="line">&#96;3,2,1&#96; → &#96;1,2,3&#96;</span><br><span class="line">&#96;1,1,5&#96; → &#96;1,5,1</span><br></pre></td></tr></table></figure>



<a id="more"></a>
<h2 id="寻找数组最后的几个递减的元素"><a href="#寻找数组最后的几个递减的元素" class="headerlink" title="寻找数组最后的几个递减的元素"></a>寻找数组最后的几个递减的元素</h2><p>最大的排列是满足降序<br>最小的排列是满足升序<br>因此寻找后一个排列的操作是:</p>
<pre><code>1. 从后遍历，寻找第一个升序的数，即 nums[k - 1] &lt; nums[k]
    2. 在[k, end]中寻找比nums[k - 1]大的最小值
    3. 交换第二步找到的最小值和nums[k - 1]
    4. 将[k, end]中的内容reverse, 因为之前[k, end]中的内容是满足降序的，如果不reverse就不是紧挨着的下一个排列了。</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &gt; <span class="number">0</span> &amp;&amp; nums[index] &lt;= nums[index - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> isDescending = (index == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(isDescending)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//use reverse iterator reverse the descending array</span></span><br><span class="line">            reverse(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> first_descend_element = nums[index - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">begin</span> = index;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> upper = descUpperBound(nums,<span class="built_in">begin</span>,<span class="built_in">end</span>,first_descend_element);</span><br><span class="line">            swap(nums[index - <span class="number">1</span>],nums[upper]);</span><br><span class="line"></span><br><span class="line">            reverse(nums.<span class="built_in">begin</span>()+<span class="built_in">begin</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">descUpperBound</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 328 Odd Even Linked List</title>
    <url>/2020/10/28/Leetcode/Leetcode%20328%20Odd%20Even%20Linked%20List/</url>
    <content><![CDATA[<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span><br><span class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The relative order inside both the even and odd groups should remain as it was in the input.</li>
<li>The first node is considered odd, the second node even and so on …</li>
<li>The length of the linked list is between <code>[0, 10^4]</code>.</li>
</ul>
<a id="more"></a>
<h2 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h2><p>不知道这题为什么定位为medium. 直接把偶数位置的节点截取下来组成一个新的链表然后接在原链表后面就可以了嘛</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode evenHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode tail = evenHead;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode i = head; i != <span class="keyword">null</span>; i = i.next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ListNode even = i.next;</span><br><span class="line">            i.next = i.next.next;</span><br><span class="line">            even.next = <span class="keyword">null</span>;</span><br><span class="line">            tail.next = even;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            prev = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prev.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = evenHead.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 326 Power Of Three</title>
    <url>/2020/10/16/Leetcode/Leetcode%20326%20Power%20Of%20Three/</url>
    <content><![CDATA[<p>Given an integer, write a function to determine if it is a power of three.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 27</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 0</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 45</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong><br>Could you do it without using any loop / recursion?</p>
<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1 暴力"></a>1 暴力</h2><p>对于所有的小于n的3的幂, 挨个试一试.</p>
<p>注意, 为了防止溢出, 要把a设置为long类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a == n)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            a *= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-网上的答案"><a href="#2-网上的答案" class="headerlink" title="2 网上的答案"></a>2 网上的答案</h2><p>看了几个网上的答案, 感觉也都不是太好.</p>
<p>有利用<code>Integer.toString(number, base)</code>转化为3进制然后再用正则表达式判断字符串是不是<code>100000...000</code>这样的. 但问题是这个方法里面也用到了循环.</p>
<p>也有直接取对数的. 看看log_{3}(n)是不是整数. 但是double转int有可能会损失精度. 除非设置一个epsilon.</p>
<p>最好的方法是这种, <a href="https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode/">https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode/</a></p>
<p>因为n最大就是INT_MAX, 而且还有一半的负数, 所以这些数里面最大的就是3^19. </p>
<p>用3^19来模n, 如果余数为0, 证明n是3的幂 </p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 33 Search In Rotated Sorted Array</title>
    <url>/2020/07/18/Leetcode/Leetcode%2033%20Search%20In%20Rotated%20Sorted%20Array/</url>
    <content><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="改进的二分查找"><a href="#改进的二分查找" class="headerlink" title="改进的二分查找"></a>改进的二分查找</h2><p>注意到,虽然被rotated了,但是仍然有这样的结构, nums = [a1,a2,a3,….,an,b1,b2,…bm],其中b1&lt;b2&lt;…&lt;bm&lt;a1&lt;a2&lt;…&lt;an。可以利用这样的结构完成二分查找</p>
<p>储存两个变量front和back记录数组第一个和最后一个值</p>
<p>两个变量 i，j记录数组左右端点</p>
<p>先计算mid和mid位置(位于子数组ai还是子数组bi)</p>
<ul>
<li>假如mid&gt;front，即mid位于数组ai中，nums=[a1,a2,a3,….,mid…,an,b1,b2,…bm]，</li>
</ul>
<blockquote>
<ul>
<li><p>假如target比nums[mid]大或比back小, 那么target肯定在mid右边，右边的数组仍然是一个rotatedArray，这时改变左右端点为右边的子数组的端点(mid+1, j)，改变front和back，递归的使用相同的步骤进行二分查找（这里要注意更新完左右端点i,j后要检查是否i&lt;=j，否则更新front=nums[i]容易下标溢出）</p>
</li>
<li><p>而当target大于front小于nums[mid]时，那么target肯定在mid左边, 而mid又在子数组ai中，所以mid左边的数组是没有rotated的。此时用普通的二分查找得到结果即可</p>
</li>
</ul>
</blockquote>
<ul>
<li>假如mid&lt;front，即mid位于数组bn中，nums=[a1,a2,a3,….,an,b1,b2,…,mid,…,bm]</li>
</ul>
<blockquote>
<ul>
<li>假如target比nums[mid]小或比back大，那么target肯定在mid左边，左边的数组仍然是一个rotatedArray，这是改变左右端点为左边子数组端点(i,mid - 1), 改变front和back，使用相同的步骤查找（也要注意改变back时下标溢出）</li>
<li>而当target比num[mid]大或比back小，那么target肯定在mid右边，右边的数组是没有rotated的，二分查找即可。</li>
</ul>
</blockquote>
<p>此题关键在于二分之后的左半数组和右半数组一定有一个是有序的.</p>
<p>总时间复杂度仍然为O(log n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">bool</span> isRotated = (nums.front() &gt; nums.back());</span><br><span class="line">        <span class="keyword">if</span>(!isRotated)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> regularBinarySearch(nums, target, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> front = nums.front();</span><br><span class="line">            <span class="keyword">int</span> back = nums.back();</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">bool</span> midInLeft = (nums[mid] &gt;= front);</span><br><span class="line">                <span class="keyword">if</span>(midInLeft)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target &gt;= front &amp;&amp; target &lt;= nums[mid])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> regularBinarySearch(nums, target, i, mid - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        i = mid + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i &gt; j) <span class="keyword">break</span>;  <span class="comment">//if not break nums[i] may be illegal address</span></span><br><span class="line">                        front = nums[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;= back)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> regularBinarySearch(nums, target, mid + <span class="number">1</span>, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        j = mid - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(j &lt; i) <span class="keyword">break</span>;  <span class="comment">//if not break nums[j] may be illegal address</span></span><br><span class="line">                        back = nums[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">regularBinarySearch</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 338 Counting Bits</title>
    <url>/2020/10/22/Leetcode/Leetcode%20338%20Counting%20Bits/</url>
    <content><![CDATA[<p>Given a non negative integer number <strong>num</strong>. For every numbers <strong>i</strong> in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [0,1,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<ul>
<li>It is very easy to come up with a solution with run time <strong>O(n*sizeof(integer))</strong>. But can you do it in linear time <strong>O(n)</strong> /possibly in a single pass?</li>
<li>Space complexity should be <strong>O(n)</strong>.</li>
<li>Can you do it like a boss? Do it without using any builtin function like <strong>__builtin_popcount</strong> in c++ or in any other language.</li>
</ul>
<a id="more"></a>
<h2 id="1-计算末尾1的个数"><a href="#1-计算末尾1的个数" class="headerlink" title="1 计算末尾1的个数"></a>1 计算末尾1的个数</h2><p>首先, 如果对于一个数i, 末尾没有1, 那么i+1的1的个数就为i中1的个数+1. 例如 1110 -&gt; 1111</p>
<p>如果i末尾有连续的j个1, 那么i+1就要将这个j个1都进位成0, 并且在第j+1位上置为1. 所以会比i的1个个数少j - 1个. 例如, 末尾有3个连续的1, 10111 -&gt; 11000. 那么i+1就会比i中1的个数少3 - 1个</p>
<p>对于这种的时间复杂度, 主要集中在计算末尾1的个数.</p>
<p>我们设末尾有0个1, 需要花费1个时间.</p>
<p>末尾有1个1, 需要花费2个时间</p>
<p>…..以此类推, 有n-1个1需要花费n个时间.</p>
<p>而从0到n中, 末尾有0个1的约有n/2个, 末尾有1个1的约为n/4个, …, 末尾有n-1个1的约有n/2^(n)个</p>
<p>所以总时间为 Σ_{n = 1}^{∞} n * (1/2)^n</p>
<p>复杂度约为O(2n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = num;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> iprev1 = getSuffix1(i - <span class="number">1</span>);</span><br><span class="line">            ans[i] = (iprev1 == <span class="number">0</span>) ? (ans[i-<span class="number">1</span>] + <span class="number">1</span>) : (ans[i-<span class="number">1</span>] - iprev1 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSuffix1</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((i &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            i = i &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-除2"><a href="#2-除2" class="headerlink" title="2 除2"></a>2 除2</h2><p>这个方法更简单, 但我没想到. 唉, 还是菜</p>
<p>假如i是偶数, 那么i中1的个数和i/2中1的个数肯定一样,</p>
<p>假如i是奇数, 那么i中1的个数等于i/2中1的个数加1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = num;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] = ((i &amp; <span class="number">1</span>) == <span class="number">0</span>) ? ans[i &gt;&gt;&gt; <span class="number">1</span>] : ans[i &gt;&gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 337 House Robber III</title>
    <url>/2020/10/26/Leetcode/Leetcode%20337%20House%20Robber%20III/</url>
    <content><![CDATA[<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">Output: 7 </span><br><span class="line">Explanation: Maximum amount of money the thief can rob &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">Output: 9</span><br><span class="line">Explanation: Maximum amount of money the thief can rob &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1 动态规划"></a>1 动态规划</h2><p>首先这题递归肯定是能做的. 动态规划的思想也是从递归来的. </p>
<blockquote>
<p>递归: 记f<code>(root)</code>为以root作为根节点的子树全部抢劫的最大金额. 那么对于root来说, 可以抢root, 那么就不能抢<code>root-&gt;left</code>和<code>root-&gt;right</code>了, 只能从<code>root-&gt;left-&gt;left(right)</code>和<code>root-&gt;right-&gt;left(right)</code>来抢.</p>
<p>即 <code>robRootAndGrandchildren = root.val + f(root-&gt;left-&gt;left) + f(root-&gt;left-&gt;right) + f(root-&gt;right-&gt;left) + f(root-&gt;right-&gt;right)</code></p>
<p>也可以选择不抢root, 那么root-&gt;left和root-&gt;right对应的子树就随便抢了</p>
<p><code>robChildren = f(root-&gt;left) + f(root-&gt;right)</code></p>
<p>最后取两者最大值 <code>f(root) = max(robChildren, robRootAndGrandChildren)</code></p>
</blockquote>
<p>但是如果这样直接递归的话会有大量的重复计算. 例如, 计算<code>robRootAndGrandchildren</code>的时候会计算<code>f(root-&gt;left-&gt;left)</code>, 计算<code>robChildren</code>的时候由于要计算<code>f(root-&gt;left)</code>所以也会间接的计算<code>f(root-&gt;left-&gt;left)</code>.</p>
<p>需要用动态规划的思路, <strong>从底向上的计算</strong>, 并且把计算结果保存起来. 这时, 可以选择hashmap来做一个TreeNode到Integer的映射.</p>
<p>也可以在树上本身存储. 方法是, 树的某个节点Node的val域存储以Node作为根节点的子树所能抢劫的最大值.</p>
<p>这样, 再计算<code>f(root-&gt;right-&gt;right)</code>的时候就只需要获取<code>root-&gt;right-&gt;right-&gt;val</code>即可</p>
<p>我们用后序遍历, 因为这样可以保证孩子节点的抢劫最大值先于父节点计算. (计算父节点的抢劫最大值需要孩子节点和孙子节点的抢劫最大值)</p>
<p>用后序遍历一遍之后直接返回根节点的val即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber III.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        postTraverse(root);</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postTraverse</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        postTraverse(root.left);</span><br><span class="line">        postTraverse(root.right);</span><br><span class="line">        getMax(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getMax</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root.val = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sum of root&#x27;s children</span></span><br><span class="line">        <span class="keyword">int</span> childSum = ((root.left == <span class="keyword">null</span>) ? <span class="number">0</span> : root.left.val) + ((root.right == <span class="keyword">null</span>) ? <span class="number">0</span> : root.right.val);</span><br><span class="line">        <span class="comment">// sum of root&#x27;s grandchildren</span></span><br><span class="line">        <span class="keyword">int</span> grandchildSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            grandchildSum += (root.left.left == <span class="keyword">null</span>) ? <span class="number">0</span> : root.left.left.val;</span><br><span class="line">            grandchildSum += (root.left.right == <span class="keyword">null</span>) ? <span class="number">0</span> : root.left.right.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            grandchildSum += (root.right.left == <span class="keyword">null</span>) ? <span class="number">0</span> : root.right.left.val;</span><br><span class="line">            grandchildSum += (root.right.right == <span class="keyword">null</span>) ? <span class="number">0</span> : root.right.right.val;</span><br><span class="line">        &#125;</span><br><span class="line">        root.val = Math.max(childSum, root.val + grandchildSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-树形dp"><a href="#2-树形dp" class="headerlink" title="2 树形dp"></a>2 树形dp</h2><p>思路参考于<a href="https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/">https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/</a></p>
<p>现在再来研究一下递归为什么慢, 是因为在计算root的时候既用到了root的孩子, 又用到了root的孙子. 而计算root的孩子的时候还要计算root的孙子. 所以造成了大量的重复计算. 如果我们把root孙子的信息存储到root孩子上面, 那么计算root只需要root孩子, 就避免了重复计算.</p>
<p>举个例子, <code>f(n) = f(n-1) + f(n-2)</code>进行递归的时候, f(n-2)计算了两次. 一次是计算f(n)的时候计算的, 一次是计算f(n-1)的时候计算的. 复杂度自然为O(2^n)</p>
<p>如果我们把<code>f(n-1)</code>上添加<code>f(n-2)</code>的信息, 使得计算<code>f(n)</code>的时候不需要再计算一遍<code>f(n-2)</code>, 而是直接从<code>f(n-1)</code>中提取<code>f(n-2)</code>. 那么复杂度自然就变为O(n)了</p>
<blockquote>
<p><code>g(1) = [f(0), f(1)]</code></p>
<p>…</p>
<p><code>g(n-1) = [f(n-2), f(n-1)]</code></p>
<p><code>g(n) = [g(n-1)[1], g(n-1)[0] + g(n-1)[1]]</code></p>
<p>这样求<code>g(n)</code>只需要知道<code>g(n-1)</code></p>
</blockquote>
<p>弄懂上面例子的原理后, 我们就可以开始了.</p>
<p>也是创建一个二维数组. 对于节点node作为根节点对应的子树来说,</p>
<p>root[0]代表从两个儿子开始抢的最大值</p>
<p>root[1]表示从四个孙子开始抢的最大值, 加上抢root本身的钱</p>
<p>root作为根节点生成的子树最大的抢劫和即为<code>max(root[0], root[1])</code></p>
<p>最后返回这个二维数组<code>[root[0], root[1]]</code>. 而不是返回<code>max(root[0], root[1])</code>. <strong>否则计算root的父节点rootFather时, 如果抢劫策略是抢劫根节点rootFather并且从孙子开始抢, 还是需要计算他的孙子(即root的儿子)的抢劫和, 即root[0]. 又产生了重复计算</strong></p>
<p>计算root[0]和root[1]的时候, root0显然是等于左子树能抢的最大值 加上 右子树能抢的最大值. </p>
<p><code>ans[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);</code></p>
<p>对于root1, 即抢根节点加上四个孙子节点. 对于root的四个孙子节点的和, 就是root.left的两个儿子节点的和和root.right的两个儿子节点的和.</p>
<p><code>ans[1] = root.val + left[0] + right[0]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = rob0(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(ans[<span class="number">0</span>], ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rob0(TreeNode root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] left = rob0(root.left);</span><br><span class="line">        <span class="keyword">int</span> leftmax = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] right = rob0(root.right);</span><br><span class="line">        <span class="keyword">int</span> rightmax = Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = leftmax + rightmax;</span><br><span class="line">        ans[<span class="number">1</span>] = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 34 Find First And Last Position Of Element In Sorted Array</title>
    <url>/2020/07/18/Leetcode/Leetcode%2034%20Find%20First%20And%20Last%20Position%20Of%20Element%20In%20Sorted%20Array/</url>
    <content><![CDATA[<p>Given an array of integers <code>nums</code> sorted in ascending order, find the starting and ending position of a given <code>target</code> value.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>nums</code> is a non decreasing array.</li>
<li><code>-10^9 &lt;= target &lt;= 10^9</code></li>
</ul>
<a id="more"></a>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>题目等价于寻找第一个大于等于target的index left和最后一个小于等于target的index right</p>
<p>如果nums中没有target，则必有 left &gt; right，返回[-1, -1]即可</p>
<p>如果有target，则返回[left, right]即为所求</p>
<p>而寻找left和right用广义的二分查找即可解决</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums.front() || target &gt; nums.back())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = getLeftIndex(nums,target);</span><br><span class="line">        <span class="keyword">int</span> right = getRightIndex(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLeftIndex</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRightIndex</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 345 Reverse Vowels Of A String</title>
    <url>/2020/09/22/Leetcode/Leetcode%20345%20Reverse%20Vowels%20Of%20A%20String/</url>
    <content><![CDATA[<p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;hello&quot;</span><br><span class="line">Output: &quot;holle&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;leetcode&quot;</span><br><span class="line">Output: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p>
<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>两个指针left, right</p>
<p>首先使得left指向第1个vowel, right指向倒数第1个vowel, 然后交换他们.</p>
<p>再使得left指向第2个vowel, right指向倒数第2个vowel, 交换他们</p>
<p>直到 left &gt;= right</p>
<p>注意的细节是, 每一次找到left和right之后都要判断是否满足条件! 不能只在while循环写<code>while(left &lt; right)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &gt; left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; s.<span class="built_in">size</span>() &amp;&amp; !isVowels(s[left]))</span><br><span class="line">                ++left;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; <span class="number">-1</span> &amp;&amp; !isVowels(s[right]))</span><br><span class="line">                --right;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(s[left], s[right]);</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isVowels</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a = <span class="built_in">std</span>::<span class="built_in">tolower</span>(ch);</span><br><span class="line">        <span class="keyword">return</span> a == <span class="string">&#x27;a&#x27;</span> || a == <span class="string">&#x27;e&#x27;</span> || a == <span class="string">&#x27;i&#x27;</span> || a == <span class="string">&#x27;o&#x27;</span> || a == <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 347 Top K Frequent Elements</title>
    <url>/2020/11/06/Leetcode/Leetcode%20347%20Top%20K%20Frequent%20Elements/</url>
    <content><![CDATA[<p>Given a non-empty array of integers, return the <strong><em>k\</em></strong> most frequent elements.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li>
<li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li>
<li>It’s guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique.</li>
<li>You can return the answer in any order.</li>
</ul>
<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1. 暴力"></a>1. 暴力</h2><p>使用一个hashmap存储每个数字出现的次数, 按次数排序, 取前k个.</p>
<p>时间复杂度为O(max(n, m*logm)) 其中n为数组长度, m为数组中不同元素的总个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            map.putIfAbsent(i,<span class="number">0</span>);</span><br><span class="line">            map.put(i, map.get(i) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt;[] arr = (Map.Entry&lt;Integer, Integer&gt;[]) <span class="keyword">new</span> Map.Entry[map.size()];</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            arr[s++] = entry;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr, (entry1, entry2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> entry2.getValue() - entry1.getValue();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] = arr[i].getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-优先队列"><a href="#2-优先队列" class="headerlink" title="2. 优先队列"></a>2. 优先队列</h2><p>和1的思路差不多, 都要先用hashmap. 但是之后可以用优先队列完成选取前k个的操作. 时间复杂度可降为O(max(n, m*logk)) 其中n为数组长度, m为数组中不同元素的总个数.</p>
<p><strong>这里还想到了用快速排序的partition思想求的第k大的数, 可以将复杂度降为O(n). 但是这是行不通的. 因为需要求全部的第1大, 第2大, … 第k大. 而不是仅仅求出第k大的数就可以的.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            map.putIfAbsent(i,<span class="number">0</span>);</span><br><span class="line">            map.put(i, map.get(i) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((entry1, entry2) -&gt; entry1.getValue() - entry2.getValue());</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.offer(entry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Map.Entry&lt;Integer, Integer&gt; top = pq.peek();</span><br><span class="line">                <span class="keyword">if</span>(top.getValue() &lt; entry.getValue())</span><br><span class="line">                &#123;</span><br><span class="line">                    pq.poll();</span><br><span class="line">                    pq.offer(entry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : pq)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[s++] = entry.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-桶排序"><a href="#3-桶排序" class="headerlink" title="3.桶排序"></a>3.桶排序</h2><p><strong>因为待排序的值都在0到n这个范围内, 所以可以用桶排序.</strong> 复杂度O(n)</p>
<p>这也提醒了我们当排序的范围不大的时候, 可以用这种非比较排序算法.</p>
<p><strong>平常基本上不用桶排序, 所以很难想到这个方法. 所以还是要多练习, 多总结.</strong></p>
<p>再选取前k个即可. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt;[] bucket = (List&lt;Integer&gt;[]) <span class="keyword">new</span> List[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != bucket.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            bucket[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            bucket[entry.getValue()].add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = bucket.length - <span class="number">1</span>; i != -<span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j : bucket[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s == k)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ans[s++] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 344 Reverse String</title>
    <url>/2020/09/22/Leetcode/Leetcode%20344%20Reverse%20String/</url>
    <content><![CDATA[<p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p>You may assume all the characters consist of <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters">printable ascii characters</a>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="直接翻转即可"><a href="#直接翻转即可" class="headerlink" title="直接翻转即可"></a>直接翻转即可</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() / <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[i];</span><br><span class="line">            s[i] = s[s.<span class="built_in">size</span>() - <span class="number">1</span> - i];</span><br><span class="line">            s[s.<span class="built_in">size</span>() - <span class="number">1</span> - i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 35 Search Insert Position</title>
    <url>/2020/07/16/Leetcode/Leetcode%2035%20Search%20Insert%20Position/</url>
    <content><![CDATA[<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">begin</span> &lt;= <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">begin</span> = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二分查找的变种 注意最后返回的值为begin。 如果查找不到， while结束后必有target在end和begin中间， end在begin左边。所以最后返回begin</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 36 Valid Sudoku</title>
    <url>/2020/10/21/Leetcode/Leetcode%2036%20Valid%20Sudoku/</url>
    <content><![CDATA[<p>Determine if a <code>9 x 9</code> Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following rules</strong>:</p>
<ol>
<li>Each row must contain the digits <code>1-9</code> without repetition.</li>
<li>Each column must contain the digits <code>1-9</code> without repetition.</li>
<li>Each of the nine <code>3 x 3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: board &#x3D; </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: board &#x3D; </span><br><span class="line">[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>board.length == 9</code></li>
<li><code>board[i].length == 9</code></li>
<li><code>board[i][j]</code> is a digit or <code>&#39;.&#39;</code>.</li>
</ul>
<a id="more"></a>
<h2 id="1-3次遍历-1个map"><a href="#1-3次遍历-1个map" class="headerlink" title="1 3次遍历, 1个map"></a>1 3次遍历, 1个map</h2><p>这个只需要构造一个hashmap即可.</p>
<p>遍历三次, 分别检查行, 列, 块是否满足标准. </p>
<p>空间占用少, 时间占用多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; auxMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ans = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans &amp;&amp; checkRowValid(board, i);</span><br><span class="line">            ans = ans &amp;&amp; checkColumnValid(board, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i = i + <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j = j + <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = ans &amp;&amp; checkBlockValid(board, i, i + <span class="number">2</span>, j, j + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkBlockValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> iBegin, <span class="keyword">int</span> iEnd, <span class="keyword">int</span> jBegin, <span class="keyword">int</span> jEnd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        auxMap.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = iBegin; i &lt;= iEnd; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = jBegin; j &lt;= jEnd; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                auxMap.putIfAbsent(board[i][j], <span class="number">0</span>);</span><br><span class="line">                auxMap.put(board[i][j], auxMap.get(board[i][j]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry : auxMap.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getKey() != <span class="string">&#x27;.&#x27;</span> &amp;&amp; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkRowValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        auxMap.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            auxMap.putIfAbsent(board[row][j], <span class="number">0</span>);</span><br><span class="line">            auxMap.put(board[row][j], auxMap.get(board[row][j]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry : auxMap.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getKey() != <span class="string">&#x27;.&#x27;</span> &amp;&amp; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkColumnValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> column)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        auxMap.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            auxMap.putIfAbsent(board[i][column], <span class="number">0</span>);</span><br><span class="line">            auxMap.put(board[i][column], auxMap.get(board[i][column]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry : auxMap.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getKey() != <span class="string">&#x27;.&#x27;</span> &amp;&amp; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1次遍历-27个map"><a href="#2-1次遍历-27个map" class="headerlink" title="2 1次遍历, 27个map"></a>2 1次遍历, 27个map</h2><p>这里直接建立2维数组, 比hashmap更快.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 - 8 is row0 to row8</span></span><br><span class="line">    <span class="comment">// 9 - 17 is column0 to column8</span></span><br><span class="line">    <span class="comment">// 18 - 26 is block0 to block8</span></span><br><span class="line">    <span class="keyword">int</span>[][] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">27</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                cnt[i][tmp]++;</span><br><span class="line">                cnt[<span class="number">9</span> + j][tmp]++;</span><br><span class="line">                cnt[<span class="number">18</span> + getBlock(i,j)][tmp]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i][j] &gt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBlock</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i / <span class="number">3</span>) * <span class="number">3</span> + (j / <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 349 Intersection Of Two Arrays</title>
    <url>/2020/10/16/Leetcode/Leetcode%20349%20Intersection%20Of%20Two%20Arrays/</url>
    <content><![CDATA[<p>Given two arrays, write a function to compute their intersection.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">Output: [9,4]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
<a id="more"></a>
<h2 id="双hashset"><a href="#双hashset" class="headerlink" title="双hashset"></a>双hashset</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums1)</span><br><span class="line">            set1.add(i);</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(i))&#123;</span><br><span class="line">                set2.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[set2.size()];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : set2)</span><br><span class="line">            ans[k++] = i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 38 Count And Say</title>
    <url>/2020/09/20/Leetcode/Leetcode%2038%20Count%20And%20Say/</url>
    <content><![CDATA[<p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure>

<p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p>
<p>Given an integer <em>n</em> where 1 ≤ <em>n</em> ≤ 30, generate the <em>n</em>th term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<a id="more"></a>
<h2 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1 迭代"></a>1 迭代</h2><p>先写一个read函数, 返回一个字符串的读音</p>
<p>然后调用read函数n - 1次, 最后返回结果. (但不知道为什么这么慢. faster than 5.04% of C++ online submissions for Count and Say.)</p>
<p>可能的改进点有, 把to_string函数换成强制类型转换, 先计算k = text.size()然后后面全部用k代替size()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(--n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">read</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">read</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span> &lt; <span class="built_in">text</span>.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">end</span> &lt; <span class="built_in">text</span>.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">text</span>[<span class="built_in">end</span>] == <span class="built_in">text</span>[<span class="built_in">begin</span>])</span><br><span class="line">                ++<span class="built_in">end</span>;</span><br><span class="line">            ans = ans + to_string(<span class="built_in">end</span> - <span class="built_in">begin</span>) + <span class="built_in">text</span>[<span class="built_in">begin</span>];</span><br><span class="line">            <span class="built_in">begin</span> = <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 350 Intersection Of Two Arrays II</title>
    <url>/2020/10/16/Leetcode/Leetcode%20350%20Intersection%20Of%20Two%20Arrays%20II/</url>
    <content><![CDATA[<p>Given two arrays, write a function to compute their intersection.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p><strong>Follow up:</strong></p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if <em>nums1</em>‘s size is small compared to <em>nums2</em>‘s size? Which algorithm is better?</li>
<li>What if elements of <em>nums2</em> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<a id="more"></a>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>先用哈希表储存某个数组的信息, 然后遍历另一个数组, 得到交集, 也能用排序做, 但是时间复杂度更高.空间复杂度一样, 都是O(m + n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            map1.putIfAbsent(i,<span class="number">0</span>);</span><br><span class="line">            map1.put(i, map1.get(i) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map1.get(i) != <span class="keyword">null</span> &amp;&amp; map1.get(i) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                map1.put(i, map1.get(i) - <span class="number">1</span>);</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : ans)</span><br><span class="line">            ret[k++] = i;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 384 Shuffle An Array</title>
    <url>/2020/10/28/Leetcode/Leetcode%20384%20Shuffle%20An%20Array/</url>
    <content><![CDATA[<p>Shuffle a set of numbers without duplicates.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Init an array with set 1, 2, and 3.</span><br><span class="line">int[] nums &#x3D; &#123;1,2,3&#125;;</span><br><span class="line">Solution solution &#x3D; new Solution(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.</span><br><span class="line">solution.shuffle();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Resets the array back to its original configuration [1,2,3].</span><br><span class="line">solution.reset();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Returns the random shuffling of array [1,2,3].</span><br><span class="line">solution.shuffle();</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="shuffle算法"><a href="#shuffle算法" class="headerlink" title="shuffle算法"></a>shuffle算法</h2><p>要保证每一种可能性是公平的. 而所有的可能排列数为<code>n!</code>. 所以这就需要洗牌出来每一个排列的概率都是<code>1/n!</code></p>
<p>可以这样, </p>
<p>首先在数组中随便选一个值, 即从0到n-1随机选取一个下标, 将这个值作为结果的第一个. 这一次抽取的概率是<code>1/n</code>(n个里面抽1个)</p>
<p>然后把被选中的那个值移到数组最后, 数组最后的元素移动到被选中的位置. 这时候数组最后一个元素已经被选中. 从0到n-2的位置放置的是没被选中的元素. 这次就从0到n-2随机选取一个下边, 作为结果的第二个. 这次抽取的概率是1/(n-1). </p>
<p>然后把这次抽取的也放置在末尾. 下次从0到n-3抽.</p>
<p>以此类推, 直至抽完所有元素. 每一次抽取的概率都是1/(n-i)</p>
<p>所以总概率即为<code>1/n!</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] origins;</span><br><span class="line">    <span class="keyword">int</span>[] shuffled;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        origins = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        shuffled= Arrays.copyOf(nums, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>[]) origins.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> n = shuffled.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> randomIndex = r.nextInt(n);</span><br><span class="line">            ans[k++] = shuffled[randomIndex];</span><br><span class="line">            <span class="comment">// swap shuffled[randomIndex] and shuffled[n]. </span></span><br><span class="line">            <span class="comment">// because next iteration will randomly select a value from 0 to n-1</span></span><br><span class="line">            <span class="keyword">int</span> tmp = shuffled[n-<span class="number">1</span>];</span><br><span class="line">            shuffled[n-<span class="number">1</span>] = shuffled[randomIndex];</span><br><span class="line">            shuffled[randomIndex] = tmp;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int[] param_1 = obj.reset();</span></span><br><span class="line"><span class="comment"> * int[] param_2 = obj.shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 380 Insert Delete Getrandom O1</title>
    <url>/2020/08/17/Leetcode/Leetcode%20380%20Insert%20Delete%20Getrandom%20O1/</url>
    <content><![CDATA[<p>Design a data structure that supports all following operations in <em>average</em> <strong>O(1)</strong> time.</p>
<ol>
<li><code>insert(val)</code>: Inserts an item val to the set if not already present.</li>
<li><code>remove(val)</code>: Removes an item val from the set if present.</li>
<li><code>getRandom</code>: Returns a random element from current set of elements (it’s guaranteed that at least one element exists when this method is called). Each element must have the <strong>same probability</strong> of being returned.</li>
</ol>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Init an empty set.</span><br><span class="line">RandomizedSet randomSet &#x3D; new RandomizedSet();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Returns false as 2 does not exist in the set.</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom should return either 1 or 2 randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2 was already in the set, so return false.</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Since 2 is the only number in the set, getRandom always return 2.</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="vector-hashmap"><a href="#vector-hashmap" class="headerlink" title="vector + hashmap"></a>vector + hashmap</h2><p>vector里面储存各个元素, hashmap储存每一个元素对应的数组下标</p>
<ul>
<li>insert时,先在vector后面pushback某个value, 再从hashmap中添加一个这个值到数组下标位置的映射(value =&gt; vector.size() - 1)</li>
<li>remove时, 先从hashmap中查找val对应的映射(val =&gt; valIndex), 和数组最后一个元素对应的映射, (back =&gt; backIndex) , 知道val在数组中的位置valIndex后交换val和数组最后一个元素, <code>swap(vc[index], vc.back());</code>同时在hashmap上登记相应的变动<code> swap(itBack-&gt;second, itVal-&gt;second);</code> 然后删除数组中最后一个元素, 删除hashmap中对应最后一个元素的映射</li>
<li>getRandom, 选择一个[0, vc.size)的随机数作为随即下标, 返回对应的值即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vc;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedSet() &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> hasVal = (mp.<span class="built_in">find</span>(val) != mp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(hasVal)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vc.push_back(val);</span><br><span class="line">        mp.insert(&#123;val,vc.<span class="built_in">size</span>()<span class="number">-1</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator itVal = mp.<span class="built_in">find</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(itVal == mp.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator itBack = mp.<span class="built_in">find</span>(vc.back());</span><br><span class="line">        <span class="keyword">int</span> index = itVal-&gt;second;</span><br><span class="line">        swap(vc[index], vc.back());</span><br><span class="line">        swap(itBack-&gt;second, itVal-&gt;second);</span><br><span class="line">        vc.pop_back();</span><br><span class="line">        mp.erase(itVal);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> randomIndex = rand() % vc.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> vc[randomIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet* obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 387 First Unique Character In A String</title>
    <url>/2020/09/22/Leetcode/Leetcode%20387%20First%20Unique%20Character%20In%20A%20String/</url>
    <content><![CDATA[<p>Given a string, find the first non-repeating character in it and return its index. If it doesn’t exist, return -1.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;leetcode&quot;</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;loveleetcode&quot;</span><br><span class="line">return 2.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong> You may assume the string contains only lowercase English letters.</p>
<a id="more"></a>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>先存储s中的所有字符的个数, 然后i从0开始找到第一个使得s[i]的个数为1的i, 返回i即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i : s) ++mp[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 39 Combination Sum</title>
    <url>/2020/08/11/Leetcode/Leetcode%2039%20Combination%20Sum/</url>
    <content><![CDATA[<p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) <strong>(without duplicates)</strong> and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
<li><code>1 &lt;= candidates[i] &lt;= 200</code></li>
<li>Each element of <code>candidate</code> is unique.</li>
<li><code>1 &lt;= target &lt;= 500</code></li>
</ul>
<a id="more"></a>
<h2 id="1-动态规划1"><a href="#1-动态规划1" class="headerlink" title="1 动态规划1"></a>1 动态规划1</h2><p>给定candidates，设target对应的二维数组为arr(tar)</p>
<p>则有arr(tar) 等于对于每一个i，arr(tar - i)返回的二维数组每个数组中再append上i后的二维数组的并。</p>
<p>如果tar-i &lt; 0，返回空的二维数组，如果tar-i == 0，则arr(tar-i)返回[[i]]，这是递归边界。</p>
<p>计算完了后对于每个vector排序，再对vectors排序，去重</p>
<p>这几次排序的复杂度很高。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> vectors = getVectors(candidates, target);</span><br><span class="line">        <span class="comment">//remove the duplicate</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vc : vectors)</span><br><span class="line">        &#123;</span><br><span class="line">            sort(vc.<span class="built_in">begin</span>(),vc.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vectors.<span class="built_in">begin</span>(),vectors.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> <span class="built_in">end</span> = unique(vectors.<span class="built_in">begin</span>(),vectors.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(vectors.<span class="built_in">begin</span>(), <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getVectors</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vectors;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vectors;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; i : candidates)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> vectorsEqualTargetMinus_i = getVectors(candidates, target - i);</span><br><span class="line">            <span class="keyword">if</span>(target - i == <span class="number">0</span>)</span><br><span class="line">            vectors.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;i&#125;));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vc : vectorsEqualTargetMinus_i)</span><br><span class="line">            &#123;</span><br><span class="line">                vc.push_back(i);</span><br><span class="line">                vectors.push_back(vc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vectors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划2"><a href="#2-动态规划2" class="headerlink" title="2 动态规划2"></a>2 动态规划2</h2><p>对于1的改进，增加一个参数j，代表上一次选择的数的index，每次只挑选j和j后面的数作为可能的选择，这样出来的二维数组为已经排序好的，不需要排序去重。复杂度低</p>
<p>对于candidates = [2,3,6,7], target = 7, 这种方法不会产生[2,2,3] [2,3,2] [3,2,2]的多解情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getVectors(candidates, target, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getVectors</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vectors;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vectors;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt; candidates.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> vectorsEqualTargetMinus_i = getVectors(candidates, target - candidates[i],i);</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i] == <span class="number">0</span>)</span><br><span class="line">                vectors.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;candidates[i]&#125;));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vc : vectorsEqualTargetMinus_i)</span><br><span class="line">            &#123;</span><br><span class="line">                vc.push_back(candidates[i]);</span><br><span class="line">                vectors.push_back(vc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vectors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 383 Ransom Note</title>
    <url>/2020/09/22/Leetcode/Leetcode%20383%20Ransom%20Note/</url>
    <content><![CDATA[<p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>
<p>Each letter in the magazine string can only be used once in your ransom note.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: ransomNote &#x3D; &quot;a&quot;, magazine &#x3D; &quot;b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;aab&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>You may assume that both strings contain only lowercase letters.</li>
</ul>
<a id="more"></a>
<h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><p>首先要理解题意, 这题意我理解了半天. 被ransom note, magazine这些名词弄蒙了.</p>
<p><strong>这题的意思就是能不能从magazine的所有字符中挑选出一些字符来组成ransom note!</strong></p>
<p>先把magazine所有字符放一个(字符 -&gt; 字符数量)map里面, 然后判断map里面的能不能组成ransom note即可.</p>
<p>但是使用哈希表只超过了5%的空间占用. 因为只有英文小写字母, 可以考虑用一个int[26]的数组来代替map, 空间占用应该会低一些</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : magazine)</span><br><span class="line">        &#123;</span><br><span class="line">            ++mp[c];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ransomNote)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(c);</span><br><span class="line">            <span class="keyword">if</span>(it == mp.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(it-&gt;second &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 4 Median Of Two Sorted Arrays</title>
    <url>/2020/09/24/Leetcode/Leetcode%204%20Median%20Of%20Two%20Sorted%20Arrays/</url>
    <content><![CDATA[<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <strong>the median</strong> of the two sorted arrays.</p>
<p><strong>Follow up:</strong> The overall run time complexity should be <code>O(log (m+n))</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">Output: 2.00000</span><br><span class="line">Explanation: merged array &#x3D; [1,2,3] and median is 2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class="line">Output: 2.50000</span><br><span class="line">Explanation: merged array &#x3D; [1,2,3,4] and median is (2 + 3) &#x2F; 2 &#x3D; 2.5.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]</span><br><span class="line">Output: 0.00000</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [], nums2 &#x3D; [1]</span><br><span class="line">Output: 1.00000</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums1 &#x3D; [2], nums2 &#x3D; []</span><br><span class="line">Output: 2.00000</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>nums1.length == m</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m &lt;= 1000</code></li>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= m + n &lt;= 2000</code></li>
<li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li>
</ul>
<a id="more"></a>
<h2 id="1-线性复杂度"><a href="#1-线性复杂度" class="headerlink" title="1 线性复杂度"></a>1 线性复杂度</h2><p>先根据总个数是奇数还是偶数来确定中位数的位置在哪里, 然后从最小的元素开始找, 找(m + n) / 2次即可. 复杂度O(m + n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cursor1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cursor2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> median1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> median2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp;</span><br><span class="line">                <span class="keyword">if</span>(cursor1 == nums1.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = nums2[cursor2];</span><br><span class="line">                    ++cursor2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cursor2 == nums2.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = nums1[cursor1];</span><br><span class="line">                    ++cursor1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums1[cursor1] &gt; nums2[cursor2])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = nums2[cursor2];</span><br><span class="line">                    ++cursor2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = nums1[cursor1];</span><br><span class="line">                    ++cursor1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == len / <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">                    median1 = tmp;</span><br><span class="line">                <span class="keyword">if</span>(i == len / <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    median2 = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)median1 + (<span class="keyword">double</span>) median2) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp;</span><br><span class="line">                <span class="keyword">if</span>(cursor1 == nums1.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = nums2[cursor2];</span><br><span class="line">                    ++cursor2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cursor2 == nums2.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = nums1[cursor1];</span><br><span class="line">                    ++cursor1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums1[cursor1] &gt; nums2[cursor2])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = nums2[cursor2];</span><br><span class="line">                    ++cursor2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = nums1[cursor1];</span><br><span class="line">                    ++cursor1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == len / <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    median2 = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)median2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-对数复杂度1"><a href="#2-对数复杂度1" class="headerlink" title="2 对数复杂度1"></a>2 对数复杂度1</h2><p>思路来源于 <code>https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/</code>,递归做的, 比较慢, 只超过33%.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pos1 = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> pos2 = (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, pos1) + findKth(nums1, nums2, <span class="number">0</span>, <span class="number">0</span>, pos2)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> offset1, <span class="keyword">int</span> offset2, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(offset1 == nums1.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> nums2[offset2 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(offset2 == nums2.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> nums1[offset1 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(nums1[offset1], nums2[offset2]);</span><br><span class="line">        <span class="keyword">int</span> mid = k / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nums1Mid = mid + offset1;</span><br><span class="line">        <span class="keyword">int</span> nums2Mid = mid + offset2;</span><br><span class="line">        <span class="keyword">bool</span> isOutofIndex1 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> isOutofIndex2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nums1Offset = offset1;</span><br><span class="line">        <span class="keyword">int</span> nums2Offset = offset2;</span><br><span class="line">        <span class="keyword">if</span>(nums1Mid &gt; nums1.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1Mid = nums1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            isOutofIndex1 = <span class="literal">true</span>;</span><br><span class="line">            nums1Offset = nums1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums2Mid &gt; nums2.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums2Mid = nums2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            isOutofIndex2 = <span class="literal">true</span>;</span><br><span class="line">            nums2Offset = nums2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums1[nums1Mid] &gt; nums2[nums2Mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isOutofIndex2)</span><br><span class="line">            &#123;</span><br><span class="line">                k -= nums2.<span class="built_in">size</span>() - offset2;</span><br><span class="line">                offset2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                offset2 += k/<span class="number">2</span>;</span><br><span class="line">                k -= k/<span class="number">2</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isOutofIndex1)</span><br><span class="line">            &#123;</span><br><span class="line">                k -= nums1.<span class="built_in">size</span>() - offset1;</span><br><span class="line">                offset1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                offset1 += k/<span class="number">2</span>;</span><br><span class="line">                k -= k/<span class="number">2</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1, nums2, offset1, offset2, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-对数复杂度2"><a href="#3-对数复杂度2" class="headerlink" title="3 对数复杂度2"></a>3 对数复杂度2</h2><p>将上面的递归改成了循环.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pos1 = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> pos2 = (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, nums2, pos1) + findKth(nums1, nums2, pos2)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> offset2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = k / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//边界情况</span></span><br><span class="line">            <span class="keyword">if</span>(offset1 == m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[offset2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(offset2 == n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[offset1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[offset1], nums2[offset2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//正常情况</span></span><br><span class="line">            <span class="keyword">int</span> mid1 = offset1 + mid;</span><br><span class="line">            <span class="keyword">int</span> mid2 = offset2 + mid;</span><br><span class="line">            <span class="keyword">bool</span> isOutOfIndex1 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">bool</span> isOutOfIndex2 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid1 &gt; m - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mid1 = m - <span class="number">1</span>;</span><br><span class="line">                isOutOfIndex1 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mid2 &gt; n - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mid2 = n - <span class="number">1</span>;</span><br><span class="line">                isOutOfIndex2 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums1[mid1] &gt; nums2[mid2])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isOutOfIndex2)</span><br><span class="line">                &#123;</span><br><span class="line">                    k -= n - offset2;</span><br><span class="line">                    offset2 = n;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    offset2 += k/<span class="number">2</span>;</span><br><span class="line">                    k -= k/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isOutOfIndex1)</span><br><span class="line">                &#123;</span><br><span class="line">                    k -= m - offset1;</span><br><span class="line">                    offset1 = m;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    offset1 += k/<span class="number">2</span>;</span><br><span class="line">                    k -= k/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 392 Is Subsequence</title>
    <url>/2020/11/06/Leetcode/Leetcode%20392%20Is%20Subsequence/</url>
    <content><![CDATA[<p>Given a string <strong>s</strong> and a string <strong>t</strong>, check if <strong>s</strong> is subsequence of <strong>t</strong>.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>
<p><strong>Follow up:</strong><br>If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?</p>
<p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/pbrother/">@pbrother</a> for adding this problem and creating all test cases.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 100</code></li>
<li><code>0 &lt;= t.length &lt;= 10^4</code></li>
<li>Both strings consists only of lowercase characters.</li>
</ul>
<a id="more"></a>
<h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1.双指针"></a>1.双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i != s.length() &amp;&amp; j != t.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == t.charAt(j))</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h2><p>如果有很多个s, 只需要构造关于t的一些信息, 然后根据这些信息来查询.</p>
<p>很明显的信息就是一个字符c从第i个位置及之后第一次出现的位置.</p>
<p>记为<code>dp[i][c]</code></p>
<p>然后只需要O(s.length)的时间复杂度就可以完成判断.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length()][<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// init dp[][]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">26</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = (<span class="keyword">char</span>) (i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = t.length() - <span class="number">1</span>; j != -<span class="number">1</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(j) == ch)</span><br><span class="line">                &#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j][i] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != s.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cursor &gt;= dp.length)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            cursor = dp[cursor][s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(cursor == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            cursor++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 40 Combination Sum II</title>
    <url>/2020/07/20/Leetcode/Leetcode%2040%20Combination%20Sum%20II/</url>
    <content><![CDATA[<p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-动态规划1"><a href="#1-动态规划1" class="headerlink" title="1 动态规划1"></a>1 动态规划1</h2><p>和leetcode39一样，只不过这一次对于最近加上的元素位于index j，后续的寻找要从j+1开始，这样就能避免一个index使用多次。</p>
<p>但是，这个方法只能保证相同下标的index不能使用多次，对于不同下标的相同值，仍需要排序去重。</p>
<p>example 1 中就有可能出现[1, 7]和[7, 1]两种解，因为candidates里有2个1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> vectors = getVectorsWithoutDuplication(candidates,target,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : vectors)</span><br><span class="line">            sort(i.<span class="built_in">begin</span>(), i.<span class="built_in">end</span>());</span><br><span class="line">        sort(vectors.<span class="built_in">begin</span>(), vectors.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> <span class="built_in">end</span> = unique(vectors.<span class="built_in">begin</span>(), vectors.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(vectors.<span class="built_in">begin</span>(), <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getVectorsWithoutDuplication</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> begin_index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vectors;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> vectors;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin_index + <span class="number">1</span>; i &lt; candidates.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> vectorsEqualTarget_i = getVectorsWithoutDuplication(candidates, target - candidates[i], i);</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i] == <span class="number">0</span>)</span><br><span class="line">                vectors.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;candidates[i]&#125;));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vc : vectorsEqualTarget_i)</span><br><span class="line">            &#123;</span><br><span class="line">                vc.push_back(candidates[i]);</span><br><span class="line">                vectors.push_back(vc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vectors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划2"><a href="#2-动态规划2" class="headerlink" title="2 动态规划2"></a>2 动态规划2</h2><p>动态规划1重复的根本原因是因为，如果有两个index i &gt; j，并且candidates[i] == candidates[j]，所以所有的和为target-candidates[i]的集合与所有和为target-candidates[j]的集合相等。那么getVectorsWithoutDuplication(candidates, target - candidates[i], i) 一定是 getVectorsWithoutDuplication(candidates, target - candidates[j], j) 的子集！</p>
<p>这时只需要不计算j产生的所有和为target-candidates[j]的数组就可以了(candidates[i] == candidates[i - 1])。</p>
<p>但是,要注意条件i &gt; begin_index + 1 ,如果没有这个条件，会落下{1,1,6,7} target=8中{1,1,6}的解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> vectors = getVectorsWithoutDuplication(candidates,target,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vectors;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getVectorsWithoutDuplication</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> begin_index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vectors;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> vectors;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin_index + <span class="number">1</span>; i &lt; candidates.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; begin_index + <span class="number">1</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">auto</span> vectorsEqualTarget_i = getVectorsWithoutDuplication(candidates, target - candidates[i], i);</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i] == <span class="number">0</span>)</span><br><span class="line">                vectors.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;candidates[i]&#125;));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vc : vectorsEqualTarget_i)</span><br><span class="line">            &#123;</span><br><span class="line">                vc.push_back(candidates[i]);</span><br><span class="line">                vectors.push_back(vc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vectors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 412 Fizz Buzz</title>
    <url>/2020/10/15/Leetcode/Leetcode%20412%20Fizz%20Buzz/</url>
    <content><![CDATA[<p>Write a program that outputs the string representation of numbers from 1 to <em>n</em>.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; 15,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>这题太简单了, 直接模拟即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                list.add(<span class="string">&quot;FizzBuzz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                list.add(<span class="string">&quot;Fizz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                list.add(<span class="string">&quot;Buzz&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                list.add(Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 41 First Missing Positive</title>
    <url>/2020/10/02/Leetcode/Leetcode%2041%20First%20Missing%20Positive/</url>
    <content><![CDATA[<p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>Your algorithm should run in <em>O</em>(<em>n</em>) time and uses constant extra space.</p>
<a id="more"></a>
<h2 id="1-原地修改数组"><a href="#1-原地修改数组" class="headerlink" title="1 原地修改数组"></a>1 原地修改数组</h2><p>首先, 利用双指针遍历一遍数组, 把大于0的元素放在数组左边, 小于等于0的放在数组右边.</p>
<p>所以我们只需要考虑左边大于0的数组, 范围记为[0, right]</p>
<p>然后, 在0到right这个子数组中原地标记, 如果发现了元素i, 就把nums[i-1]置为负, 如果元素超过了right + 1, 就跳过. (因为数组中一共只有right + 1个正数, 所以第一个缺失的肯定在0到right + 1中间!)</p>
<p>然后, 从0开始寻找没有被标记为负数的值, 如果nums[i]没有标记为负数, 说明数组中没有出现过元素i+1, 即找到了第一个消失的正数i+1. 如果从0到right所有的nums[i]都被标记了负数, 说明1到right + 1这些元素都有, 下一个缺失的元素自然是right + 2.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; nums.length &amp;&amp; nums[left] &gt; <span class="number">0</span>)</span><br><span class="line">                ++left;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; -<span class="number">1</span> &amp;&amp; nums[right] &lt;= <span class="number">0</span>)</span><br><span class="line">                --right;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[right];</span><br><span class="line">                nums[right] = nums[left];</span><br><span class="line">                nums[left] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(val &lt;= right + <span class="number">1</span>)</span><br><span class="line">                nums[val-<span class="number">1</span>] = -Math.abs(nums[val-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-原地修改数组"><a href="#2-原地修改数组" class="headerlink" title="2 原地修改数组"></a>2 原地修改数组</h2><p>对于上面的方法1, 我们发现根本不用把大于0的元素和小于等于0的元素左右分类. 只需要把所有小于等于0的元素都置为n+1, 然后对整个数组原地修改即可. 这种方法复杂度不变, 但更简洁.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                nums[i] = n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(val &lt;= n)</span><br><span class="line">                nums[val-<span class="number">1</span>] = -Math.abs(nums[val-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 416 Partition Equal Subset Sum</title>
    <url>/2020/11/05/Leetcode/Leetcode%20416%20Partition%20Equal%20Subset%20Sum/</url>
    <content><![CDATA[<p>Given a <strong>non-empty</strong> array <code>nums</code> containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5,11,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,5]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The array cannot be partitioned into equal sum subsets.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<a id="more"></a>
<h2 id="1-暴力-超时"><a href="#1-暴力-超时" class="headerlink" title="1. 暴力(超时)"></a>1. 暴力(超时)</h2><p>直接等价于用背包法找到和为sum/2的子数组</p>
<p>本来想的是这长度只有200, 暴力背包法应该能过的. 结果还是超时了. 看样子dfs还是不行. 必须30以内才稳</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">if</span>((sum &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> doesPartitionSumEqualTarget(nums, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doesPartitionSumEqualTarget</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, nums, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> currSum, <span class="keyword">int</span> currIndex, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(currSum &gt; target || currIndex == nums.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(currSum == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> addCurr = dfs(currSum + nums[currIndex], currIndex + <span class="number">1</span>, nums, target);</span><br><span class="line">        <span class="keyword">if</span>(addCurr)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> notAddCurr = dfs(currSum, currIndex + <span class="number">1</span>, nums, target);</span><br><span class="line">        <span class="keyword">return</span> notAddCurr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-01背包"><a href="#2-01背包" class="headerlink" title="2 01背包"></a>2 01背包</h2><p>事实上我这个题一开始的想法是对的. 只是不知道01背包这样的问题怎么用动态规划. (事实上之前的背包问题我都是dfs做的. <strong>本人大菜鸡一个</strong>)</p>
<p>我们可以这样动态规划. 以下摘自<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/">https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/</a>.</p>
<p><code>dp[i][j]</code> 表示从数组的 <code>[0,i]</code> 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false。</p>
<p>首先确定边界条件. 由于任何范围内选取0个数, 都可以使得和为0. 故<code>dp[i][0] = true</code>对于任意的i均成立</p>
<p>对于<code>i = 0</code>, 由于只有2种情况. 选nums[0]和不选nums[0]所以<code>dp[0][0] = true</code>, <code>dp[0][nums[0]] = true</code>. 其他的<code>dp[0][j]</code>都为false.</p>
<p>下面推导状态转移方程.</p>
<p>对于<code>dp[i][j]</code>, 如果想让<code>dp[i][j]</code>为true, 有两种情况</p>
<ul>
<li><p>如果选nums[i], 那么就需要<code>dp[i-1][j - nums[i]]</code>为true. 同时要保证<code>j &gt;= nums[i]</code>.</p>
</li>
<li><p>如果不选nums[i], 就需要<code>dp[i-1][j]</code>为true.</p>
</li>
</ul>
<p>上面两种情况只要有一个满足, 那么<code>dp[i][j]</code>就为true了.</p>
<p>同时, 我们发现dp[i]仅仅和dp[i-1]有关. 所以可以进一步优化空间复杂度到O(target).</p>
<p>下面给出优化过空间之后的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">if</span>((sum &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] dp_i = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp_i[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; target) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        dp_i[nums[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">boolean</span>[] dp_iPlus1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= target; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp_iPlus1[j] = dp_i[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp_iPlus1[j] = dp_i[j] || dp_i[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp_i = dp_iPlus1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_i[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 414 Third Maximum Number</title>
    <url>/2020/07/24/Leetcode/Leetcode%20414%20Third%20Maximum%20Number/</url>
    <content><![CDATA[<p>Given a <strong>non-empty</strong> array of integers, return the <strong>third</strong> maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3, 2, 1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: The third maximum is 1.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1, 2]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: The third maximum does not exist, so the maximum (2) is returned instead.</span><br></pre></td></tr></table></figure>



<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2, 2, 3, 1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: Note that the third maximum here means the third maximum distinct number.</span><br><span class="line">Both numbers with value 2 are both considered as second maximum.</span><br></pre></td></tr></table></figure>



<a id="more"></a>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>这个题思路很简单,但是有坑的地方</p>
<p>首先说思路,求第k大的数通常是构造k个元素的优先队列,这里由于优先队列里的元素不能重复, 所以手动用vector构造.</p>
<ul>
<li>第1步创建一个3个元素的优先队列, 并且都赋值为INT_MIN. 这时vector为递增排列</li>
<li>第2步 对于每个元素nums[i], 和vector最前面的元素vector[0]比较,如果大于这个元素,并且和后两个元素不重复,就将vector[0] 替换为nums[i], 同时排序vector</li>
<li>第3步 当遍历完nums[i]时，vector[0]即为第3大的元素。注意如果vector[0] 为INT_MIN，那么说明没有第三大的元素 e.g. {2,2,2,2,4,4}, 这时根据题意要返回最大的元素vector[2].</li>
</ul>
<p>这个思路的复杂度低O(n), 也只需要常数的空间复杂度。</p>
<p><strong>但是，这个题坑的地方是，给的测试数组中包含INT_MIN = -2147483648 !!!**，上面的用INT_min作为最小值的策略就失效了。（</strong>[1,2,-2147483648]**这样的数组不会得出正确结果 -2147483648）</p>
<p>所以，就要设置一个新的值表示所有的int的最小值，和-2147483648区分开。</p>
<blockquote>
<p>有的做法为将int转换为long long，在设置 long long LONG_MIN = (long long)INT_MIN - 1，这是一种解决方法</p>
</blockquote>
<p>我使用的方法是创建类型 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; real_min &#123;INT_MIN, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<p>数组中的值nums[i]定义为 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; fake &#123;nums[i], <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<p>并重新定义大小关系 <code>&#123;INT_MIN, false&#125; &lt; &#123;INT_MIN, true&#125;</code>。 这样即使nums中有INT_MIN也能正确区分是真的最小值还是只是-2147483648了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; pr = &#123;INT_MIN, <span class="literal">false</span>&#125;;</span><br><span class="line">        vector&lt;pair&lt;int,bool&gt;&gt; top3(3,pr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; tmp = &#123;nums[i],<span class="literal">true</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(cmp_pair(tmp,top3[<span class="number">0</span>]) &gt; <span class="number">0</span> &amp;&amp; cmp_pair(tmp,top3[<span class="number">1</span>]) != <span class="number">0</span> &amp;&amp; cmp_pair(tmp,top3[<span class="number">2</span>]) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                top3[<span class="number">0</span>] = tmp;</span><br><span class="line">                sort(top3.<span class="built_in">begin</span>(), top3.<span class="built_in">end</span>(), cmp);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;top3[<span class="number">0</span>].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;top3[<span class="number">1</span>].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;top3[<span class="number">2</span>].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;top3[<span class="number">0</span>].second&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;top3[<span class="number">1</span>].second&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;top3[<span class="number">2</span>].second&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(top3[<span class="number">0</span>] == pr)</span><br><span class="line">            <span class="keyword">return</span> top3[<span class="number">2</span>].first;</span><br><span class="line">        <span class="keyword">return</span> top3[<span class="number">0</span>].first;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cmp_pair</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first != b.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a.second == <span class="literal">false</span> &amp;&amp; b.second == <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a.second == <span class="literal">true</span> &amp;&amp; b.second ==<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first != b.first)</span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (a.second == <span class="literal">false</span>) &amp;&amp; (b.second ==<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 43 Multiply Strings</title>
    <url>/2020/09/20/Leetcode/Leetcode%2043%20Multiply%20Strings/</url>
    <content><![CDATA[<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">Output: &quot;6&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;</span><br><span class="line">Output: &quot;56088&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 110.</li>
<li>Both <code>num1</code> and <code>num2</code> contain only digits <code>0-9</code>.</li>
<li>Both <code>num1</code> and <code>num2</code> do not contain any leading zero, except the number 0 itself.</li>
<li>You <strong>must not use any built-in BigInteger library</strong> or <strong>convert the inputs to integer</strong> directly.</li>
</ol>
<a id="more"></a>
<h2 id="1-常规解法"><a href="#1-常规解法" class="headerlink" title="1 常规解法"></a>1 常规解法</h2><p>先实现两个字符串相加的函数<code>add()</code>, 然后实现一个字符串与一个0-9的数相乘的函数<code>simpleMultiply()</code>. 最后通过这两个函数实现<code>multiply()</code>. 过程清晰但是复杂. 复杂度是O(2mn), n次m长的字符串与整数相乘有m*n的复杂度, m次相加有m*n的复杂度.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> answer = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num2.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> simpleProduct = simpleMultiply(num1, num2[i] - <span class="string">&#x27;0&#x27;</span>) + <span class="built_in">string</span>(num2.<span class="built_in">size</span>() - i - <span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            answer = add(answer, simpleProduct);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(answer[k] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; k &lt; answer.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            ++k;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(answer.<span class="built_in">begin</span>() + k, answer.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">max</span>(num1.<span class="built_in">size</span>(), num2.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span>(num1.<span class="built_in">size</span>() &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            num1 = <span class="built_in">string</span>(len - num1.<span class="built_in">size</span>(),<span class="string">&#x27;0&#x27;</span>) + num1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            num2 = <span class="built_in">string</span>(len - num2.<span class="built_in">size</span>(),<span class="string">&#x27;0&#x27;</span>) + num2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (num1[i] - <span class="string">&#x27;0&#x27;</span>) + (num2[i] - <span class="string">&#x27;0&#x27;</span>) + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            sum %= <span class="number">10</span>;</span><br><span class="line">            result.push(sum + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push(carry + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(!result.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(result.top());</span><br><span class="line">            result.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simpleMultiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        assert(num2 &gt;= <span class="number">0</span> &amp;&amp; num2 &lt;= <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">int</span> len = num1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> product = (num1[i] - <span class="string">&#x27;0&#x27;</span>) * num2 + carry;</span><br><span class="line">            carry = product / <span class="number">10</span>;</span><br><span class="line">            product %= <span class="number">10</span>;</span><br><span class="line">            result.push(product + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push(carry + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(!result.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(result.top());</span><br><span class="line">            result.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-改进常规解法"><a href="#2-改进常规解法" class="headerlink" title="2 改进常规解法"></a>2 改进常规解法</h2><p>新开辟一个长度为num1.size() + num2.size()的数组</p>
<p><strong>观察到, num1的第i位与num2的第j位的乘积一定是在结果的第i + j + 1 位, 如果有进位则是进位在i + j位</strong></p>
<p>例如 “123” 和 “456”中第2位(个位)的乘积在第5位(新开辟数组的最后一位).</p>
<p>依次遍历i,j, 然后往结果里面填值即可.</p>
<p>这个方法复杂度低, 但是较为容易出错.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(num1.<span class="built_in">size</span>() + num2.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = num1.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = num2.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> prod = (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>) + ans[i + j + <span class="number">1</span>];</span><br><span class="line">                ans[i + j] += prod / <span class="number">10</span>;</span><br><span class="line">                ans[i + j + <span class="number">1</span>] = prod % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : ans)</span><br><span class="line">            i += <span class="string">&#x27;0&#x27;</span>; <span class="comment">// int to char</span></span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[k] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            ++k;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(s.<span class="built_in">begin</span>() + k, s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 429 N Ary Tree Level Order Traversal</title>
    <url>/2020/10/05/Leetcode/Leetcode%20429%20N%20Ary%20Tree%20Level%20Order%20Traversal/</url>
    <content><![CDATA[<p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,3,2,4,null,5,6]</span><br><span class="line">Output: [[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class="line">Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>
<li>The total number of nodes is between <code>[0, 10^4]</code></li>
</ul>
<a id="more"></a>
<h2 id="队列-BFS"><a href="#队列-BFS" class="headerlink" title="队列 + BFS"></a>队列 + BFS</h2><p>和leetcode 102 相同的做法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; llist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> llist;</span><br><span class="line">        Queue&lt;Node&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Node tmp = q.poll();</span><br><span class="line">                list.add(tmp.val);</span><br><span class="line">                <span class="keyword">for</span>(Node node : tmp.children)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(node != <span class="keyword">null</span>)</span><br><span class="line">                        q.offer(node);</span><br><span class="line">                &#125;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">            llist.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> llist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 438 Find All Anagrams In A String</title>
    <url>/2020/10/27/Leetcode/Leetcode%20438%20Find%20All%20Anagrams%20In%20A%20String/</url>
    <content><![CDATA[<p>Given a string <strong>s</strong> and a <strong>non-empty</strong> string <strong>p</strong>, find all the start indices of <strong>p</strong>‘s anagrams in <strong>s</strong>.</p>
<p>Strings consists of lowercase English letters only and the length of both strings <strong>s</strong> and <strong>p</strong> will not be larger than 20,100.</p>
<p>The order of output does not matter.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index &#x3D; 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="改进的滑动窗口"><a href="#改进的滑动窗口" class="headerlink" title="改进的滑动窗口"></a>改进的滑动窗口</h2><p>普通的滑动窗口很简单, 就是从左到右依次取长度为pLen的字串, 比较和p是不是anagram.</p>
<p>但是这里可以改进一下, </p>
<p>如果滑动窗口到一个新加入的char值, 这个值在p中并没有, 就可以跳过所有的包含这个值的窗口. 减少查找成本</p>
<blockquote>
<p>例如 s: “cbaebabacd” p: “abc”</p>
<p>第一次查找时 <strong>cba</strong>ebabacd 为cba, 是anagram</p>
<p>下一次要判断bae是不是anagram.</p>
<p>我们发现新加进来的e在p中没有, 所以下面的三次查找直接跳过即可</p>
<p> c<strong>bae</strong>babacd, cb<strong>aeb</strong>abacd, cba<strong>eba</strong>bacd. 因为肯定是false.</p>
<p>直接从bab开始查找即可 cbae<strong>bab</strong>acd</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> pLen = p.length();</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; pLen)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span>[] pArr = getArray(p, <span class="number">0</span>, pLen - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = pLen - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] curr = getArray(s, begin, end);</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arrayEqual(curr, pArr))</span><br><span class="line">            &#123;</span><br><span class="line">                ans.add(begin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end == s.length() - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// chech if p contains s[end+1]</span></span><br><span class="line">            <span class="comment">// if p doesn&#x27;t contain s[end+1]</span></span><br><span class="line">            <span class="comment">// skip all substring contains s[end+1]</span></span><br><span class="line">            <span class="keyword">if</span>(pArr[s.charAt(end + <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                begin = end + <span class="number">1</span>;</span><br><span class="line">                end = end + pLen;</span><br><span class="line">                <span class="keyword">if</span>(end &gt;= s.length())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                curr = getArray(s, begin, end);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> beginChar = s.charAt(begin);</span><br><span class="line">                --curr[beginChar - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                ++begin;</span><br><span class="line">                ++end;</span><br><span class="line">                <span class="keyword">char</span> endChar = s.charAt(end);</span><br><span class="line">                ++curr[endChar - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getArray(String p, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ans[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">arrayEqual</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length != b.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != b[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 442 Find All Duplicates In An Array</title>
    <url>/2020/08/18/Leetcode/Leetcode%20442%20Find%20All%20Duplicates%20In%20An%20Array/</url>
    <content><![CDATA[<p>Given an array of integers, 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear <strong>twice</strong> and others appear <strong>once</strong>.</p>
<p>Find all the elements that appear <strong>twice</strong> in this array.</p>
<p>Could you do it without extra space and in O(<em>n</em>) runtime?</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1 暴力"></a>1 暴力</h2><p>想不出来O(1)空间的了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vc;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">            ++mp[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : mp)</span><br><span class="line">            <span class="keyword">if</span>(i.second == <span class="number">2</span>)</span><br><span class="line">                vc.push_back(i.first);</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-原地标记"><a href="#2-原地标记" class="headerlink" title="2 原地标记"></a>2 原地标记</h2><p>思路借鉴于: <a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/solution/c-qiao-miao-zi-xing-ha-xi-by-hou-yong-sheng/">hou-yong-sheng</a> (leetcode-cn)</p>
<p>利用nums[i] 属于 [1,n]的特点, 每一个值都可以对应一个下标. 这里使用值i对应i-1下标</p>
<p><strong>如果读到一个值i, 就把nums[i-1]的值置为负数. 如果再次读到i时, 检查nums[i-1]是不是为负数， 如果是的话, 说明前面肯定出现过i, 重复!!</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vc;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="built_in">abs</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                vc.push_back(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums[i<span class="number">-1</span>] = -nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 448 Find All Numbers Disappeared In An Array</title>
    <url>/2020/07/26/Leetcode/Leetcode%20448%20Find%20All%20Numbers%20Disappeared%20In%20An%20Array/</url>
    <content><![CDATA[<p>Given an array of integers where 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, <em>n</em>] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(<em>n</em>) runtime? You may assume the returned list does not count as extra space.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-hashmap"><a href="#1-hashmap" class="headerlink" title="1 hashmap"></a>1 hashmap</h2><p>是,我知道这个不符合常数空间复杂度的要求,但是菜有什么办法呢😭</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++mp[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vc;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>() + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i] == <span class="number">0</span>)</span><br><span class="line">                vc.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-原地标记"><a href="#2-原地标记" class="headerlink" title="2 原地标记"></a>2 原地标记</h2><p>本题的关键是<strong>如何储存出现的元素的信息</strong>,观察解法1hashmap方法发现额外构造了一个映射. </p>
<p>但是因为这次出现的元素的范围在1-n之间, 所以可以利用数组本身储存出现信息. 元素1出现就在数组第0个元素上做个标记, …, 元素n出现就在数组第n-1个元素上做个标记</p>
<p><strong>重点是如何做这个标记</strong>, 直接标记为-1或0是不行的. </p>
<blockquote>
<p>例如, [4,3,2,7,8,2,3,1] 当读取第0个元素为4时, 假如在第3个元素上标记为-1或0, 这时如果继续向后读到第3个元素,发现第3个元素的7已经被覆盖了, 无法还原原来nums[3]的信息.</p>
</blockquote>
<p>所以需要一个标记后也可以还原数组信息的方法. 这样的方法不止一种, 可以取负数, nums[i] = -abs(nums[i]), 当需要读到nums[i]的值的时候直接取绝对值即可还原出来原来nums[i]的值, 也可以在nums[i]上加上n, nums[i] += n, 需要nums原来的信息时候直接取模即可</p>
<p>下面假设使用的是取负数的方法. </p>
<p>遍历nums所有元素标记数组后, 再遍历一遍检查是否存在没有被标记为负数的元素, 如果nums[i]仍然为正数, 那就说明数组中肯定没有i+1!!!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            nums[index] = - <span class="built_in">abs</span>(nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vc;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">               vc.push_back(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 44 Wildcard Matching</title>
    <url>/2020/09/30/Leetcode/Leetcode%2044%20Wildcard%20Matching/</url>
    <content><![CDATA[<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;?&#39; Matches any single character.</span><br><span class="line">&#39;*&#39; Matches any sequence of characters (including the empty sequence).</span><br></pre></td></tr></table></figure>

<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
<p><strong>Note:</strong></p>
<ul>
<li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li>
<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>?</code> or <code>*</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; matches any sequence.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;cb&quot;</span><br><span class="line">p &#x3D; &quot;?a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;adceb&quot;</span><br><span class="line">p &#x3D; &quot;*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The first &#39;*&#39; matches the empty sequence, while the second &#39;*&#39; matches the substring &quot;dce&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;acdcb&quot;</span><br><span class="line">p &#x3D; &quot;a*c?b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-动态规划1"><a href="#1-动态规划1" class="headerlink" title="1 动态规划1"></a>1 动态规划1</h2><p>和leetcode 10 正则表达式匹配一样, 采用动态规划</p>
<p>思路可参考下面的URL</p>
<p><a href="https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode-solution/">https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode-solution/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> m = s.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = p.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">//empty patten always matches empty string</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">false</span>; <span class="comment">// empty patten doesnt match non-empty string</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == s.charAt(i-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划2"><a href="#2-动态规划2" class="headerlink" title="2 动态规划2"></a>2 动态规划2</h2><p>发现动态规划1中, 数组<code>dp[i]</code>可以完全由<code>dp[i-1]</code>推导, 所以可以只new2个1维数组, <code>dp_iMinus1[]</code>对应<code>dp[i-1][]</code>和<code>dp_i[]</code>对应<code>dp[i][]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> m = s.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = p.length() + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] dp_iMinus1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] dp_i = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        dp_iMinus1[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                dp_iMinus1[j] = dp_iMinus1[j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp_iMinus1[j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp_i[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp_i[j] = dp_iMinus1[j] || dp_i[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == s.charAt(i-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">                        dp_i[j] = dp_iMinus1[j-<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp_i[j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp_iMinus1 = Arrays.copyOf(dp_i, dp_i.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_iMinus1[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 46 Permutations</title>
    <url>/2020/09/29/Leetcode/Leetcode%2046%20Permutations/</url>
    <content><![CDATA[<p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS即可. 使用一个boolean数组来标记nums[i]是否已经出现在list里面了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] isTraversed = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        List&lt;Integer&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(ans, curr, nums, isTraversed);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; curr, <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] isTraversed)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isTraversed[i])</span><br><span class="line">            &#123;</span><br><span class="line">                curr.add(nums[i]);</span><br><span class="line">                isTraversed[i] = <span class="keyword">true</span>;</span><br><span class="line">                permute(ans, curr, nums, isTraversed);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">                isTraversed[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 485 Max Consecutive Ones</title>
    <url>/2020/07/26/Leetcode/Leetcode%20485%20Max%20Consecutive%20Ones/</url>
    <content><![CDATA[<p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,1,0,1,1,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first two digits or the last three digits are consecutive 1s.</span><br><span class="line">    The maximum number of consecutive 1s is 3.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ul>
<li>The input array will only contain <code>0</code> and <code>1</code>.</li>
<li>The length of input array is a positive integer and will not exceed 10,000</li>
</ul>
<a id="more"></a>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>记录两个值, maxlen和currentlen, currentlen记录截止到当前出现过的最大长度, maxlen记录currentlen最大者</p>
<p>思路和最大子数组Leetcode53的动态规划解法相似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currentLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++currentLen;</span><br><span class="line">                <span class="keyword">if</span>(currentLen &gt; maxLen)</span><br><span class="line">                    maxLen = currentLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentLen = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 457 Circular Array Loop</title>
    <url>/2020/08/17/Leetcode/Leetcode%20457%20Circular%20Array%20Loop/</url>
    <content><![CDATA[<p>You are given a <strong>circular</strong> array <code>nums</code> of positive and negative integers. If a number <em>k</em> at an index is positive, then move forward <em>k</em> steps. Conversely, if it’s negative (-<em>k</em>), move backward <em>k</em> steps. Since the array is circular, you may assume that the last element’s next element is the first element, and the first element’s previous element is the last element.</p>
<p>Determine if there is a loop (or a cycle) in <code>nums</code>. A cycle must start and end at the same index and the cycle’s length &gt; 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,-1,1,2,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle, from index 0 -&gt; 2 -&gt; 3 -&gt; 0. The cycle&#39;s length is 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-1,2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The movement from index 1 -&gt; 1 -&gt; 1 ... is not a cycle, because the cycle&#39;s length is 1. By definition the cycle&#39;s length must be greater than 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,1,-1,-2,-2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The movement from index 1 -&gt; 2 -&gt; 1 -&gt; ... is not a cycle, because movement from index 1 -&gt; 2 is a forward movement, but movement from index 2 -&gt; 1 is a backward movement. All movements in a cycle must follow a single direction.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>-1000 ≤ nums[i] ≤ 1000</li>
<li>nums[i] ≠ 0</li>
<li>1 ≤ nums.length ≤ 5000</li>
</ol>
<a id="more"></a>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>个人感觉这个题不难, 就是麻烦, 条件多! 中心思想只有将数组看成是链表, 利用快慢指针判断.</p>
<p>首先考虑对于数组中任意一个开始的index看作链表的头节点, 如果通过快慢指针的方法确定了有环, 那么直接可以返回true了.</p>
<p>但是如果没有找到环, 比如, 我们从a开始寻找(将a看成头节点), 寻找路径为a-&gt;b-&gt;c-&gt;d-&gt;e, 当遍历到e的时候发现快指针的前进方向和一开始的前进方向相反了(例如[-2,1,-1,-2,-2], The movement from index 1 -&gt; 2 -&gt; 1 -&gt; … is not a cycle), 不满足题意, 返回false后, 下一次从b开始寻找的时候就不需要再调用一次<code>hasCircleFromIndex(nums,b)</code>了，<strong>因为如果再次从b作为头节点开始找的话，也只能是走b-&gt;c-&gt;d-&gt;e的寻找路径，最后还是会发现e出现了问题要返回false</strong>。 </p>
<p>所以，对每一次经过遍历的所有数组元素都要做一个标记，当开始的index已经被标记了，就说明沿着这条路走肯定会false。直接跳过，寻找下一个没有被标记的index再次寻找即可。</p>
<blockquote>
<p>如果不标记,直接暴力寻找, 考虑[1,1,1,1,1,1,1,1,9]这样的数组, 每一次开始的index都会用双指针前进到最后才发现不行, 复杂度为O(n^2)! 而如果标记了前面的1, 则可降为线性复杂度</p>
</blockquote>
<p>但是<strong>标记的时候要用慢指针标记，慢指针遍历过的才标记，而不是用快指针，否则会出现错误</strong>，下面举例说明</p>
<blockquote>
<p>对于**[-1,1,2]** ， 我们先将-1作为头节点，第一次迭代，快指针遍历了-1 -&gt; 2 -&gt; 1，如果把2 和 1都标记了，那么就不会返回true了。如果用慢指针，那么会只标记2，再次选取index=1的时候就会判断为true。 但是这里我感觉好奇怪，明明从2出发可以找到一个circle，但是却会被标记。更稳妥的方法是先判断fast的方向对不对，如果不对，不标记slow，直接返回false，方向对再标记slow。这样可以确保任意一个被标记的index出发都不会找到circle。 但是前面那种先标记的方法也能ac，而且速度更快。(代码中/*注释的地方)</p>
</blockquote>
<p>从nums[0]遍历到nums[size-1], 对于每一个元素作为index, 如果被标记了就直接跳过,没被标记就从这个index作为头节点找是否存在circle.最后返回查找结果</p>
<p>时间复杂度分析: 因为每一次while循环都会标记一个慢指针遍历的数, 所以<strong>所有while花的时间等于标记慢指针的时间</strong>. 而所有的慢指针最多有n个, 故时间复杂度为O(n)</p>
<p>还有需要注意的地方是, c++的负数取模和通常认知的取模不一样, 所以要重新定义.</p>
<blockquote>
<p>[-1, -1, -1]中, index = -1, 往前退1步应该为 -1 % 3 = 2, 但是c++的%运算符会返回-1.  需要重新定义</p>
<p><code>auto mod = []\(int a, int b)&#123;return (a % b &gt;= 0) ? a % b : a % b + b;&#125;</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">circularArrayLoop</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bool result = false;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isMarked(nums[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(hasCircleFromIndex(nums,i))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">3000</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">-1000</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sup = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCircleFromIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fast = index;</span><br><span class="line">        <span class="keyword">int</span> slow = index;</span><br><span class="line">        <span class="comment">//initial direction right is true, left is false    </span></span><br><span class="line">        <span class="keyword">bool</span> direction = (undoMark(nums[index]) &gt; <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            fast = mod(fast + undoMark(nums[fast]), nums.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">bool</span> fastDirection1 = (undoMark(nums[fast]) &gt; <span class="number">0</span>);</span><br><span class="line">            fast = mod(fast + undoMark(nums[fast]), nums.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">bool</span> fastDirection2 = (undoMark(nums[fast]) &gt; <span class="number">0</span>);</span><br><span class="line">            slow = mod(slow + undoMark(nums[slow]), nums.<span class="built_in">size</span>());</span><br><span class="line">            </span><br><span class="line">            nums[slow] = mark(nums[slow]);</span><br><span class="line">            <span class="keyword">if</span>(fastDirection1 != direction || fastDirection2 != direction)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* use this one is safer but slower than above</span></span><br><span class="line"><span class="comment">            if(fastDirection1 != direction || fastDirection2 != direction)</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            nums[slow] = mark(nums[slow]);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(fast != slow);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check if has only one node in circle</span></span><br><span class="line">        <span class="keyword">if</span>(mod(slow + undoMark(nums[slow]), nums.<span class="built_in">size</span>())== slow)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a &gt;= M + inf) ? a : (a + M);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">undoMark</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a &gt;= M + inf) ? (a - M) : a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMarked</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt;= M + inf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>    <span class="comment">// modify a % b</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a % b &gt;= <span class="number">0</span>) ? a % b : a % b + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 47 Permutations II</title>
    <url>/2020/09/29/Leetcode/Leetcode%2047%20Permutations%20II/</url>
    <content><![CDATA[<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1 暴力"></a>1 暴力</h2><p>明显可以当成leetcode 46题来做, 只不过这里要用<code>Set&lt;List&lt;Integer&gt;&gt;</code>.去重. 但是太慢了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] isTraversed = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        List&lt;Integer&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(ans, curr, nums, isTraversed);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(Set&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; curr, <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] isTraversed)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isTraversed[i])</span><br><span class="line">            &#123;</span><br><span class="line">                curr.add(nums[i]);</span><br><span class="line">                isTraversed[i] = <span class="keyword">true</span>;</span><br><span class="line">                permute(ans, curr, nums, isTraversed);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">                isTraversed[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-排序去重"><a href="#2-排序去重" class="headerlink" title="2 排序去重"></a>2 排序去重</h2><p>首先先排序.</p>
<p><strong>当nums[i] == nums[i-1], 并且isTraverse[i-1] = false的时候, 直接跳过nums[i]即可. 否则一定会重!</strong></p>
<blockquote>
<p> 例如 nums = [1,1,2]</p>
<p>第一次遍历, 先选择了第1个1, 此时curr = [1], 这时, 第1个1的isTraverse为false, 可以将第2个1假如到curr中变成curr = [1, 1],随后可以计算出符合条件的 curr = [1,1,2], curr = [1,2,1], 他们被加入到结果ans中.</p>
<p>第二次遍历, 选择了第2个1, 但是有nums[1] == nums[0], 并且isTraverse[0] = false, 应该跳过这一次! 如果不跳过, 就有当前的curr存储了第2个1, curr = [1], 但是第1个1的isTraverse是false, 所以还会把第1个1加入到curr中, 变成curr = [1,1]. 和上面的重复了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">boolean</span>[] isTraversed = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        List&lt;Integer&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(ans, curr, nums, isTraversed);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; curr, <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] isTraversed)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isTraversed[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !isTraversed[i-<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                curr.add(nums[i]);</span><br><span class="line">                isTraversed[i] = <span class="keyword">true</span>;</span><br><span class="line">                permute(ans, curr, nums, isTraversed);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">                isTraversed[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 48 Rotate Image</title>
    <url>/2020/08/01/Leetcode/Leetcode%2048%20Rotate%20Image/</url>
    <content><![CDATA[<p>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p><strong>Note:</strong></p>
<p>You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given input matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given input matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="原地移动"><a href="#原地移动" class="headerlink" title="原地移动"></a>原地移动</h2><p>因为不让使用额外空间, 所以只能原地变换.</p>
<p>考虑m[i][j]顺时针旋转90°的变换</p>
<p>m[i][j] –&gt;m[j][n-1-i]–&gt;m[n-1-i][n-1-j]–&gt;m[n-1-j][i]–&gt;m[i][j]</p>
<p>所以只需要旋转一个元素就可以达到将这一个元素对应的4个位置的元素都旋转90的目的</p>
<p>例如  i = 1, j = 0. 只需要按照以下顺序操作一次, 对应的4个位置都会改变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = m[i][j];</span><br><span class="line">            m[i][j] = m[n<span class="number">-1</span>-j][i];</span><br><span class="line">            m[n<span class="number">-1</span>-j][i] = m[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j];</span><br><span class="line">            m[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j] = m[j][n<span class="number">-1</span>-i];</span><br><span class="line">            m[j][n<span class="number">-1</span>-i] = tmp;</span><br></pre></td></tr></table></figure>

<p>m[0][1] = 1, 10 &lt;– 1, 12 &lt;– 10, 13 &lt;– 12, 1 &lt;– 13 </p>
<p>[ 5, <strong>1</strong>, 9,11],<br>[ 2, 4, 8,<strong>10</strong>],<br>[<strong>13</strong>, 3, 6, 7],<br>[15,14,<strong>12</strong>,16]</p>
<p>所以只需要对整个矩阵的1/4的元素执行上述操作.如下图的黑体.当对5,1,9,4全部进行完旋转操作后</p>
<p>[ <strong>5, 1, 9</strong>,11],<br>[ 2, <strong>4</strong>, 8,10],<br>[13, 3, 6, 7],<br>[15,14,12,16]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m = matrix;</span><br><span class="line">        <span class="keyword">if</span>(m.empty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">size</span>() != m.front().<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;InputInvalid&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = m.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j_begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j_end = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j_begin &gt; j_end)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = j_begin; j &lt;= j_end; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = m[i][j];</span><br><span class="line">                m[i][j] = m[n<span class="number">-1</span>-j][i];</span><br><span class="line">                m[n<span class="number">-1</span>-j][i] = m[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j];</span><br><span class="line">                m[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j] = m[j][n<span class="number">-1</span>-i];</span><br><span class="line">                m[j][n<span class="number">-1</span>-i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j_begin;</span><br><span class="line">            --j_end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 495 Teemo Attacking</title>
    <url>/2020/08/17/Leetcode/Leetcode%20495%20Teemo%20Attacking/</url>
    <content><![CDATA[<p>In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo’s attacking <strong>ascending</strong> time series towards Ashe and the poisoning time duration per Teemo’s attacking, you need to output the total time that Ashe is in poisoned condition.</p>
<p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,4], 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. </span><br><span class="line">This poisoned status will last 2 seconds until the end of time point 2. </span><br><span class="line">And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. </span><br><span class="line">So you finally need to output 4.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2], 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. </span><br><span class="line">This poisoned status will last 2 seconds until the end of time point 2. </span><br><span class="line">However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. </span><br><span class="line">Since the poisoned status won&#39;t add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. </span><br><span class="line">So you finally need to output 3.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>You may assume the length of given time series array won’t exceed 10000.</li>
<li>You may assume the numbers in the Teemo’s attacking time series and his poisoning time duration per attacking are non-negative integers, which won’t exceed 10,000,000.</li>
</ol>
<a id="more"></a>
<h2 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h2><p>这题太简单了吧, 我觉得tag不应该设置为medium, 比有的easy都简单</p>
<p>核心算法只有<code>ans += min(duration,timeSeries[i+1] - timeSeries[i]);</code> 当nums[i+1] - nums[i] &lt; duration的时候, 第i次的中毒时间会被第i+1次的中毒时间覆盖掉, 此时中毒时间只有nums[i+1] - nums[i]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; timeSeries.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == timeSeries.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                ans += duration;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += <span class="built_in">min</span>(duration,timeSeries[i+<span class="number">1</span>] - timeSeries[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 494 Target Sum</title>
    <url>/2020/10/10/Leetcode/Leetcode%20494%20Target%20Sum/</url>
    <content><![CDATA[<p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p>
<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The length of the given array is positive and will not exceed 20.</li>
<li>The sum of elements in the given array will not exceed 1000.</li>
<li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li>
</ul>
<a id="more"></a>
<h2 id="1-回溯"><a href="#1-回溯" class="headerlink" title="1 回溯"></a>1 回溯</h2><p>其实回溯这个名字吧, 说的好听叫回溯, 说的不好听就叫穷举出所有可能.</p>
<p>第一次做这个题只想到了回溯, 没有想到动态规划的方法. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        findTargetSumWays(<span class="number">0</span>, <span class="number">0</span>, nums, S);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span> currSum, <span class="keyword">int</span> currIndex, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(currIndex == nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S == currSum)&#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findTargetSumWays(currSum + nums[currIndex], currIndex + <span class="number">1</span>, nums, S);</span><br><span class="line">        findTargetSumWays(currSum - nums[currIndex], currIndex + <span class="number">1</span>, nums, S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2 动态规划"></a>2 动态规划</h2><p>这个动态规划还真不容易想到. 要把答案放在数组里. <code>dp[i][j]</code>表示从nums[0]到nums[i]的子数组中可以组成和为j的方案数. 那么就有<code>dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]</code>. </p>
<p>同时因为下标不能是负数, 要把第二维的所有下标都加上sum.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> M = sum;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][<span class="number">2</span> * M + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][nums[i] + M] += <span class="number">1</span>;</span><br><span class="line">                dp[i][-nums[i] + M] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = -sum; j &lt;=  sum; ++j)&#123;</span><br><span class="line">                    <span class="keyword">int</span> a1 = (j - nums[i] &lt; -sum) ? <span class="number">0</span> : dp[i-<span class="number">1</span>][j - nums[i] + M];</span><br><span class="line">                    <span class="keyword">int</span> a2 = (j + nums[i] &gt; sum) ? <span class="number">0</span> : dp[i-<span class="number">1</span>][j + nums[i] + M];</span><br><span class="line">                    dp[i][j + M] += a1 + a2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S &gt; M || S &lt; -M ? <span class="number">0</span> : dp[nums.length - <span class="number">1</span>][S + M];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 52 Maximum Product Subarray</title>
    <url>/2020/08/10/Leetcode/Leetcode%2052%20Maximum%20Product%20Subarray/</url>
    <content><![CDATA[<p>Given an integer array <code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,0,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-split-0"><a href="#1-split-0" class="headerlink" title="1. split 0"></a>1. split 0</h2><p>首先要考虑nums只有一个元素, 返回nums.front()即可</p>
<p>若nums含有大于等于2个元素, 则最大积一定大于等于0.</p>
<p>将nums以0分割为几个子序列, 在这些子序列中选取最大的子数组乘积即可. 因为跨过2个子序列的子数组乘积一定为0</p>
<p>下面假设数组被0分割为几个子序列, [a1, a2, …, an, <strong>0</strong>, b1,b2, …, bm, <strong>0</strong>, c1,…].</p>
<p>index i遍历数组, 并用product记录子序列的乘积. <code>product = product * i ; nums[i] != 0;</code></p>
<p>当nums[i] == 0时, 我们就获得了一段以0分隔的子序列. 记起点为begin, 终点为end, 乘积为product.</p>
<ul>
<li>若product &gt; 0, 说明这一段含有0的子序列有偶数个负数. 此时product即为这一段子序列的最大子数组乘积.</li>
<li>若product &lt; 0, 说明有奇数个0, 我们需要从开头截掉一段含有第一个负数的子数组, 或者从结尾截掉一段含有最后一个负数的子数组. 例如[1,-1,-2,3,-2,4] 中, 含有第一个负数的子数组为[1, -1], 那么就令left = product/(-1*1), 含有最后一个负数的子数组为[-2,4] right = product / (-2*4). 返回left和right的最大值. 即比较[1,-1,-2,3]的乘积和[-2,3,-2,4]</li>
</ul>
<p>最后, 把各段没有0的子序列的最大子数组乘积取最大值, 即为所求.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums.front();</span><br><span class="line">        <span class="keyword">int</span> max0 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator <span class="built_in">begin</span> = nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator <span class="built_in">end</span> = nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span> != nums.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*<span class="built_in">end</span> != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                product *= *<span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                max0 = <span class="built_in">max</span>(max0, maxProduct(<span class="built_in">begin</span>, <span class="built_in">end</span>, product));</span><br><span class="line">                <span class="built_in">begin</span> = <span class="built_in">end</span> + <span class="number">1</span>;</span><br><span class="line">                product = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++<span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max0 = <span class="built_in">max</span>(max0, maxProduct(<span class="built_in">begin</span>, nums.<span class="built_in">end</span>(), product));</span><br><span class="line">        <span class="keyword">return</span> max0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator <span class="built_in">begin</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator <span class="built_in">end</span>, <span class="keyword">int</span> product)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//no element</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">end</span> - <span class="built_in">begin</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">begin</span>; <span class="comment">// one element</span></span><br><span class="line">        <span class="keyword">if</span>(product &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//product is negetive shows we must delete some negetive one in the product</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> leftsubProduct = product;</span><br><span class="line">            <span class="keyword">while</span>(*--<span class="built_in">end</span> &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                leftsubProduct /= *<span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leftsubProduct /= *<span class="built_in">end</span>;</span><br><span class="line">            <span class="keyword">int</span> rightsubProduct = product;</span><br><span class="line">            <span class="keyword">while</span>(*<span class="built_in">begin</span> &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rightsubProduct /= *<span class="built_in">begin</span>;</span><br><span class="line">                ++<span class="built_in">begin</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rightsubProduct /= *<span class="built_in">begin</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(leftsubProduct, rightsubProduct);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2 动态规划"></a>2 动态规划</h2><p>用max[i] 表示以nums[i]结尾的最大乘积子数组的值. 用min[i] 表示以nums[i]结尾的最小乘积子数组的值.</p>
<p>则有 <code>max[i+1] = max(nums[i], nums[i] * max[i], nums[i] * min[i])</code></p>
<p><code>min[i+1] = min(nums[i], nums[i] * max[i], nums[i] * min[i])</code> <strong>要考虑到一个负数和一串乘积为负数的子数组乘起来积很大， 和一个负数和一串乘积为正数的子数组乘积来的积很小</strong></p>
<p>利用一个变量maxGlobal 储存各个max[i]的最大值即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min_prev = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_prev = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxGlobal = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> min_now = <span class="built_in">min</span>(nums[i], <span class="built_in">min</span>(min_prev * nums[i], max_prev * nums[i]));</span><br><span class="line">            <span class="keyword">int</span> max_now = <span class="built_in">max</span>(nums[i], <span class="built_in">max</span>(min_prev * nums[i], max_prev * nums[i]));</span><br><span class="line">            <span class="keyword">if</span>(maxGlobal &lt; max_now)</span><br><span class="line">                maxGlobal = max_now;</span><br><span class="line">            max_prev = max_now;</span><br><span class="line">            min_prev = min_now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxGlobal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 50 Powx N</title>
    <url>/2020/09/28/Leetcode/Leetcode%2050%20Powx%20N/</url>
    <content><![CDATA[<p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a>, which calculates <em>x</em> raised to the power <em>n</em> (i.e. xn).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>-100.0 &lt; x &lt; 100.0</code></li>
<li><code>-231 &lt;= n &lt;= 231-1</code></li>
<li><code>-104 &lt;= xn &lt;= 104</code></li>
</ul>
<a id="more"></a>
<h2 id="1-快速幂"><a href="#1-快速幂" class="headerlink" title="1 快速幂"></a>1 快速幂</h2><p>对于pow(x, n), 可以先计算出tmp = pow(x, n/2)然后再用tmp * tmp 或 tmp * x * tmp表示出power(x,n).</p>
<p>要注意n为Integer.MIN_VALUE的时候, 转成正数会overflow. 所以构造一个辅助函数, <code>double myPowLong(double x, long n)</code>解决这个问题.</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myPowLong(x, (<span class="keyword">long</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">myPowLong</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">1.0</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/myPowLong(x,-n);</span><br><span class="line">        <span class="keyword">double</span> tmp = myPowLong(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tmp * tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> tmp * x * tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-快速幂-非递归方法"><a href="#2-快速幂-非递归方法" class="headerlink" title="2 快速幂 非递归方法"></a>2 快速幂 非递归方法</h2><p>在递归方法中, 需要O(logn)的空间复杂度.</p>
<p>对于迭代方法, 首先将n做二进制分解, 然后根据每一位的值决定是否乘一个多余的x.</p>
<p>例如 n = 9, 二进制表示为1001. </p>
<p>所以$x^n = (x^{8})^1 * (x^{4})^0 * (x^{2})^0 * (x^1)^1$  </p>
<p>首先二进制n的最后一位为1, x = x0, ans = x0,</p>
<p>然后更新n &gt;&gt;= 1 和x *=x. 更新完之后n的最后一位为0, x = x0^2</p>
<p>所以<strong>不需要</strong>进行ans *= x的操作 ans还是x0. 继续更新 n和x, 更新完之后n的最后一位还是为0, x = x0^4</p>
<p>这时仍然不需要更新ans. 继续更新 n和x, 更新完之后n的最后一位是1, x = x0^8</p>
<p>所以ans *= x, 这时ans = x0^9. 继续更新n和x, n更新完了之后为0了, 退出循环. 得到正确结果ans = x0^9</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myPowLong(x, (<span class="keyword">long</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">myPowLong</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">1.0</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/myPowLong(x,-n);</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> lastDigit = n &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(lastDigit == <span class="number">1</span>) ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 5 Longest Palindromic Substring</title>
    <url>/2020/09/23/Leetcode/Leetcode%205%20Longest%20Palindromic%20Substring/</url>
    <content><![CDATA[<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-动态规划1-超时"><a href="#1-动态规划1-超时" class="headerlink" title="1 动态规划1(超时)"></a>1 动态规划1(超时)</h2><p>注意到, 从i到j的字串中的最长回文子串要么是他自己, 要么是从i+1到j字符串的回文子串, 要么是i到j-1字符串的回文子串.</p>
<p>即 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">string</span><span class="params">(i,j)</span> is palindrome</span></span><br><span class="line">    dp[i][j] = string(i,j);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dp[i][j] = maxlen(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure>

<p>但是这样做, 复杂度为n^3. (填充dp矩阵n^2, 每一次判断<code>string(i,j)</code>是不是回文需要n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">string</span> dp[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="built_in">string</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; n; ++c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - c; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(s, i, i + c))</span><br><span class="line">                    dp[i][i+c] = <span class="built_in">string</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + c + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> s1 = dp[i+<span class="number">1</span>][i+c];</span><br><span class="line">                    <span class="built_in">string</span> s2 = dp[i][i+c<span class="number">-1</span>];</span><br><span class="line">                    dp[i][i+c] = (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>()) ? s1 : s2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span> &gt; <span class="built_in">begin</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="built_in">end</span>] == s[<span class="built_in">begin</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                ++<span class="built_in">begin</span>;</span><br><span class="line">                --<span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-动态规划2"><a href="#2-动态规划2" class="headerlink" title="2 动态规划2"></a>2 动态规划2</h2><p>改变动态规划1中的做法, 我们存储一个bool数组<code>bool isPalindrome[i][j]</code>表示从i到j的字串是否为palindrome.</p>
<p>那么, 首先可以得到<code>isPalindrome[i][i] is always true</code>. <code>isPalindrome[i][i+1] = (s[i] == s[i+1])</code></p>
<p>其次, <code>isPalindrome[i][j]</code>可以由 <code>isPalindrome[i+1][j-1]</code>推导出来. </p>
<p><strong>如果<code>isPalindrome[i+1][j-1]</code>为真, 并且<code>s[i] == s[j]</code>, 那么就有<code>isPalindrome[i][j] = true</code>, 否则为false</strong></p>
<p>根据此结论即可递推的求出所有的<code>isPalindrome[i][j]</code>. 找最长的即可. </p>
<p>时间和空间均为O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">bool</span> isPalindrome[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            isPalindrome[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            isPalindrome[i][i+<span class="number">1</span>] = (s[i] == s[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">2</span>; c &lt; n; ++c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - c; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                isPalindrome[i][i+c] = (isPalindrome[i+<span class="number">1</span>][i+c<span class="number">-1</span>]) &amp;&amp; (s[i] == s[i+c]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(maxLen &lt; j - i + <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">begin</span> = i;</span><br><span class="line">                        <span class="built_in">end</span> = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(s.<span class="built_in">begin</span>() + <span class="built_in">begin</span>, s.<span class="built_in">begin</span>() + <span class="built_in">end</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-中心扩展法"><a href="#3-中心扩展法" class="headerlink" title="3 中心扩展法"></a>3 中心扩展法</h2><p>考虑到每个回文子串都有一个中心, 这个中心可以是某个字符串中的字符, 也可能是某2个相邻字符中间处. </p>
<p>所以一共有2n-1个可能的中心. 对于这2n-1个中心, 每一个中心都向外扩展, 看看最大能扩展到什么长度, 然后找出最大的就可以</p>
<p>时间复杂度O(n^2), 空间O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxLen = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">0</span>; mid &lt; n; ++mid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> localLen = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> localBegin = mid;</span><br><span class="line">            <span class="keyword">int</span> localEnd = mid;</span><br><span class="line">            <span class="keyword">while</span>(localBegin &gt; <span class="number">-1</span> &amp;&amp; localEnd &lt; n &amp;&amp; s[localBegin] == s[localEnd])</span><br><span class="line">            &#123;</span><br><span class="line">                localLen = localEnd - localBegin + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(maxLen &lt; localLen)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxLen = localLen;</span><br><span class="line">                    <span class="built_in">begin</span> = localBegin;</span><br><span class="line">                    <span class="built_in">end</span> = localEnd;</span><br><span class="line">                &#125;</span><br><span class="line">                --localBegin;</span><br><span class="line">                ++localEnd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">0</span>; mid &lt; n - <span class="number">1</span>; ++mid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> localLen = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> localBegin = mid;</span><br><span class="line">            <span class="keyword">int</span> localEnd = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(localBegin &gt; <span class="number">-1</span> &amp;&amp;localEnd &lt; n &amp;&amp; s[localBegin] == s[localEnd])</span><br><span class="line">            &#123;</span><br><span class="line">                localLen = localEnd - localBegin + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(maxLen &lt; localLen)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxLen = localLen;</span><br><span class="line">                    <span class="built_in">begin</span> = localBegin;</span><br><span class="line">                    <span class="built_in">end</span> = localEnd;</span><br><span class="line">                &#125;</span><br><span class="line">                --localBegin;</span><br><span class="line">                ++localEnd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(s.<span class="built_in">begin</span>() + <span class="built_in">begin</span>, s.<span class="built_in">begin</span>() + <span class="built_in">end</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 49 Group Anagrams</title>
    <url>/2020/10/02/Leetcode/Leetcode%2049%20Group%20Anagrams/</url>
    <content><![CDATA[<p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]</span><br><span class="line">Output: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;&quot;]</span><br><span class="line">Output: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;a&quot;]</span><br><span class="line">Output: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 104</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> consists of lower-case English letters.</li>
</ul>
<a id="more"></a>
<h2 id="1-暴力双重hashmap"><a href="#1-暴力双重hashmap" class="headerlink" title="1 暴力双重hashmap"></a>1 暴力双重hashmap</h2><p>外层hashmap储存相同anagram的所有string.(内层的hashmap作为key, <code>list&lt;string&gt;</code>作为value)</p>
<p>内层hashmap用来判断两个字符串是不是anagram. (相同的字符出现相同的次数)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;Map&lt;Character, Integer&gt;, List&lt;String&gt;&gt; mp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Map&lt;Character, Integer&gt; strmp = str2map(strs[i]);</span><br><span class="line">            mp.putIfAbsent(strmp, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            mp.get(strmp).add(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; llist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; list : mp.values())</span><br><span class="line">        &#123;</span><br><span class="line">            llist.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> llist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Character, Integer&gt; <span class="title">str2map</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; ans = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.putIfAbsent(str.charAt(i),<span class="number">0</span>);</span><br><span class="line">            ans.put(str.charAt(i), ans.get(str.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-用char-26-判断是不是anagram"><a href="#2-用char-26-判断是不是anagram" class="headerlink" title="2 用char[26]判断是不是anagram"></a>2 用char[26]判断是不是anagram</h2><p>看了题解之后感觉我自己写的双重hashmap的时间复杂度和空间复杂度都和答案一样. 不知道为什么那么慢, 才超过5%. 可能是因为hashmap太多.</p>
<p>把内层的hashmap改成数组cnt.</p>
<p>通过判断cnt来判断两个string是不是anagram.</p>
<p>还需要把char[] cnt转化成String 才可以作为hashmap的键. 这里不能用int[]. 因为相同的int数组转化为string结果不确定.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; mp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span>[] cnt = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> i : str.toCharArray())</span><br><span class="line">            &#123;</span><br><span class="line">                ++cnt[i - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            String strcnt = String.valueOf(cnt);</span><br><span class="line">            mp.putIfAbsent(strcnt, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            mp.get(strcnt).add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(mp.values());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 54 Spiral Matrix</title>
    <url>/2020/08/03/Leetcode/Leetcode%2054%20Spiral%20Matrix/</url>
    <content><![CDATA[<p>Given a matrix of <em>m</em> x <em>n</em> elements (<em>m</em> rows, <em>n</em> columns), return all elements of the matrix in spiral order.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="螺旋遍历"><a href="#螺旋遍历" class="headerlink" title="螺旋遍历"></a>螺旋遍历</h2><p>首先要对已经遍历过的元素做个标记INT_MIN(一开始想用-1做标记, 但是给的test cases里有-1这个元素).</p>
<p>对于某个location{i,j}, 分别检查左边,右边, 上边,下边的元素是不是还没有遍历过并且没有超出边界.</p>
<p>  [ 1,  2,  <strong>3</strong>,  4],<br>  [ 5,  6,  7,  8],<br>  [ <strong>9</strong>, 10,11,<strong>12</strong>],<br>  [13,<strong>14</strong>,15,16]</p>
<ol>
<li>如果一个元素的右边和下边都没有遍历 接下来要先遍历右边 对于上图元素3,接下来要遍历4</li>
<li>如果一个元素的下边和左边都没有遍历 接下来要先遍历下边 对于上图元素12,接下来要遍历16</li>
<li>如果一个元素的左边和上边都没有遍历 接下来要先遍历左边 对于上图元素14, 接下来要遍历13</li>
<li>如果一个元素的上边和右边都没有遍历 接下来要先遍历上边 对于上图元素9, 接下来要遍历5</li>
<li>其他情况, 对应角上的元素, 例如4,16,13 只有一个方向没有遍历过. (4只能往下走, 16只能往左走, 13只能往上走) 那就遍历这个方向.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vc;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix.front().empty())</span><br><span class="line">            <span class="keyword">return</span> vc;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pr = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        vc.push_back(matrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        matrix[<span class="number">0</span>][<span class="number">0</span>] = INT_MIN;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(hasNextPair(matrix,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            getNextPair(matrix,pr);</span><br><span class="line">            vc.push_back(matrix[pr.first][pr.second]);</span><br><span class="line">            matrix[pr.first][pr.second] = INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNextPair</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isRightAvailable(m,pr) || isDownAvailable(m,pr) || isLeftAvailable(m,pr) || isUpAvailable(m,pr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNextPair</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isRightAvailable(m,pr) &amp;&amp; isDownAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isDownAvailable(m,pr) &amp;&amp; isLeftAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isLeftAvailable(m,pr) &amp;&amp; isUpAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isUpAvailable(m,pr) &amp;&amp; isRightAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isRightAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isDownAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isLeftAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isUpAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRightAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (j + <span class="number">1</span> &lt; m.front().<span class="built_in">size</span>()) &amp;&amp; (m[i][j+<span class="number">1</span>] != INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDownAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span> &lt; m.<span class="built_in">size</span>()) &amp;&amp; (m[i+<span class="number">1</span>][j] != INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeftAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (j - <span class="number">1</span>  &gt;= <span class="number">0</span>) &amp;&amp; (m[i][j<span class="number">-1</span>] != INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUpAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (m[i<span class="number">-1</span>][j] != INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 543 Diameter Of Binary Tree</title>
    <url>/2020/10/05/Leetcode/Leetcode%20543%20Diameter%20Of%20Binary%20Tree/</url>
    <content><![CDATA[<p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p>
<p><strong>Example:</strong><br>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5    </span><br></pre></td></tr></table></figure>



<p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p>
<p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p>
<a id="more"></a>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><p>分为经过root和不经过root. 如果不经过root, 当前直径就等于左子树直径和右子树直径的最大者. 如果经过root, 直径就等于左子树高度+右子树高度. 三者取最大值即当前树的直径.</p>
<p>递归地这样写很简单, 但是太慢了. 每一次计算都要计算树的高度, 即都要遍历到树的叶子节点.</p>
<p>只超过了9%的时间.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (root == <span class="keyword">null</span>) ? <span class="number">0</span> : Math.max(treeDepth(root.left) + treeDepth(root.right), Math.max(diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (root == <span class="keyword">null</span>) ? <span class="number">0</span> : Math.max(treeDepth(root.left) + <span class="number">1</span>,treeDepth(root.right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-原地修改树"><a href="#2-原地修改树" class="headerlink" title="2 原地修改树"></a>2 原地修改树</h2><p>首先写一个函数<code>int computeDepth(TreeNode root)</code>, 把树中的每一个节点的val值都换成以该节点作为根节点的子树的高度.</p>
<p>这样, 就方便多了.</p>
<p>对于每一个节点root, </p>
<ul>
<li><p>如果root为null, 那么直接返回0就好了</p>
</li>
<li><p>如果root的左侧或右侧为空(这里假设右侧为空), 根据经过根节点和不经过根节点的分类, 那么以root生成的子树的直径就为<code>Math.max(getDiameter(root.left), root.left.val)</code>. 这里的<code>root.left.val</code>为root的左子树的高度. <code>getDiameter(root.left)</code>为不经过根节点, <code>root.left.val</code>为经过根节点.</p>
</li>
<li><p>如果root的两侧都非空, 还是按照经过根节点和不经过根节点来. <code>int diameterPassRoot = root.left.val + root.right.val;</code>和<code>int diameterNotPassRoot = Math.max(getDiameter(root.left), getDiameter(root.right));</code>,最后返回<code>Math.max(diameterPassRoot, diameterNotPassRoot);</code></p>
</li>
</ul>
<p>这个方法是提前整理出了任意一个节点的高度, 避免了方法1中的频繁计算树的高度的问题.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        computeDepth(root);</span><br><span class="line">        <span class="keyword">return</span> getDiameter(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDiameter</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> Math.max(getDiameter(root.right), root.right.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> Math.max(getDiameter(root.left), root.left.val);</span><br><span class="line">        <span class="keyword">int</span> diameterPassRoot = root.left.val + root.right.val;</span><br><span class="line">        <span class="keyword">int</span> diameterNotPassRoot = Math.max(getDiameter(root.left), getDiameter(root.right));</span><br><span class="line">        <span class="keyword">return</span> Math.max(diameterPassRoot, diameterNotPassRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeDepth</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        root.val = Math.max(computeDepth(root.left), computeDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3 全局变量"></a>3 全局变量</h2><p>贴一个来自leetcode官网上的方法. <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/">https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/</a></p>
<p>因为路径肯定是要经过某一个子树的根节点的. 所以找出所有的节点i, 计算每一个i的(左子树深度-1)和(右子树深度-1)的和, 取最大的那一个就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        getDepth(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = getDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> R = getDepth(root.right);</span><br><span class="line">        ans = Math.max(ans, L + R);</span><br><span class="line">        <span class="keyword">return</span> Math.max(L, R) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 53 Maximum Subarray</title>
    <url>/2020/08/10/Leetcode/Leetcode%2053%20Maximum%20Subarray/</url>
    <content><![CDATA[<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<a id="more"></a>
<h2 id="1-暴力解法1-超时"><a href="#1-暴力解法1-超时" class="headerlink" title="1 暴力解法1(超时)"></a>1 暴力解法1(超时)</h2><p>对于任意两个指针i, j  计算从nums[i]到nums[j]的和，找到最大的。</p>
<p>遍历i，j所花复杂度为 n(n+1)/2，对于所有的(i, j)，计算子数组和的总时间为A=sum_{i=0, n-1} ( sum_{j=i, n-1} ( j-i+1 ) ) = O(n^3).平均计算子数组时间为2A/n(n+1)=O(n) 总复杂度为O(n^3) </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = sum(i,j,nums);</span><br><span class="line">                <span class="keyword">if</span>(tmp &gt; res)</span><br><span class="line">                    res = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">        &#123;</span><br><span class="line">            res += nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-暴力解法2"><a href="#2-暴力解法2" class="headerlink" title="2 暴力解法2"></a>2 暴力解法2</h2><p>观察到1中在计算sub sum的时候做了大量重复的计算。发现计算sum(i,j+1)时可以直接利用sum(i,j)的结果，可将计算sum的复杂度降为常数。总复杂度为O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = INT_MIN;           <span class="comment">//考虑到数组中的所有元素可能为负，不能用0初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum_i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                sum_i += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum_i &gt; sum)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum = sum_i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-分治"><a href="#3-分治" class="headerlink" title="3 分治"></a>3 分治</h2><p><strong>注意数组全部为负值的情况，此时只需要选一个最大的值即为所求</strong></p>
<p>观察到如果将数组[low , high]分为左右两部分，则最大子数组必然出现在3种情况种</p>
<ul>
<li><p>全部在左边的数组中</p>
</li>
<li><p>全部在右边的数组中</p>
</li>
<li><p>一部分在左边数组一部分在右边数组，并且必然包含边界元素</p>
</li>
</ul>
<p>此时记数组边界为[low , high]，分界符mid = low + (high - low) / 2， 则左数组边界为[low, mid]，右数组边界为[mid+1, high]（至于为什么不采用边界[low, mid - 1] 和 [mid, high]，当原始数组只有2个元素时会出现错误）</p>
<p>对于前两种情况，分别递归调用边界为[low, mid]和[mid+1, high]的函数，注意边界条件为数组只有1个元素时跳出递归。只要原始数组nums不是0个元素，此划分不会出现边界问题。</p>
<p>  第三种情况，分别计算左半部分包含边界mid的最大和（nums[i]+…+nums[mid], i from low to mid）和右半部分包含边界mid+1的最大和（nums[mid+1]+…+nums[j], j from mid+1 to high），最大和为两者相加</p>
<p>最后返回三种情况的最大值</p>
<p>对于第三种情况，计算最大子序列的复杂度为O(n)</p>
<p>所以 T(n) = 2T(n/2) + O(n)，总复杂度为O(nlogn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = *max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span> &lt;= <span class="number">0</span>)   <span class="comment">//if all elements less than 0, return max(nums)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;null array&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dividedMaxSubArray(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dividedMaxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(high == low)   <span class="comment">//only one value in subarray</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[low],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftMax = dividedMaxSubArray(nums, low, mid);</span><br><span class="line">        <span class="keyword">int</span> rightMax = dividedMaxSubArray(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftHalf = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftTmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &gt;= low; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            leftTmp += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(leftTmp &gt; leftHalf)</span><br><span class="line">                leftHalf = leftTmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rightHalf = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightTmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = mid + <span class="number">1</span>; j &lt;= high; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            rightTmp += nums[j];</span><br><span class="line">            <span class="keyword">if</span>(rightTmp &gt; rightHalf)</span><br><span class="line">                rightHalf = rightTmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> midMax = leftHalf + rightHalf;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(midMax,<span class="built_in">max</span>(leftMax,rightMax));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-动态规划"><a href="#4-动态规划" class="headerlink" title="4 动态规划"></a>4 动态规划</h2><p>同样要先处理数组全是负数的情况</p>
<p><strong>观察到，如果一个子序列和为负数，那么这个子序列一定不可能出现在最大子序列中。</strong></p>
<p>设立两个变量 max，tmp，对于i from 0 to nums.size()</p>
<p>tmp记录了从0到i中，所有以nums[i]结尾的子数组的最大值，因为如果存在在i前面的j，和j前面的任意k，使得从k到j的和为负，那么从k到i的和一定小于j到i的和。所以在遍历到j的时候就应该置tmp为0，不要j前面这一段。</p>
<p>对于从0到n的每个i 依次将max与tmp比较，取这些tmp的最大值，就得到了每个以nums[i]结尾的子序列的最大值中的最大值。</p>
<p><strong>dp[i+1] = max(dp[i]+nums[i+1], nums[i+1])</strong> 其中dp[i]表示以nums[i]结尾的最大子数组</p>
<p>只遍历一遍，所以总复杂度为O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxElem = *max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(maxElem &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> maxElem;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="built_in">max</span>)</span><br><span class="line">                <span class="built_in">max</span> = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 509 Fibonacci Number</title>
    <url>/2020/07/26/Leetcode/Leetcode%20509%20Fibonacci%20Number/</url>
    <content><![CDATA[<p>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), for N &gt; 1.</span><br></pre></td></tr></table></figure>

<p>Given <code>N</code>, calculate <code>F(N)</code>.</p>
<a id="more"></a>
<h2 id="直接计算"><a href="#直接计算" class="headerlink" title="直接计算"></a>直接计算</h2><p>没什么难的, 直接计算吧, 这都不会的话重学编程语言</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span> || N == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        <span class="keyword">int</span> f_Nminus2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f_Nminus1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = f_Nminus2 + f_Nminus1;</span><br><span class="line">            f_Nminus2 = f_Nminus1;</span><br><span class="line">            f_Nminus1 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 532 K Diff Pairs In An Array</title>
    <url>/2020/07/26/Leetcode/Leetcode%20532%20K%20Diff%20Pairs%20In%20An%20Array/</url>
    <content><![CDATA[<p>Given an array of integers and an integer <strong>k</strong>, you need to find the number of <strong>unique</strong> k-diff pairs in the array. Here a <strong>k-diff</strong> pair is defined as an integer pair (i, j), where <strong>i</strong> and <strong>j</strong> are both numbers in the array and their <a href="https://en.wikipedia.org/wiki/Absolute_difference">absolute difference</a> is <strong>k</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3, 1, 4, 1, 5], k &#x3D; 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:[1, 2, 3, 4, 5], k &#x3D; 1</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).</span><br></pre></td></tr></table></figure>



<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1, 3, 1, 5, 4], k &#x3D; 0</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: There is one 0-diff pair in the array, (1, 1).</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The pairs (i, j) and (j, i) count as the same pair.</li>
<li>The length of the array won’t exceed 10,000.</li>
<li>All the integers in the given input belong to the range: [-1e7, 1e7].</li>
</ol>
<a id="more"></a>
<h2 id="分类讨论"><a href="#分类讨论" class="headerlink" title="分类讨论"></a>分类讨论</h2><p>当k = 0时, 问题等价于寻找数组中出现次数大于等于2次的元素个数, 建立一个hashmap统计出现次数即可.O(n)</p>
<p>当k &lt; 0时, 我本以为k=-1和k=1的结果应该一样, 毕竟集合<code>&#123;(i, j): k == i - j&#125;</code>和集合<code>&#123;(i, j): -k == i - j&#125;</code>的元素个数相同,但是这个题的坑在于<strong>k&lt;0时, 应该返回结果是0, 而example并未说明!</strong></p>
<p>当k&gt;0时, 同一个元素只需要考虑一次,不需要考虑这个元素出现了几次(出现1次和出现多次没有区别). 所以先进行<strong>排序</strong>和去重</p>
<p>设置双指针, i=0,j=1, tmp = nums[j] - nums[i], </p>
<ul>
<li><p>若tmp == k,则说明已经找到一组解, 再令++j, ++i去寻找下一个可能的解</p>
</li>
<li><p>若tmp&lt;k 说明需要++j, 以获得更大的差值nums[j] - nums[i]</p>
</li>
<li><p>若tmp&gt;k 说明需要++i, 以获得更小的差值nums[j] - nums[i]</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span> || k &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i :nums)</span><br><span class="line">                ++mp[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : mp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i.second &gt; <span class="number">1</span>)</span><br><span class="line">                    ++res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator new_end = unique(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            nums.erase(new_end, nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[j] - nums[i];</span><br><span class="line">                <span class="keyword">if</span>(tmp == k)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                    ++j;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp &lt; k)</span><br><span class="line">                    ++j;</span><br><span class="line">                <span class="keyword">if</span>(tmp &gt; k)</span><br><span class="line">                    ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 56 Merge Intervals</title>
    <url>/2020/08/03/Leetcode/Leetcode%2056%20Merge%20Intervals/</url>
    <content><![CDATA[<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure>

<p><strong>NOTE:</strong> input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>
<a id="more"></a>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>懒得写题解了, 思路copy from <a href="https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/">https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/</a></p>
<p>如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。</p>
<p>我们用数组 merged 存储最终的答案。</p>
<p>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：</p>
<p>如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；</p>
<p>否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。</p>
<p>代码中用vvc代替merged</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvc;</span><br><span class="line">        <span class="keyword">if</span>(intervals.empty())</span><br><span class="line">            <span class="keyword">return</span> vvc;</span><br><span class="line">        <span class="keyword">int</span> left = intervals.front().front();</span><br><span class="line">        <span class="keyword">int</span> right = intervals.front().back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = intervals[i];</span><br><span class="line">            <span class="keyword">if</span>(tmp.front() &lt;= right)  <span class="comment">// able to merge</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = <span class="built_in">max</span>(right, tmp.back());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                    <span class="comment">// cannot merge</span></span><br><span class="line">            &#123;</span><br><span class="line">                vvc.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;left, right&#125;));</span><br><span class="line">                left = tmp.front();</span><br><span class="line">                right = tmp.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vvc.push_back(&#123;left,right&#125;);</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; intervalA, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; intervalB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervalA.front() != intervalB.front())</span><br><span class="line">            <span class="keyword">return</span> intervalA.front() &lt; intervalB.front();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> intervalA.back() &lt; intervalB.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 560 Subarray Sum Equals K</title>
    <url>/2020/08/20/Leetcode/Leetcode%20560%20Subarray%20Sum%20Equals%20K/</url>
    <content><![CDATA[<p>Given an array of integers and an integer <strong>k</strong>, you need to find the total number of continuous subarrays whose sum equals to <strong>k</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The length of the array is in range [1, 20,000].</li>
<li>The range of numbers in the array is [-1000, 1000] and the range of the integer <strong>k</strong> is [-1e7, 1e7].</li>
</ul>
<a id="more"></a>
<h2 id="1-暴力-超时"><a href="#1-暴力-超时" class="headerlink" title="1 暴力(超时)"></a>1 暴力(超时)</h2><p>想不出来更好的了, 只能暴力</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum == k)</span><br><span class="line">                    ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-Perfix-Sum"><a href="#2-Perfix-Sum" class="headerlink" title="2 Perfix Sum"></a>2 Perfix Sum</h2><p><strong>假如我们构造了一个数组S, 其中, S[i] 为前i项的和 nums[0] + nums[1] + … + nums[i], 那么问题就转换为求数组S中的两个元素使得S[i] - S[j] = k 成立, 其中i &gt; j&gt;=-1. 这和Leetcode 1 Two Sum是不是完全相同!</strong> </p>
<p>所以构造hashmap, 为前i项的值映射到这个值的总个数. </p>
<p>因为从j+1到i的子序列和可以表示为S[i]-S[j] <code>S[i]-S[j] = k =&gt; S[j] = S[i] - k</code>, 所以对于任意的S[i], 只需要寻找有多少个和为(S[i] - k)的前缀S[j], 即可求出以nums[i]结尾的, 和为k的子数组个数. </p>
<p>注意, 我们定义S[-1] = 0;是因为对于从0到i的子序列和没有办法通过S[i] - S[j]的方法表示出来, 只能人为规定mp[0] = 1; (前缀和为0的最开始有1个)</p>
<p>同时为了保证j&lt;i, 我们使用一次遍历的方法, 先求出S[i], 再计算map里面满足条件<code>S[j] = S[i] - k</code>的个数加到ans上(这时map里面的S[j]都能保证j&lt;i), 最后再把S[i]放进map中. </p>
<p>复杂度O(n) </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">int</span> tmp = mp[sum - k];</span><br><span class="line">            ans += tmp;</span><br><span class="line">            ++mp[sum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 55 Jump Game</title>
    <url>/2020/08/01/Leetcode/Leetcode%2055%20Jump%20Game/</url>
    <content><![CDATA[<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>0 &lt;= nums[i][j] &lt;= 10^5</code></li>
</ul>
<a id="more"></a>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>创建变量int maxDist = 0储存目前阶段能jump到的最远的距离 一开始最远只能到0</p>
<p>对于i从0到nums.size() - 1</p>
<p>若i &gt; maxDist 说明无论如何也不可能到达i， 所以不可能到达last one 返回false</p>
<p>若i &lt;= maxDist 说明可以到达i， 这时要更新maxDist, 看看在节点i的帮助下能不能跳更远， 在i开始跳的最远距离为i + nums[i] 并更新maxDist = max(maxDist, i + nums[i])</p>
<p>最后，若i完整的从0遍历到size - 1，说明可以到达，返回true</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxDist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxDist &lt; i)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            maxDist=<span class="built_in">max</span>(maxDist, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 561 Array Partition I</title>
    <url>/2020/07/26/Leetcode/Leetcode%20561%20Array%20Partition%20I/</url>
    <content><![CDATA[<p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">Output: 4</span><br><span class="line">Explanation: n is 2, and the maximum sum of pairs is 4 &#x3D; min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li>
<li>All the integers in the array will be in the range of [-10000, 10000].</li>
</ol>
<a id="more"></a>
<h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><p>要获得各个min(ai, bi)的和最大, 最小值和第2小的值肯定是组成一个pair, 第3小的和第4小的组成一个pair, …, 以此类推. (否则, 如果最小的和第二小的元素不是一个pair, 那么把他们组成一个pair会获得更大的sum值)</p>
<p>排序后计算nums[0]+nums[2]+…+nums[2*n - 2]的值即可.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res += nums[<span class="number">2</span>*i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 57 Insert Interval</title>
    <url>/2020/08/03/Leetcode/Leetcode%2057%20Insert%20Interval/</url>
    <content><![CDATA[<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">Output: [[1,5],[6,9]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">Output: [[1,2],[3,10],[12,16]]</span><br><span class="line">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br></pre></td></tr></table></figure>

<p><strong>NOTE:</strong> input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>
<a id="more"></a>
<h2 id="1-懒人做法"><a href="#1-懒人做法" class="headerlink" title="1 懒人做法"></a>1 懒人做法</h2><p>直接参考leetcode 56 的做法, pushback新的区间后直接调用leetcode56的merge方法.</p>
<p>但是复杂度高, 要排序 nlogn</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval)</span> </span>&#123;</span><br><span class="line">        intervals.push_back(newInterval);</span><br><span class="line">        <span class="keyword">return</span> merge(intervals);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvc;</span><br><span class="line">        <span class="keyword">if</span>(intervals.empty())</span><br><span class="line">            <span class="keyword">return</span> vvc;</span><br><span class="line">        <span class="keyword">int</span> left = intervals.front().front();</span><br><span class="line">        <span class="keyword">int</span> right = intervals.front().back();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = intervals[i];</span><br><span class="line">            <span class="keyword">if</span>(tmp.front() &lt;= right)  <span class="comment">// able to merge</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = <span class="built_in">max</span>(right, tmp.back());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                    <span class="comment">// cannot merge</span></span><br><span class="line">            &#123;</span><br><span class="line">                vvc.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;left, right&#125;));</span><br><span class="line">                left = tmp.front();</span><br><span class="line">                right = tmp.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vvc.push_back(&#123;left,right&#125;);</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; intervalA, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; intervalB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervalA.front() != intervalB.front())</span><br><span class="line">            <span class="keyword">return</span> intervalA.front() &lt; intervalB.front();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> intervalA.back() &lt; intervalB.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-扫描"><a href="#2-扫描" class="headerlink" title="2 扫描"></a>2 扫描</h2><p>因为intervals已经是按照左端点排序的了, 所以从左到右找到newInterval的左端点在的区间intervals[left_index]和右端点在的区间intervals[right_index]. 然后合并即可</p>
<p>这里对于左右端点设置两个变量, 所在的区间i 和是否在区间外面（左边的外面）</p>
<p>例如intervals = [[1,3],[6,9]], newInterval = [2,5]，左端点2所在的区间为第0个区间，并且不是在区间0外面. 右端点5所在的区间为第1个区间，并且在区间1外面</p>
<p>对于index小于left_index的区间和index大于right_index的区间， 直接放到结果中</p>
<p>left_index到right_index之间的区间则要分类讨论(还要注意left_index和right_index是否越界)</p>
<p>若right不在区间中, 则要添加两个区间[ min(intervals[left_index].front(), left), right ] 和 intervals[right_index]. 反之， 只添加一个区间 [ min(intervals[left_index].front(), left), right ]</p>
<blockquote>
<p>例如intervals = [[1,3],[6,9]], newInterval = [2,5] 要添加 区间 [1,5] 和 [6,9]</p>
<p>例如intervals = [[1,3],[6,9]], newInterval = [2,7] 要添加 区间[1,7] </p>
<p>因为 无论 newInterval.back()是5还是7, 都归类到第1个区间[6,9], 但是一个在第1个区间左边,一个在第1个区间中间</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvc;</span><br><span class="line">        <span class="keyword">if</span>(intervals.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vvc.push_back(newInterval);</span><br><span class="line">            <span class="keyword">return</span> vvc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = newInterval.front();</span><br><span class="line">        <span class="keyword">int</span> right = newInterval.back();</span><br><span class="line">        <span class="keyword">bool</span> isLeftBeyondInterval = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> isRightBeyondInterval = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left_index = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> right_index = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; intervals[i].front())</span><br><span class="line">            &#123;</span><br><span class="line">                isLeftBeyondInterval = <span class="literal">true</span>;</span><br><span class="line">                left_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(left &lt;= intervals[i].back())</span><br><span class="line">            &#123;</span><br><span class="line">                isLeftBeyondInterval = <span class="literal">false</span>;</span><br><span class="line">                left_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(right &lt; intervals[i].front())</span><br><span class="line">            &#123;</span><br><span class="line">                isRightBeyondInterval = <span class="literal">true</span>;</span><br><span class="line">                right_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right &lt;= intervals[i].back())</span><br><span class="line">            &#123;</span><br><span class="line">                isRightBeyondInterval = <span class="literal">false</span>;</span><br><span class="line">                right_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; left_index)</span><br><span class="line">            &#123;</span><br><span class="line">                vvc.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isRightBeyondInterval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left_index &lt; intervals.<span class="built_in">size</span>())</span><br><span class="line">                vvc.push_back(&#123;<span class="built_in">min</span>(intervals[left_index].front(), left), right&#125;);</span><br><span class="line">            <span class="keyword">if</span>(right_index &lt; intervals.<span class="built_in">size</span>())</span><br><span class="line">                vvc.push_back(intervals[right_index]);</span><br><span class="line">            <span class="keyword">if</span>(left_index == intervals.<span class="built_in">size</span>())</span><br><span class="line">                vvc.push_back(&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            vvc.push_back(&#123;<span class="built_in">min</span>(intervals[left_index].front(), left), intervals[right_index].back()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; right_index)</span><br><span class="line">            &#123;</span><br><span class="line">                vvc.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 566 Reshape The Matrix</title>
    <url>/2020/07/27/Leetcode/Leetcode%20566%20Reshape%20The%20Matrix/</url>
    <content><![CDATA[<p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p>
<p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and <strong>column</strong> number of the wanted reshaped matrix, respectively.</p>
<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p>
<p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums &#x3D; </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r &#x3D; 1, c &#x3D; 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">nums &#x3D; </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r &#x3D; 2, c &#x3D; 4</span><br><span class="line">Output: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">Explanation:There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The height and width of the given matrix is in range [1, 100].</li>
<li>The given r and c are all positive.</li>
</ol>
<a id="more"></a>
<h2 id="构造二维数组赋值"><a href="#构造二维数组赋值" class="headerlink" title="构造二维数组赋值"></a>构造二维数组赋值</h2><p>没什么难的, 没学过数据结构和算法的也能做出来, 注意要先判断给的r*c和nums的元素数量是否相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">matrixReshape</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> count = nums.<span class="built_in">size</span>() * nums.front().<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(count != r * c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(c,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">vvc</span><span class="params">(r,tmp)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> new_i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> new_j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j : i)</span><br><span class="line">            &#123;</span><br><span class="line">                vvc[new_i][new_j] = j;</span><br><span class="line">                ++new_j;</span><br><span class="line">                <span class="keyword">if</span>(new_j == c)</span><br><span class="line">                &#123;</span><br><span class="line">                    new_j = <span class="number">0</span>;</span><br><span class="line">                    ++new_i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 565 Array Nesting</title>
    <url>/2020/08/19/Leetcode/Leetcode%20565%20Array%20Nesting/</url>
    <content><![CDATA[<p>A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below.</p>
<p>Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A &#x3D; [5,4,0,3,1,6,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">A[0] &#x3D; 5, A[1] &#x3D; 4, A[2] &#x3D; 0, A[3] &#x3D; 3, A[4] &#x3D; 1, A[5] &#x3D; 6, A[6] &#x3D; 2.</span><br><span class="line"></span><br><span class="line">One of the longest S[K]:</span><br><span class="line">S[0] &#x3D; &#123;A[0], A[5], A[6], A[2]&#125; &#x3D; &#123;5, 6, 2, 0&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>N is an integer within the range [1, 20,000].</li>
<li>The elements of A are all distinct.</li>
<li>Each element of A is an integer within the range [0, N-1].</li>
</ol>
<a id="more"></a>
<h2 id="1-set-原地标记"><a href="#1-set-原地标记" class="headerlink" title="1 set + 原地标记"></a>1 set + 原地标记</h2><p>构造一个set储存被遍历过的值.</p>
<p>i从0到size - 1遍历, 当nums[i] 被标记过时直接跳过. </p>
<p>当nums[i]未被标记过, 从nums[i]开始, 遵循顺序nums[i] -&gt; nums[nums[i]] -&gt; nums[nums[nums[i]]] -&gt; … 把每一个元素标记, 并放入set, 直到某一个值与set里面的值重复. 最后统计set的size并clear这个set. 取各个set中最大的size返回即可. </p>
<p>时间复杂度O(n) 空间复杂度O(k) k是返回值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isMarked(nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = mark(nums[i], N);</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.<span class="built_in">find</span>(tmp) == s.<span class="built_in">end</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        s.insert(tmp);</span><br><span class="line">                        nums[tmp] = mark(nums[tmp], N);</span><br><span class="line">                        tmp = undoMark(nums[tmp], N);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        maxLen = <span class="built_in">max</span>(maxLen, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>()));</span><br><span class="line">                        s.<span class="built_in">clear</span>();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? a : a - N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">undoMark</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? a + N : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isMarked</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-原地标记"><a href="#2-原地标记" class="headerlink" title="2 原地标记"></a>2 原地标记</h2><p>通过对1的观察, 发现不需要构造一个set来判断是否重复地计算一个元素. 只需要一个数count来记录这次遍历的环的大小即可. 对于每一个没有被标记的nums[i], 还是从nums[i]开始, 遵循顺序nums[i] -&gt; nums[nums[i]] -&gt; nums[nums[nums[i]]] -&gt; … 把每一个元素标记, 并且**++count**. 直到某个元素已经被标记了, 返回各个count的最大值, 并清空count. </p>
<p>时间复杂度O(n) 空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isMarked(nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> maxLocal = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp = i;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!isMarked(nums[tmp]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        ++maxLocal;</span><br><span class="line">                        nums[tmp] = mark(nums[tmp], N);</span><br><span class="line">                        tmp = undoMark(nums[tmp], N);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        maxLen = <span class="built_in">max</span>(maxLen, maxLocal);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? a : a - N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">undoMark</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? a + N : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isMarked</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 59 Spiral Matrix II</title>
    <url>/2020/08/03/Leetcode/Leetcode%2059%20Spiral%20Matrix%20II/</url>
    <content><![CDATA[<p>Given a positive integer <em>n</em>, generate a square matrix filled with elements from 1 to <em>n</em>2 in spiral order.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p>思路和leetcode54一模一样</p>
<p>都先要根据规则找到下一个位置. 具体参考leetcode54</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generateMatrix</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">vvc</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,INT_MIN))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; location = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        vvc[<span class="number">0</span>][<span class="number">0</span>] = a++;</span><br><span class="line">        <span class="keyword">while</span>(hasNextPair(vvc,location))</span><br><span class="line">        &#123;</span><br><span class="line">            getNextPair(vvc, location);</span><br><span class="line">            vvc[location.first][location.second] = a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNextPair</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isRightAvailable(m,pr) || isDownAvailable(m,pr) || isLeftAvailable(m,pr) || isUpAvailable(m,pr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNextPair</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isRightAvailable(m,pr) &amp;&amp; isDownAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isDownAvailable(m,pr) &amp;&amp; isLeftAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isLeftAvailable(m,pr) &amp;&amp; isUpAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isUpAvailable(m,pr) &amp;&amp; isRightAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isRightAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isDownAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isLeftAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isUpAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRightAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (j + <span class="number">1</span> &lt; m.front().<span class="built_in">size</span>()) &amp;&amp; (m[i][j+<span class="number">1</span>] == INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDownAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span> &lt; m.<span class="built_in">size</span>()) &amp;&amp; (m[i+<span class="number">1</span>][j] == INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeftAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (j - <span class="number">1</span>  &gt;= <span class="number">0</span>) &amp;&amp; (m[i][j<span class="number">-1</span>] == INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUpAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (m[i<span class="number">-1</span>][j] == INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 58 Length Of Last Word</title>
    <url>/2020/09/21/Leetcode/Leetcode%2058%20Length%20Of%20Last%20Word/</url>
    <content><![CDATA[<p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word (last word means the last appearing word if we loop from left to right) in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p><strong>Note:</strong> A word is defined as a <strong>maximal substring</strong> consisting of non-space characters only.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;Hello World&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>先trim掉最后面的空格, 然后从后向前计数, 碰到空格停止计数, 最后返回计数的值即可</p>
<p>注意, 这里去除掉最后的空格的函数写法</p>
<p><code>s.erase(find_if(s.rbegin(), s.rend(), [](char ch)&#123;return !std::isspace(ch);&#125;).base(), s.end());</code>.</p>
<p>其中<code>find_if(s.rbegin(), s.rend(), [](char ch)&#123;return !std::isspace(ch);&#125;)</code>利用反向迭代器寻找最后一个不是空格的元素, 然后通过<code>base()</code>方法转换为对应的正向迭代器it. 然后删除掉it到s.end()的空格.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s.erase(find_if(s.rbegin(), s.rend(), [](<span class="keyword">char</span> ch)&#123;<span class="keyword">return</span> !<span class="built_in">std</span>::<span class="built_in">isspace</span>(ch);&#125;).base(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                ++cnt;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 581 Shortest Unsorted Continuous Subarray</title>
    <url>/2020/07/28/Leetcode/Leetcode%20581%20Shortest%20Unsorted%20Continuous%20Subarray/</url>
    <content><![CDATA[<p>Given an integer array, you need to find one <strong>continuous subarray</strong> that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.</p>
<p>You need to find the <strong>shortest</strong> such subarray and output its length.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>Then length of the input array is in range [1, 10,000].</li>
<li>The input array may contain duplicates, so ascending order here means <strong>&lt;=</strong>.</li>
</ol>
<a id="more"></a>
<h2 id="1-憨批解法"><a href="#1-憨批解法" class="headerlink" title="1 憨批解法"></a>1 憨批解法</h2><p>先构造个排好序的数组sortedNums, 再从左到右对照nums和sortNums第一个不一样的元素nums[i]和最后一个不一样的元素nums[j],所以(j - i + 1)即为所求。为了防止nums已经是排好序的导致的i&gt;j，所以 return max(j - i + 1, 0)</p>
<p><strong>这算法太憨了😂😂😂, 既然已经都花时间和空间排好序了那还求排序需要的最短子数组干什么呢?</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortedNums = nums;</span><br><span class="line">        sort(sortedNums.<span class="built_in">begin</span>(), sortedNums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != sortedNums[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != sortedNums[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(j - i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-4次扫描"><a href="#2-4次扫描" class="headerlink" title="2 4次扫描"></a>2 4次扫描</h2><ol>
<li>首先要确定数组中从左到右第一个不是升序的元素和最后一个不是升序的元素, 即第一个使<code>nums[i] &lt; nums[i - 1]</code>成立的i first_desc, 和最后一个使<code>nums[i] &lt; nums[i - 1]</code>成立的i last_desc. (若找不到的话, 那就说明这个数组本来就是升序的, 返回0)那么在范围[first_desc, last_desc - 1]范围内的元素肯定不是升序排列. 需要移动的范围<strong>至少</strong>是这个区间</li>
</ol>
<blockquote>
<p>e.g. [0 2 3 4 <strong>1</strong> 6 7 <strong>5</strong> 8]           至少需要移动元素1到5所在的区间, 注意是至少, 因为前面的2 3 4元素虽然是升序但是位置也是不对的  </p>
<p>​                                                 (元素1要放到他们前面)</p>
</blockquote>
<ol start="2">
<li><p>当确定first_desc和last_desc后.需要找到first_desc及之后的最小元素min_after_first_desc和last_desc之前的最大元素max_before_last_desc.  <strong>first_desc及之后的最小元素min_after_first_desc的正确位置肯定在[0, first_desc]之间. last_desc之前的最大元素max_before_last_desc的正确位置肯定在[last_desc, nums.size() - 1]之间!!</strong> 因为min_after_first_desc是肯定要小于nums[first_desc]的, 排序的话肯定要排到first_desc前面的某个位置loc1, 这个loc1就是我们最终寻找的index.  max_before_last_desc同理.</p>
</li>
<li><p>找到min_after_first_desc的正确位置loc1, 即<strong>从左到右</strong>遍历0到first_desc - 1的第一个大于min_after_first_desc的元素位置, 找到max_before_last_desc的正确位置loc2, 即<strong>从右到左</strong>遍历nums.size() - 1到last_desc第一个小于max_before_last_desc的元素位置, loc2 - loc1 + 1即为所求.</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first_desc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last_desc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                first_desc = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                last_desc = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(first_desc == <span class="number">0</span> &amp;&amp; last_desc == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//ascending array</span></span><br><span class="line">        <span class="keyword">int</span> min_after_first_desc = *min_element(nums.<span class="built_in">begin</span>() + first_desc, nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> max_before_last_desc = *max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + last_desc);</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= first_desc; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; min_after_first_desc)</span><br><span class="line">            &#123;</span><br><span class="line">                low = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= last_desc; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; max_before_last_desc)</span><br><span class="line">            &#123;</span><br><span class="line">                high = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high - low + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 595 Big Countries</title>
    <url>/2020/10/25/Leetcode/Leetcode%20595%20Big%20Countries/</url>
    <content><![CDATA[<p>There is a table <code>World</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| name            | continent  | area       | population   | gdp           |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |</span><br><span class="line">| Albania         | Europe     | 28748      | 2831741      | 12960000      |</span><br><span class="line">| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |</span><br><span class="line">| Andorra         | Europe     | 468        | 78115        | 3712000       |</span><br><span class="line">| Angola          | Africa     | 1246700    | 20609294     | 100990000     |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br></pre></td></tr></table></figure>

<p>A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.</p>
<p>Write a SQL solution to output big countries’ name, population and area.</p>
<p>For example, according to the above table, we should output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| name         | population  | area         |</span><br><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| Afghanistan  | 25500100    | 652230       |</span><br><span class="line">| Algeria      | 37100000    | 2381741      |</span><br><span class="line">+--------------+-------------+--------------+</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="select语句的基本使用"><a href="#select语句的基本使用" class="headerlink" title="select语句的基本使用"></a>select语句的基本使用</h2><p>这太简单了, 第一天学SQL就能写出来</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, population, area <span class="keyword">FROM</span> World <span class="keyword">WHERE</span> population &gt; <span class="number">25000000</span> <span class="keyword">OR</span> area &gt; <span class="number">3000000</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 6 Zigzag Conversion</title>
    <url>/2020/09/24/Leetcode/Leetcode%206%20Zigzag%20Conversion/</url>
    <content><![CDATA[<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>

<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>

<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="直接构造"><a href="#直接构造" class="headerlink" title="直接构造"></a>直接构造</h2><p>考虑字符串”0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16”</p>
<p>n=5</p>
<p>那么构造出来的结果就是</p>
<blockquote>
<p>0                8                                        16</p>
<p>1            7    9                                15</p>
<p>2        6            10                    14</p>
<p>3    5                    11        13</p>
<p>4                                12</p>
</blockquote>
<p>发现, 第1行的字符总为 <code>k * (2 * n - 2)</code>. k= 0, 1, 2, 3…这些位置的字符, 例如上面例子中, n = 5, 那么第一行所有的字符就为 0 8 16. 把这些先pushback到一个空的字符串s中.</p>
<p>第<code>i</code>, <code>(0 &lt; i &lt; n)</code>行中, 对应的元素总为 <code>k * (2 * n - 2) + i</code> 和  <code>(k + 1) * (2 * n - 2) - i</code>. 例如上面例子中的(1,7), (9,15). 然后对于每个i, 把这些字符pushback到s中.</p>
<p>最后, 第n-1行的元素总是为 <code>k * (2 * n - 2) + n - 1</code>.  k= 0, 1, 2, 3…. 例如上面例子中的4 12. push到s中即可.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>&amp; n = numRows;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(k * (<span class="number">2</span> * n - <span class="number">2</span>) &lt; len)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(s[k * (<span class="number">2</span> * n - <span class="number">2</span>)]);</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == n - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(k * (<span class="number">2</span> * n - <span class="number">2</span>) + i &lt; len)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(s[k * (<span class="number">2</span> * n - <span class="number">2</span>) + i]);</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k*(<span class="number">2</span>*n<span class="number">-2</span>) + i &lt; len)</span><br><span class="line">                        ans.push_back(s[k*(<span class="number">2</span>*n<span class="number">-2</span>) + i]);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>((k+<span class="number">1</span>)*(<span class="number">2</span>*n<span class="number">-2</span>) - i &lt; len)</span><br><span class="line">                        ans.push_back(s[(k+<span class="number">1</span>)*(<span class="number">2</span>*n<span class="number">-2</span>) - i]);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 605 Can Place Flowers</title>
    <url>/2020/07/27/Leetcode/Leetcode%20605%20Can%20Place%20Flowers/</url>
    <content><![CDATA[<p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p>
<p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number <strong>n</strong>, return if <strong>n</strong> new flowers can be planted in it without violating the no-adjacent-flowers rule.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The input array won’t violate no-adjacent-flowers rule.</li>
<li>The input array size is in the range of [1, 20000].</li>
<li><strong>n</strong> is a non-negative integer which won’t exceed the input array size.</li>
</ol>
<a id="more"></a>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>从左到右依次判断该位置是否能种花<code>flowerbed[i - 1] == 0 &amp;&amp; flowerbed[i + 1] == 0 &amp;&amp; flowerbed[i] == 0</code>. 若能, ++capacity,并且在该位置设置为1. 最后判断capacity和n的大小即可.</p>
<p>注意当n == 0 和 n == flowerbed.size() - 1 时判断条件改为flowerbed[i + 1] == 0 &amp;&amp; flowerbed[i] == 0 和 flowerbed[i - 1] == 0 &amp;&amp; flowerbed[i] == 0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">1</span>) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flowerbed[i + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; flowerbed[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++capacity;</span><br><span class="line">                    flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == flowerbed.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flowerbed[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; flowerbed[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++capacity;</span><br><span class="line">                    flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flowerbed[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; flowerbed[i + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; flowerbed[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++capacity;</span><br><span class="line">                    flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> capacity &gt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 596 Classes More Than 5 Students</title>
    <url>/2020/10/25/Leetcode/Leetcode%20596%20Classes%20More%20Than%205%20Students/</url>
    <content><![CDATA[<p>There is a table <code>courses</code> with columns: <strong>student</strong> and <strong>class</strong></p>
<p>Please list out all classes which have more than or equal to 5 students.</p>
<p>For example, the table:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+------------+</span><br><span class="line">| student | class      |</span><br><span class="line">+---------+------------+</span><br><span class="line">| A       | Math       |</span><br><span class="line">| B       | English    |</span><br><span class="line">| C       | Math       |</span><br><span class="line">| D       | Biology    |</span><br><span class="line">| E       | Math       |</span><br><span class="line">| F       | Computer   |</span><br><span class="line">| G       | Math       |</span><br><span class="line">| H       | Math       |</span><br><span class="line">| I       | Math       |</span><br><span class="line">+---------+------------+</span><br></pre></td></tr></table></figure>

<p>Should output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| class   |</span><br><span class="line">+---------+</span><br><span class="line">| Math    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong><br>The students should not be counted duplicate in each course.</p>
<a id="more"></a>
<h2 id="GROUP-BY的使用"><a href="#GROUP-BY的使用" class="headerlink" title="GROUP BY的使用"></a>GROUP BY的使用</h2><p>按照class分组, 统计每个组的学生个数, 选出大于等于5的组来.</p>
<p>但是要注意, 在测试样例中, (A, Math)这样的元组可能出现多次, 不要统计相同的学生和相同的课. 要用COUNT(DISTINCT name)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">class</span> <span class="keyword">FROM</span> courses <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">class</span> <span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span> student) &gt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 61 Rotate List</title>
    <url>/2020/09/25/Leetcode/Leetcode%2061%20Rotate%20List/</url>
    <content><![CDATA[<p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</span><br><span class="line">Output: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>首先要遍历一遍链表求出长度len,</p>
<p>然后更新k = k % len. 因为假如k是len的整数倍的话, 旋转k次等于回到了原链表.</p>
<p>**然后, 我们只需要将原链表的最后k个node分离出来当成一个新的链表, 整体地插入到原链表头部即可 . **(当然, 原链表的倒数k+1个节点的next域要置为null)</p>
<ul>
<li>先使用快慢指针, 求得倒数第k+1个节点.</li>
<li>记录下倒数第k个节点的指针ans, 作为新链表的头部.</li>
<li>然后将倒数第k+1个节点的next置为null</li>
<li>最后将原链表插入到新链表的尾部</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode <span class="built_in">list</span> = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">list</span> != null)</span><br><span class="line">        &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            <span class="built_in">list</span> = <span class="built_in">list</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        k = k % len;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode listHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode fast = listHead;</span><br><span class="line">        ListNode slow = listHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != null)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode ans = slow.next;</span><br><span class="line">        ListNode ansTail = ans;</span><br><span class="line">        slow.next = null;</span><br><span class="line">        <span class="keyword">while</span>(ansTail.next != null)</span><br><span class="line">        &#123;</span><br><span class="line">            ansTail = ansTail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ansTail.next = head;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 611 Valid Triangle Number</title>
    <url>/2020/08/18/Leetcode/Leetcode%20611%20Valid%20Triangle%20Number/</url>
    <content><![CDATA[<p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,3,4]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Valid combinations are: </span><br><span class="line">2,3,4 (using the first 2)</span><br><span class="line">2,3,4 (using the second 2)</span><br><span class="line">2,2,3</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The length of the given array won’t exceed 1000.</li>
<li>The integers in the given array are in the range of [0, 1000].</li>
</ol>
<a id="more"></a>
<h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1 二分查找"></a>1 二分查找</h2><p>先排序, 确定任意前2个边, 再统计第3个边的可能的个数. 最后加起来</p>
<p>O(n^2logn)复杂度. 确定前两个边n^2, 找第三个边的数量logn</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = lower_bound(nums.<span class="built_in">begin</span>() + j + <span class="number">1</span>, nums.<span class="built_in">end</span>(), nums[i] + nums[j]);</span><br><span class="line">                <span class="keyword">int</span> k = it - nums.<span class="built_in">begin</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> count = k - j;</span><br><span class="line">                ans += count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-改进的查找"><a href="#2-改进的查找" class="headerlink" title="2 改进的查找"></a>2 改进的查找</h2><p>观察1, 发现每次确定一个i,j后, 都要从[j+1, end)中查找最后一个满足nums[i] + nums[j] &lt; nums[k]的k</p>
<p>但是, 随着j的迭代, 上面的范围可以逐渐缩小.</p>
<p>假设某一次找到了相应的k, 下一次j=j+1的迭代时, 新的k肯定是在原来的k的后面. 利用这一点可以复杂度变为n^2.(对于每一个固定的i, j和k都会以<strong>不后退</strong>的方式前进到end, 所以固定i后每一次复杂度为O(n))</p>
<p>同时还要剔除nums中的0, 因为含有0的三个边不可能组成三角形</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> k = i + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(k != nums.<span class="built_in">size</span>() &amp;&amp; nums[i] + nums[j] &gt; nums[k])</span><br><span class="line">                    ++k;</span><br><span class="line">                <span class="keyword">int</span> count = k - j - <span class="number">1</span>;</span><br><span class="line">                ans += count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 62 Unique Paths</title>
    <url>/2020/08/04/Leetcode/Leetcode%2062%20Unique%20Paths/</url>
    <content><![CDATA[<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"><br>Above is a 7 x 3 grid. How many possible unique paths are there?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down</span><br><span class="line">2. Right -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>It’s guaranteed that the answer will be less than or equal to <code>2 * 10 ^ 9</code>.</li>
</ul>
<a id="more"></a>
<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1 动态规划"></a>1 动态规划</h2><p>显然是从(i, j)到终点的可能路径数量等于 (i + 1, j)到终点的可能路径数 加上 (i, j + 1)到终点的可能路径数. 直接动态规划即可</p>
<p>时间复杂度m*n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">grid</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">-1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> uniquePaths(grid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> delimiterMark = <span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == grid.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; j == grid.front().<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isLocationValid(grid,i,j))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] != delimiterMark)</span><br><span class="line">            <span class="keyword">return</span> grid[i][j];</span><br><span class="line">        <span class="keyword">int</span> right = uniquePaths(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> down = uniquePaths(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        grid[i][j] = right + down;</span><br><span class="line">        <span class="keyword">return</span> grid[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLocationValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; grid.<span class="built_in">size</span>() &amp;&amp; j &lt; grid.front().<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-排列组合"><a href="#2-排列组合" class="headerlink" title="2 排列组合"></a>2 排列组合</h2><p>因为机器最后的目标是右下角，向下几步，向右几步都是固定的，</p>
<p>所以一共需要向下走m - 1步, 向右走n - 1步, 总共走m + n - 2步. 所以在这m + n - 2步里面挑m - 1步向下即可.</p>
<p>​                                                                                  $C_{m+n-2}^{m-1} = \frac{(m+n-2)!}{(m-1)!(n-1)!}$</p>
<p>时间复杂度O(m + n). <strong>虽然这题一看就是动态规划, 但是被动态规划限制了思维, 没有更进一步考虑复杂度更低的算法, 不得不佩服大佬们敏锐的思维! 😞😞</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> round(tgamma(m+n<span class="number">-1</span>) / (tgamma(m) * tgamma(n)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 617 Merge Two Binary Trees</title>
    <url>/2020/10/04/Leetcode/Leetcode%20617%20Merge%20Two%20Binary%20Trees/</url>
    <content><![CDATA[<p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>
<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">    Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">         3</span><br><span class="line">        &#x2F; \</span><br><span class="line">       4   5</span><br><span class="line">      &#x2F; \   \ </span><br><span class="line">     5   4   7</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p>
<a id="more"></a>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(t1 != <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(t1.val + t2.val, mergeTrees(t1.left,t2.left), mergeTrees(t1.right, t2.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 627 Swap Salary</title>
    <url>/2020/10/25/Leetcode/Leetcode%20627%20Swap%20Salary/</url>
    <content><![CDATA[<p>Given a table <code>salary</code>, such as the one below, that has m=male and f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a <strong>single update statement</strong> and no intermediate temp table.</p>
<p>Note that you must write a single update statement, <strong>DO NOT</strong> write any select statement for this problem.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | m   | 2500   |</span><br><span class="line">| 2  | B    | f   | 1500   |</span><br><span class="line">| 3  | C    | m   | 5500   |</span><br><span class="line">| 4  | D    | f   | 500    |</span><br></pre></td></tr></table></figure>

<p>After running your <strong>update</strong> statement, the above salary table should have the following rows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | f   | 2500   |</span><br><span class="line">| 2  | B    | m   | 1500   |</span><br><span class="line">| 3  | C    | f   | 5500   |</span><br><span class="line">| 4  | D    | m   | 500    |</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="CASE语句"><a href="#CASE语句" class="headerlink" title="CASE语句"></a>CASE语句</h2><p>不知道case之前完全没思路, 知道了之后就很简单了. case…when…then…else…end.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">UPDATE</span> salary <span class="keyword">SET</span> sex = <span class="keyword">CASE</span> sex <span class="keyword">WHEN</span> <span class="string">&#x27;m&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;f&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;m&#x27;</span> <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h2 id="转化为ascii"><a href="#转化为ascii" class="headerlink" title="转化为ascii"></a>转化为ascii</h2><p>答案来源于<a href="https://leetcode-cn.com/problems/swap-salary/solution/zi-mu-he-asciihu-zhuan-by-rachy/">https://leetcode-cn.com/problems/swap-salary/solution/zi-mu-he-asciihu-zhuan-by-rachy/</a></p>
<p>很棒的解法!</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> salary <span class="keyword">set</span> sex = <span class="built_in">char</span>(<span class="keyword">ascii</span>(<span class="string">&#x27;m&#x27;</span>) + <span class="keyword">ascii</span>(<span class="string">&#x27;f&#x27;</span>) - <span class="keyword">ascii</span>(sex));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 620 Not Boring Movies</title>
    <url>/2020/10/25/Leetcode/Leetcode%20620%20Not%20Boring%20Movies/</url>
    <content><![CDATA[<p>X city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.</p>
<p>Please write a SQL query to output movies with an odd numbered ID and a description that is not ‘boring’. Order the result by rating.</p>
<p>For example, table <code>cinema</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">|   2     | Science   |   fiction    |   8.5     |</span><br><span class="line">|   3     | irish     |   boring     |   6.2     |</span><br><span class="line">|   4     | Ice song  |   Fantacy    |   8.6     |</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure>

<p>For the example above, the output should be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="直接查询即可"><a href="#直接查询即可" class="headerlink" title="直接查询即可"></a>直接查询即可</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> cinema <span class="keyword">WHERE</span> <span class="keyword">id</span> % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">AND</span> description != <span class="string">&#x27;boring&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> rating <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 626 Exchange Seats</title>
    <url>/2020/10/29/Leetcode/Leetcode%20626%20Exchange%20Seats/</url>
    <content><![CDATA[<p>Mary is a teacher in a middle school and she has a table <code>seat</code> storing students’ names and their corresponding seat ids.</p>
<p>The column <strong>id</strong> is continuous increment.</p>
<p>Mary wants to change seats for the adjacent students.</p>
<p>Can you write a SQL query to output the result for Mary?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Abbot   |</span><br><span class="line">|    2    | Doris   |</span><br><span class="line">|    3    | Emerson |</span><br><span class="line">|    4    | Green   |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure>

<p>For the sample input, the output is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Doris   |</span><br><span class="line">|    2    | Abbot   |</span><br><span class="line">|    3    | Green   |</span><br><span class="line">|    4    | Emerson |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>If the number of students is odd, there is no need to change the last one’s seat.</p>
<a id="more"></a>
<h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> t.id, (</span><br><span class="line"><span class="keyword">select</span> student <span class="keyword">from</span> seat <span class="keyword">as</span> t1 <span class="keyword">where</span> t1.id = </span><br><span class="line">    (<span class="keyword">case</span> <span class="keyword">when</span> t.id % <span class="number">2</span> = <span class="number">0</span> <span class="keyword">then</span> t.id - <span class="number">1</span> </span><br><span class="line">         <span class="keyword">when</span> t.id % <span class="number">2</span> = <span class="number">1</span> <span class="keyword">and</span> t.id &lt; (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> seat) <span class="keyword">then</span> t.id + <span class="number">1</span></span><br><span class="line">         <span class="keyword">else</span> t.id <span class="keyword">end</span>)</span><br><span class="line">) <span class="keyword">as</span> student <span class="keyword">from</span> seat <span class="keyword">as</span> t;</span><br></pre></td></tr></table></figure>

<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> t.id, (<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">id</span> % <span class="number">2</span> = <span class="number">0</span> <span class="keyword">then</span> lastStudent <span class="keyword">else</span> nextStudent <span class="keyword">end</span>) <span class="keyword">as</span> student</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">id</span>, student,</span><br><span class="line">        lag(student, <span class="number">1</span>, student) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>) <span class="keyword">as</span> lastStudent,</span><br><span class="line">        <span class="keyword">lead</span>(student, <span class="number">1</span>, student) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>) <span class="keyword">as</span> nextStudent</span><br><span class="line"><span class="keyword">from</span> seat) <span class="keyword">as</span> t;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 64 Minimum Path Sum</title>
    <url>/2020/08/04/Leetcode/Leetcode%2064%20Minimum%20Path%20Sum/</url>
    <content><![CDATA[<p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p>
<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-动态规划1"><a href="#1-动态规划1" class="headerlink" title="1 动态规划1"></a>1 动态规划1</h2><p><code>dist[i][j] = min(dist[i][j + 1], dist[i + 1][j]) + grid[i][j]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dist</span><span class="params">(grid.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(grid.front().<span class="built_in">size</span>(), <span class="number">-1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> minPathSum(dist, grid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dist, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> delimiterMark = <span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == grid.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; j == grid.front().<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[i][j];</span><br><span class="line">        <span class="keyword">if</span>(!isLocationValid(grid, i, j))</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(dist[i][j] != delimiterMark)</span><br><span class="line">            <span class="keyword">return</span> dist[i][j];</span><br><span class="line">        <span class="keyword">int</span> right = minPathSum(dist, grid, i, j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> down = minPathSum(dist, grid, i+<span class="number">1</span>, j);</span><br><span class="line">        dist[i][j] = <span class="built_in">min</span>(right, down) + grid[i][j];</span><br><span class="line">        <span class="keyword">return</span> dist[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLocationValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; grid.<span class="built_in">size</span>() &amp;&amp; j &lt; grid.front().<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划2"><a href="#2-动态规划2" class="headerlink" title="2 动态规划2"></a>2 动态规划2</h2><p>对于这个题, 可以直接将dist信息储存在grid中, grid遍历过的储存的就是dist, 没有遍历过的还是储存的原来的值. 这样不需要new一个二维数组. </p>
<p>依次计算(i,j)到(0,0)的距离, 返回grid[m-1][n-1]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = grid.front().<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[i][j] += <span class="built_in">min</span>(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 643 Maximum Average Subarray I</title>
    <url>/2020/07/29/Leetcode/Leetcode%20643%20Maximum%20Average%20Subarray%20I/</url>
    <content><![CDATA[<p>Given an array consisting of <code>n</code> integers, find the contiguous subarray of given length <code>k</code> that has the maximum average value. And you need to output the maximum average value.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,12,-5,-6,50,3], k &#x3D; 4</span><br><span class="line">Output: 12.75</span><br><span class="line">Explanation: Maximum average is (12-5-6+50)&#x2F;4 &#x3D; 51&#x2F;4 &#x3D; 12.75</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>1 &lt;= <code>k</code> &lt;= <code>n</code> &lt;= 30,000.</li>
<li>Elements of the given array will be in the range [-10,000, 10,000].</li>
</ol>
<a id="more"></a>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>直接从左到右依次出现的k个子数组的average即可</p>
<p>注意计算后一个窗口的sum可以利用前一个窗口的sum信息, sum = sum_previous - nums[i - 1] + nums[i - 1 + k]</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> || nums.<span class="built_in">size</span>() &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;InputException&quot;</span>);</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">int</span> sumOfPrevious = accumulate(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">double</span> maxAvg = (<span class="keyword">double</span>)sumOfPrevious / (<span class="keyword">double</span>)k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; nums.<span class="built_in">begin</span>() + i + k - <span class="number">1</span> != nums.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sumOfNow = sumOfPrevious - nums[i - <span class="number">1</span>] + nums[i + k - <span class="number">1</span>];</span><br><span class="line">            sumOfPrevious = sumOfNow;</span><br><span class="line">            <span class="keyword">double</span> tmp = (<span class="keyword">double</span>)sumOfNow / (<span class="keyword">double</span>)k;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; maxAvg)</span><br><span class="line">                maxAvg = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAvg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 628 Maximum Product Of Three Numbers</title>
    <url>/2020/07/29/Leetcode/Leetcode%20628%20Maximum%20Product%20Of%20Three%20Numbers/</url>
    <content><![CDATA[<p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4]</span><br><span class="line">Output: 24</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000].</li>
<li>Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer.</li>
</ol>
<a id="more"></a>
<h2 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h2><p>很容易的就能推测出来最大值肯定是三个最大的数相乘, 或者是一个最大的和两个最小的相乘(考虑存在绝对值很大的负数). 扫描一遍找出来top3最大的和last2最小的即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; top3;</span><br><span class="line">        top3.push(nums[<span class="number">0</span>]);</span><br><span class="line">        top3.push(nums[<span class="number">1</span>]);</span><br><span class="line">        top3.push(nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; top3.top())</span><br><span class="line">            &#123;</span><br><span class="line">                top3.pop();</span><br><span class="line">                top3.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; last2;</span><br><span class="line">        last2.push(nums[<span class="number">0</span>]);</span><br><span class="line">        last2.push(nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; last2.top())</span><br><span class="line">            &#123;</span><br><span class="line">                last2.pop();</span><br><span class="line">                last2.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> smallest2nd = last2.top();</span><br><span class="line">        last2.pop();</span><br><span class="line">        <span class="keyword">int</span> smallest = last2.top();</span><br><span class="line">        <span class="keyword">int</span> largest3rd = top3.top();</span><br><span class="line">        top3.pop();</span><br><span class="line">        <span class="keyword">int</span> largest2nd = top3.top();</span><br><span class="line">        top3.pop();</span><br><span class="line">        <span class="keyword">int</span> largest = top3.top();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(largest * largest2nd * largest3rd, largest * smallest2nd * smallest);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 647 Palindromic Substrings</title>
    <url>/2020/10/07/Leetcode/Leetcode%20647%20Palindromic%20Substrings/</url>
    <content><![CDATA[<p>Given a string, your task is to count how many palindromic substrings in this string.</p>
<p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;aaa&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The input string length won’t exceed 1000.</li>
</ol>
<a id="more"></a>
<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1 动态规划"></a>1 动态规划</h2><p>这题和最长回文字串类似</p>
<p>通过动态规划求出任意的i,j, 字串s(i,j)是不是palindrome的. 然后再统计所有的palindrome字串个数.</p>
<p>时间复杂度O(n^2) 空间复杂度也是平方级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = (s.charAt(i) == s.charAt(i+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">2</span>; c &lt; n; ++c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + c &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i+c] = dp[i+<span class="number">1</span>][i+c-<span class="number">1</span>] &amp;&amp; (s.charAt(i) == s.charAt(i+c));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j)</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])</span><br><span class="line">                    ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-中心扩展"><a href="#2-中心扩展" class="headerlink" title="2 中心扩展"></a>2 中心扩展</h2><p>最长回文字串的中心扩展法类似</p>
<p>空间复杂度减少到了O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> right = i;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; -<span class="number">1</span> &amp;&amp; right &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(left) == s.charAt(right))</span><br><span class="line">                &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                    --left;</span><br><span class="line">                    ++right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; -<span class="number">1</span> &amp;&amp; right &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(left) == s.charAt(right))</span><br><span class="line">                &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                    --left;</span><br><span class="line">                    ++right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 63 Unique Paths II</title>
    <url>/2020/08/04/Leetcode/Leetcode%2063%20Unique%20Paths%20II/</url>
    <content><![CDATA[<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p>
<p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>
<p><strong>Note:</strong> <em>m</em> and <em>n</em> will be at most 100.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">There is one obstacle in the middle of the 3x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>和leetcode 62相同的方法. 只不过要加一个判断是不是obstacle的条件. 若(i,j)是obstacle, 那么(i,j)到终点的可能的路径数为0.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">paths</span><span class="params">(obstacleGrid.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(obstacleGrid.front().<span class="built_in">size</span>(), <span class="number">-1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> uniquePathsWithObstacles(paths, obstacleGrid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> delimiterMark = <span class="number">-1</span>, <span class="keyword">int</span> obstacleMark = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == obstacleGrid.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; j == obstacleGrid.front().<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> obstacleGrid[i][j] == obstacleMark ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isLocationValid(obstacleGrid, i, j))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(paths[i][j] != delimiterMark)</span><br><span class="line">            <span class="keyword">return</span> paths[i][j];</span><br><span class="line">        <span class="keyword">int</span> right = uniquePathsWithObstacles(paths, obstacleGrid, i, j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> down = uniquePathsWithObstacles(paths, obstacleGrid, i+<span class="number">1</span>, j);</span><br><span class="line">        paths[i][j] = right + down;</span><br><span class="line">        <span class="keyword">return</span> paths[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLocationValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> delimiterMark = <span class="number">-1</span>, <span class="keyword">int</span> obstacleMark = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; obstacleGrid.<span class="built_in">size</span>() &amp;&amp; j &lt; obstacleGrid.front().<span class="built_in">size</span>() &amp;&amp; obstacleGrid[i][j] != obstacleMark;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 65 Valid Number</title>
    <url>/2020/09/28/Leetcode/Leetcode%2065%20Valid%20Number/</url>
    <content><![CDATA[<p>Validate if a given string can be interpreted as a decimal number.</p>
<p>Some examples:<br><code>&quot;0&quot;</code> =&gt; <code>true</code><br><code>&quot; 0.1 &quot;</code> =&gt; <code>true</code><br><code>&quot;abc&quot;</code> =&gt; <code>false</code><br><code>&quot;1 a&quot;</code> =&gt; <code>false</code><br><code>&quot;2e10&quot;</code> =&gt; <code>true</code><br><code>&quot; -90e3  &quot;</code> =&gt; <code>true</code><br><code>&quot; 1e&quot;</code> =&gt; <code>false</code><br><code>&quot;e3&quot;</code> =&gt; <code>false</code><br><code>&quot; 6e-1&quot;</code> =&gt; <code>true</code><br><code>&quot; 99e2.5 &quot;</code> =&gt; <code>false</code><br><code>&quot;53.5e93&quot;</code> =&gt; <code>true</code><br><code>&quot; --6 &quot;</code> =&gt; <code>false</code><br><code>&quot;-+3&quot;</code> =&gt; <code>false</code><br><code>&quot;95a54e53&quot;</code> =&gt; <code>false</code></p>
<p><strong>Note:</strong> It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:</p>
<ul>
<li>Numbers 0-9</li>
<li>Exponent - “e”</li>
<li>Positive/negative sign - “+”/“-“</li>
<li>Decimal point - “.”</li>
</ul>
<p>Of course, the context of these characters also matters in the input.</p>
<p><strong>Update (2015-02-10):</strong><br>The signature of the <code>C++</code> function had been updated. If you still see your function signature accepts a <code>const char *</code> argument, please click the reload button to reset your code definition.</p>
<a id="more"></a>
<h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><p>自己不会做, 借鉴于<a href="https://leetcode-cn.com/problems/valid-number/solution/biao-qu-dong-fa-by-user8973/">https://leetcode-cn.com/problems/valid-number/solution/biao-qu-dong-fa-by-user8973/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S0 = <span class="number">0</span>;  <span class="comment">// begin state</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S1 = <span class="number">1</span>;  <span class="comment">// digits before &#x27;e&#x27; and &#x27;.&#x27;, after head &#x27;+/-&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S2 = <span class="number">2</span>; <span class="comment">// state to absorb the first &quot;+/-&quot; before &#x27;e&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S3 = <span class="number">3</span>; <span class="comment">// state that absorb a &quot;.&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S4 = <span class="number">4</span>; <span class="comment">// digits after &#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S5 = <span class="number">5</span>; <span class="comment">// state that absorb &#x27;e&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S6 = <span class="number">6</span>; <span class="comment">// digits after &#x27;e&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S7 = <span class="number">7</span>; <span class="comment">// state that absorb &#x27;+/-&#x27; after &#x27;e&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Serr = -<span class="number">1</span>; <span class="comment">//error state</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; validSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] tran = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,<span class="number">7</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        validSet.add(S0);</span><br><span class="line">        validSet.add(S1);</span><br><span class="line">        validSet.add(S4);</span><br><span class="line">        validSet.add(S6);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">make</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit(ch))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">if</span>(s.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> beginWithDot(s);</span><br><span class="line">        <span class="keyword">int</span> state = S0;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> curr = make(ch);</span><br><span class="line">            <span class="keyword">if</span>(curr == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            state = tran[state][curr];</span><br><span class="line">            <span class="keyword">if</span>(state == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> validSet.contains(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">beginWithDot</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(<span class="number">1</span>) == <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> state = S3;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">                <span class="keyword">int</span> curr = make(ch);</span><br><span class="line">                <span class="keyword">if</span>(curr == -<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                state = tran[state][curr];</span><br><span class="line">                <span class="keyword">if</span>(state == -<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> validSet.contains(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 661 Image Smoother</title>
    <url>/2020/07/29/Leetcode/Leetcode%20661%20Image%20Smoother/</url>
    <content><![CDATA[<p>Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[1,1,1],</span><br><span class="line"> [1,0,1],</span><br><span class="line"> [1,1,1]]</span><br><span class="line">Output:</span><br><span class="line">[[0, 0, 0],</span><br><span class="line"> [0, 0, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line">Explanation:</span><br><span class="line">For the point (0,0), (0,2), (2,0), (2,2): floor(3&#x2F;4) &#x3D; floor(0.75) &#x3D; 0</span><br><span class="line">For the point (0,1), (1,0), (1,2), (2,1): floor(5&#x2F;6) &#x3D; floor(0.83333333) &#x3D; 0</span><br><span class="line">For the point (1,1): floor(8&#x2F;9) &#x3D; floor(0.88888889) &#x3D; 0</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The value in the given matrix is in the range of [0, 255].</li>
<li>The length and width of the given matrix are in the range of [1, 150].</li>
</ol>
<a id="more"></a>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>没什么难的, 判断好是否是边界元素,然后计算就行了</p>
<p>推荐写一个私有方法判断位置是否越界, 要不然if里面的条件太复杂</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">imageSmoother</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = M.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = M.front().<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> mean = M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">                <span class="keyword">if</span>(isLocationValid(i - <span class="number">1</span>, j - <span class="number">1</span>, m, n))</span><br><span class="line">                    tmp.push_back(M[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(isLocationValid(i - <span class="number">1</span>, j, m, n))</span><br><span class="line">                    tmp.push_back(M[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(isLocationValid(i - <span class="number">1</span>, j + <span class="number">1</span>, m, n))</span><br><span class="line">                    tmp.push_back(M[i<span class="number">-1</span>][j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(isLocationValid(i, j - <span class="number">1</span>, m, n))</span><br><span class="line">                    tmp.push_back(M[i][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(isLocationValid(i, j, m, n))</span><br><span class="line">                    tmp.push_back(M[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(isLocationValid(i, j + <span class="number">1</span>, m, n))</span><br><span class="line">                    tmp.push_back(M[i][j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(isLocationValid(i + <span class="number">1</span>, j - <span class="number">1</span>, m, n))</span><br><span class="line">                    tmp.push_back(M[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(isLocationValid(i + <span class="number">1</span>, j, m, n))</span><br><span class="line">                    tmp.push_back(M[i+<span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(isLocationValid(i + <span class="number">1</span>, j + <span class="number">1</span>, m, n))</span><br><span class="line">                    tmp.push_back(M[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">                mean[i][j] = accumulate(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), <span class="number">0</span>) / tmp.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mean;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLocationValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> bound1, <span class="keyword">int</span> bound2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&gt;=<span class="number">0</span> &amp;&amp; i &lt; bound1 &amp;&amp; j &gt;=<span class="number">0</span> &amp;&amp; j &lt;bound2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 66 Plus One</title>
    <url>/2020/07/17/Leetcode/Leetcode%2066%20Plus%20One/</url>
    <content><![CDATA[<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, increment one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure>



<a id="more"></a>
<h2 id="分类讨论"><a href="#分类讨论" class="headerlink" title="分类讨论"></a>分类讨论</h2><p>+　正常情况下末尾加1即可<br>+　若后几位是9，把9替换为0并且在前一位加1<br>+　若全是9，返回一个digits.size()+1的100…000的vector</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isAll9 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digits.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                isAll9 = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isAll9)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vc;</span><br><span class="line">            vc.push_back(<span class="number">1</span>);</span><br><span class="line">            vc.insert(vc.<span class="built_in">end</span>(), digits.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> vc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(digits[i] != <span class="number">9</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++digits[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    digits[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 665 Non Decreasing Array</title>
    <url>/2020/07/30/Leetcode/Leetcode%20665%20Non%20Decreasing%20Array/</url>
    <content><![CDATA[<p>Given an array <code>nums</code> with <code>n</code> integers, your task is to check if it could become non-decreasing by modifying <strong>at most</strong> <code>1</code> element.</p>
<p>We define an array is non-decreasing if <code>nums[i] &lt;= nums[i + 1]</code> holds for every <code>i</code> (0-based) such that <code>(0 &lt;= i &lt;= n - 2)</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,2,3]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [4,2,1]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You can&#39;t get a non-decreasing array by modify at most one element.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10 ^ 4</code></li>
<li><code>- 10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5</code></li>
</ul>
<a id="more"></a>
<h2 id="分类讨论"><a href="#分类讨论" class="headerlink" title="分类讨论"></a>分类讨论</h2><p>首先找到数组中第一个递减元素的索引first_descending_index = the first i that enable <code>nums[i] &lt; nums[i-1]</code>.  i from 1 to nums.size() - 1</p>
<ul>
<li>如果first_descending_index == nums.size(), 那么这个数组本来就是递增的. 返回true</li>
<li>如果first_descending_index == nums.size() - 1, 那么这个数组除了最后一个元素之外是递增的, 将最后一个元素置为INT_MAX也能满足要求. 返回true</li>
</ul>
<p>下面为简洁起见将first_descending_index记为fdi. fdi必定在数组内部(不是第一个和最后一个位置). 考虑fdi相邻的两个元素, 并且已知<code>nums[fdi] &lt; nums[fdi - 1]</code></p>
<ul>
<li>若 <code>nums[fdi + 1] &lt; nums[fdi]</code>, 则有<code>nums[fdi + 1] &lt; nums[fdi] &lt; nums[fdi - 1]</code>. 例如[4, 3, 2] 此时无论如何也不能做到修改一个元素后将数组变为ascending的. 返回false</li>
<li>若<code>nums[fdi + 1] &gt; nums[fdi - 1]</code>, 则有<code>nums[fdi] &lt; nums[fdi - 1] &lt; nums[fdi + 1]</code>.  例如[4,3,7] 这时将nums[fdi]修改为<code>nums[fdi] = nums[fdi - 1]</code>, 即可使得在fdi的邻域保持ascending. 但我们还不知道fdi后面的元素是不是为递增的(如果不是, 就至少要修改2次). 所以要判断修改之后的数组是不是递增的. 如果不是, 说明1次的修改是不能将数组变为ascending的. 返回false</li>
<li>若<code>nums[fdi + 1] &gt;= nums[fdi] &amp;&amp; nums[fdi + 1] &lt;= nums[fdi - 1]</code>, 即nums[fdi] &lt; nums[fdi + 1] &lt; nums[fdi - 1]. 例如[6, 2, 3]. <strong>此时只能修改nums[fdi - 1]<code>nums[fdi - 1] = nums[fdi]</code>. (修改nums[fdi+1]或nums[fdi]都不能使这三个元素变为ascending.  [6,2,3]中只能修改6)</strong>. 但是这样会造成前面已经ascending的元素disordered. 在[1,6,2,3]中将4修改为2是可行的. 但是在[4,6,2,3]中将6修改为2是不可行的. 所以还是要判断修改之后的元素是不是递增的.如果不是,返回false</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> || nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> first_descending_index = i;</span><br><span class="line">        <span class="keyword">if</span>(first_descending_index == nums.<span class="built_in">size</span>() || first_descending_index == nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>&amp; fdi = first_descending_index;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[fdi + <span class="number">1</span>] &lt; nums[fdi])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[fdi + <span class="number">1</span>] &gt; nums[fdi - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[fdi] = nums[fdi - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> isAscending(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[fdi + <span class="number">1</span>] &gt;= nums[fdi] &amp;&amp; nums[fdi + <span class="number">1</span>] &lt;= nums[fdi - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[fdi - <span class="number">1</span>] = nums[fdi];</span><br><span class="line">            <span class="keyword">return</span> isAscending(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;In no case you could enter this clause; some logical errors must occur before!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAscending</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 67 Add Binary</title>
    <url>/2020/09/20/Leetcode/Leetcode%2067%20Add%20Binary/</url>
    <content><![CDATA[<p>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or <code>0</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;</span><br><span class="line">Output: &quot;10101&quot;</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>Each string consists only of <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code> characters.</li>
<li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li>
<li>Each string is either <code>&quot;0&quot;</code> or doesn’t contain any leading zero.</li>
</ul>
<a id="more"></a>
<h2 id="进位加法"><a href="#进位加法" class="headerlink" title="进位加法"></a>进位加法</h2><p>仿照Leetcode 43 中的进位加法即可.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">size</span>() &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="built_in">string</span>(len - a.<span class="built_in">size</span>(), <span class="string">&#x27;0&#x27;</span>) + a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            b = <span class="built_in">string</span>(len - b.<span class="built_in">size</span>(), <span class="string">&#x27;0&#x27;</span>) + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (a[i] - <span class="string">&#x27;0&#x27;</span>) + (b[i] - <span class="string">&#x27;0&#x27;</span>) + carry;</span><br><span class="line">            carry = sum / <span class="number">2</span>;</span><br><span class="line">            ans.push_back(sum % <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">            ans.push_back(carry);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: ans)</span><br><span class="line">            i += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(ans.rbegin(), ans.rend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 670 Maximum Swap</title>
    <url>/2020/08/20/Leetcode/Leetcode%20670%20Maximum%20Swap/</url>
    <content><![CDATA[<p>Given a non-negative integer, you could swap two digits <strong>at most</strong> once to get the maximum valued number. Return the maximum valued number you could get.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2736</span><br><span class="line">Output: 7236</span><br><span class="line">Explanation: Swap the number 2 and the number 7.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 9973</span><br><span class="line">Output: 9973</span><br><span class="line">Explanation: No swap.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The given number is in the range [0, 10^8]</li>
</ol>
<a id="more"></a>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>首先肯定要把这个整数变成一个数组再处理的. 我这个题用的<code>deque&lt;int&gt;</code>, 但是看了网上的解答觉得转成<code>string</code>更好, 空间由4n字节降为n字节, n为这个数的位数. </p>
<p>思路很简单, 从左到右开始找, 找到第一个不是递减的值记为nums[j], 再从j到最后一位中寻找一个最大的值(如果有多个最大的值, 取后面的那个). 找到最大的值M之后, 数组中的元素从左到右和M比较, 如果大于等于M, 就向后继续找, 直到找到一个比M小的值, 这个值和M交换, 即为所求</p>
<p>举例: </p>
<blockquote>
<p> 9870  因为一直递减, 所以不用交换</p>
<p> 9708, 第一个不是递减的元素是0, 从元素0开始到最后一个元素的范围, 最大的是8, M=8, 从左到右找, 第一个小于8的是7, 所以7和8交换得到9807</p>
<p>1993, 第一个不是递减的元素是1, 从元素1到最后一个元素的范围中, 最大的是9, 但是这时候要选择靠后面的9, 用靠后面的9与1交换, 得到9913, 否则将会得到错误的解9193.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; nums = int2deque(num);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator maxIt;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">max</span> = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator j = nums.<span class="built_in">begin</span>() + i; j != nums.<span class="built_in">end</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(*j &gt;= <span class="built_in">max</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">max</span> = *j;</span><br><span class="line">                    maxIt = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator <span class="built_in">begin</span> = nums.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(*<span class="built_in">begin</span> &gt;= *maxIt)</span><br><span class="line">                ++<span class="built_in">begin</span>;</span><br><span class="line">            swap(*<span class="built_in">begin</span>, *maxIt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque2int(nums);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> scaleSystemBaseInt2Array = <span class="number">10</span>;  <span class="comment">// Decimal system</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> scaleSystemBaseArray2Int = <span class="number">10</span>;  <span class="comment">// Decimal system</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deque2int</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> scaleSystemBase = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nums.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            a = a * scaleSystemBaseArray2Int + nums.front();</span><br><span class="line">            nums.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">int2deque</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_front(a % scaleSystemBaseInt2Array);</span><br><span class="line">            a /= scaleSystemBaseInt2Array;</span><br><span class="line">        &#125;<span class="keyword">while</span>(a &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 674 Longest Continuous Increasing Subsequence</title>
    <url>/2020/07/29/Leetcode/Leetcode%20674%20Longest%20Continuous%20Increasing%20Subsequence/</url>
    <content><![CDATA[<p>Given an unsorted array of integers, find the length of longest <code>continuous</code> increasing subsequence (subarray).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,4,7]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. </span><br><span class="line">Even though [1,3,5,7] is also an increasing subsequence, it&#39;s not a continuous one where 5 and 7 are separated by 4. </span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,2,2,2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The longest continuous increasing subsequence is [2], its length is 1. </span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong> Length of the array will not exceed 10,000.</p>
<a id="more"></a>
<h2 id="双整数储存信息"><a href="#双整数储存信息" class="headerlink" title="双整数储存信息"></a>双整数储存信息</h2><p>构造两个int, maxLength和currentLength, i从1遍历到nums.size() - 1, maxLength储存截止到现在最长的递增子序列长度, currentLength储存子数组nums[0]到nums[i]中包含nums[i]的最长的递增子序列长度. 若currentLength &gt; maxLength, 则更新maxLength. O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> currentLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                ++currentLength;</span><br><span class="line">                <span class="keyword">if</span>(currentLength &gt; maxLength)</span><br><span class="line">                    maxLength = currentLength;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentLength = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 697 Degree Of An Array</title>
    <url>/2020/07/29/Leetcode/Leetcode%20697%20Degree%20Of%20An%20Array/</url>
    <content><![CDATA[<p>Given a non-empty array of non-negative integers <code>nums</code>, the <strong>degree</strong> of this array is defined as the maximum frequency of any one of its elements.</p>
<p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The input array has a degree of 2 because both elements 1 and 2 appear twice.</span><br><span class="line">Of the subarrays that have the same degree:</span><br><span class="line">[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</span><br><span class="line">The shortest length is 2. So return 2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,2,3,1,4,2]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">The degree is 3 because the element 2 is repeated 3 times.</span><br><span class="line">So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>nums.length</code> will be between 1 and 50,000.</li>
<li><code>nums[i]</code> will be an integer between 0 and 49,999.</li>
</ul>
<a id="more"></a>
<h2 id="1-暴力算法"><a href="#1-暴力算法" class="headerlink" title="1 暴力算法"></a>1 暴力算法</h2><p>先创建个map找到数组的degree(1次遍历), 再找到所有的出现次数为degree的元素(1次遍历, 因为出现次数最多的元素可能不止一个. 假设有k个元素的出现次数最多). 对于每个出现次数最多的元素找到第一次出现的位置和最后一次出现的位置, 由这两个位置计算长度(k次遍历). 再从k个长度里面返回最小的长度.  一共需要k+2次遍历. </p>
<p>但是看完网上各种答案之后, 感觉并没有更好的思路. 所有的思路都是找到所有出现次数为degree的元素, 再从这些元素中计算每个元素的最小长度, 最后取最小值. 有些方法虽然降低了遍历的次数但增加了空间复杂度. 各有利弊吧. 目前没有找到时间或空间低于O(n)的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> || nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++mp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxFrequency = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : mp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second &gt; maxFrequency)</span><br><span class="line">            &#123;</span><br><span class="line">                maxFrequency = i.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; frequencyNumbers;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : mp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second == maxFrequency)</span><br><span class="line">                frequencyNumbers.push_back(i.first);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> frequencyNum : frequencyNumbers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">begin</span> &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="built_in">begin</span>] == frequencyNum)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ++<span class="built_in">begin</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">end</span> &gt; <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="built_in">end</span>] == frequencyNum)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                --<span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len.push_back(<span class="built_in">end</span> - <span class="built_in">begin</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *min_element(len.<span class="built_in">begin</span>(), len.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 69 Sqrtx</title>
    <url>/2020/09/25/Leetcode/Leetcode%2069%20Sqrtx/</url>
    <content><![CDATA[<p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of <em>x</em>, where <em>x</em> is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>将问题转化为, 从0到x中查找最后一个mid使得 mid * mid &lt;= x的元素即可.</p>
<p>同时, 条件中要写<code>mid &lt;= x / mid</code> 而不是<code>mid * mid &lt;= x</code>, 否则mid*mid会溢出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> || x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = x;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid &lt;= x / mid)</span><br><span class="line">            &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> begin - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 7 Reverse Integer</title>
    <url>/2020/08/07/Leetcode/Leetcode%207%20Reverse%20Integer/</url>
    <content><![CDATA[<p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<a id="more"></a>
<h2 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h2><p>不断地求模获得每一位的数字储存起来, 再重组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> isNegative = (x &lt; <span class="number">0</span>);</span><br><span class="line">            x = <span class="built_in">abs</span>(x);</span><br><span class="line">            <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = x % <span class="number">10</span>;</span><br><span class="line">                x = x / <span class="number">10</span>;</span><br><span class="line">                q.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(result &gt; INT_MAX / <span class="number">10</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                result = result * <span class="number">10</span> + tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> isNegative ? -result : result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="常规解法2"><a href="#常规解法2" class="headerlink" title="常规解法2"></a>常规解法2</h2><p>其实不需要new一个queue, 直接在result上更改就可以了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> isNegative = (x &lt; <span class="number">0</span>);</span><br><span class="line">            x = <span class="built_in">abs</span>(x);</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = x % <span class="number">10</span>;</span><br><span class="line">                x = x / <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(result &gt; INT_MAX / <span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                result = result * <span class="number">10</span> + tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> isNegative ? -result : result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 717 One Bit And Two Bit Characters</title>
    <url>/2020/07/29/Leetcode/Leetcode%20717%20One%20Bit%20And%20Two%20Bit%20Characters/</url>
    <content><![CDATA[<p>We have two special characters. The first character can be represented by one bit <code>0</code>. The second character can be represented by two bits (<code>10</code> or <code>11</code>).</p>
<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">bits &#x3D; [1, 0, 0]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: </span><br><span class="line">The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">bits &#x3D; [1, 1, 1, 0]</span><br><span class="line">Output: False</span><br><span class="line">Explanation: </span><br><span class="line">The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<p><code>1 &lt;= len(bits) &lt;= 1000</code>.</p>
<p><code>bits[i]</code> is always <code>0</code> or <code>1</code>.</p>
<a id="more"></a>
<h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>i从左到右依次的解码遍历, 若为1则 i = i + 2, is1bit赋值为false, 0则为i = i + 1, is1bit赋值为true. 遍历完后返回is1bit即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bits.empty() || bits.back() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;Invalid BitStream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> is1bit;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; bits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bits[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                is1bit = <span class="literal">true</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                is1bit = <span class="literal">false</span>;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> is1bit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 70 Climbing Stairs</title>
    <url>/2020/09/25/Leetcode/Leetcode%2070%20Climbing%20Stairs/</url>
    <content><![CDATA[<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>很容易发现, 记f(n)为上第n层楼梯的方法数量, 则有f(n) = f(n-1) + f(n-2). f(0) = 1, f(1) = 1.</p>
<p>动态规划出f(n)即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 71 Simplify Path</title>
    <url>/2020/10/21/Leetcode/Leetcode%2071%20Simplify%20Path/</url>
    <content><![CDATA[<p>Given an <strong>absolute path</strong> for a file (Unix-style), simplify it. Or in other words, convert it to the <strong>canonical path</strong>.</p>
<p>In a UNIX-style file system, a period <code>.</code> refers to the current directory. Furthermore, a double period <code>..</code> moves the directory up a level.</p>
<p>Note that the returned canonical path must always begin with a slash <code>/</code>, and there must be only a single slash <code>/</code> between two directory names. The last directory name (if it exists) <strong>must not</strong> end with a trailing <code>/</code>. Also, the canonical path must be the <strong>shortest</strong> string representing the absolute path.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;home&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;home&quot;</span><br><span class="line">Explanation: Note that there is no trailing slash after the last directory name.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;..&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;&quot;</span><br><span class="line">Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;home&#x2F;&#x2F;foo&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;home&#x2F;foo&quot;</span><br><span class="line">Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;..&#x2F;..&#x2F;b&#x2F;..&#x2F;c&#x2F;&#x2F;.&#x2F;&#x2F;&quot;</span><br><span class="line">Output: &quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 6:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#x2F;a&#x2F;&#x2F;b&#x2F;&#x2F;&#x2F;&#x2F;c&#x2F;d&#x2F;&#x2F;.&#x2F;.&#x2F;&#x2F;..&quot;</span><br><span class="line">Output: &quot;&#x2F;a&#x2F;b&#x2F;c&quot;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-利用StringBuilder"><a href="#1-利用StringBuilder" class="headerlink" title="1 利用StringBuilder"></a>1 利用StringBuilder</h2><p>首先用split方法分割”/“得到字符串数组strings</p>
<p>首先建立一个空的stringbuilder sb</p>
<p>下面依次处理strings里面的字符串</p>
<p>对于<code>&quot;.&quot;</code>和<code>&quot;&quot;</code>, 直接跳过不做处理.</p>
<p>对于一般的字符串s, 如果sb为空或者sb最后一个字符不是”/“, 就要append上”/s”, 反之, 只需要append上”s”</p>
<p>对于<code>&quot;..&quot;</code>, 寻找sb中<strong>最后一个</strong>“/“的位置lastSlashIndex, 如果lastSlashIndex == -1, 就跳过. 否则, 删除lastSlashIndex到末尾的所有字符.</p>
<p>最后返回sb.toString(). 如果sb.toString() 为<code>&quot;&quot;</code>, 就返回<code>&quot;/&quot;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(path))</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String[] strings = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String string : strings)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(string) || <span class="string">&quot;.&quot;</span>.equals(string))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;..&quot;</span>.equals(string))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> lastSlashIndex = sb.lastIndexOf(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(lastSlashIndex &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sb.delete(lastSlashIndex, sb.length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sb.length() == <span class="number">0</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                    sb.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                sb.append(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = sb.toString();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.equals(ans) ? <span class="string">&quot;/&quot;</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-利用list"><a href="#2-利用list" class="headerlink" title="2 利用list"></a>2 利用list</h2><p>上面的过程完全可以转化成list. 并且在碰到<code>&quot;..&quot;</code>的情况时效率更高(因为不用找最后一个”/“了). 但是在字符串拼接上string会比stringbuilder慢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(path))</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] strings = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String string : strings)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(string) || <span class="string">&quot;.&quot;</span>.equals(string))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;..&quot;</span>.equals(string))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(list.isEmpty())</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                list.add(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String i : list)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            sb.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 724 Find Pivot Index</title>
    <url>/2020/07/30/Leetcode/Leetcode%20724%20Find%20Pivot%20Index/</url>
    <content><![CDATA[<p>Given an array of integers <code>nums</code>, write a method that returns the “pivot” index of this array.</p>
<p>We define the pivot index as the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index.</p>
<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,7,3,6,5,6]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The sum of the numbers to the left of index 3 (nums[3] &#x3D; 6) is equal to the sum of numbers to the right of index 3.</span><br><span class="line">Also, 3 is the first index where this occurs.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">There is no index that satisfies the conditions in the problem statement.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The length of <code>nums</code> will be in the range <code>[0, 10000]</code>.</li>
<li>Each element <code>nums[i]</code> will be an integer in the range <code>[-1000, 1000]</code>.</li>
</ul>
<a id="more"></a>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>维护两个值leftSum和rightSum, 一开始假设i = 0. i左边没有元素,所以leftsum = 0; i右边的和为<code>accumulate(nums.begin() + 1, nums.end(), 0)</code>. 依次判断leftsum和rightsum是否相等. 相等则直接返回i, 不相等i需要向后移动一位, 这时不用重新计算新的leftsum和rightsum, 只需要在i移动到i+1之前, 将leftsum += nums[i] 和rightsum -= nums[i+1]即可求的新的leftsum,rightsum.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightSum = accumulate(nums.<span class="built_in">begin</span>() + <span class="number">1</span>, nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(leftSum != rightSum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            leftSum += nums[i];</span><br><span class="line">            rightSum -= nums[i + <span class="number">1</span>];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 74 Search A 2d Matrix</title>
    <url>/2020/09/20/Leetcode/Leetcode%2074%20Search%20A%202d%20Matrix/</url>
    <content><![CDATA[<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix &#x3D; [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target &#x3D; 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix &#x3D; [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target &#x3D; 13</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="1-2次二分查找"><a href="#1-2次二分查找" class="headerlink" title="1 2次二分查找"></a>1 2次二分查找</h2><p>先二分查找target所在的行号row, 然后在row中二分查找target. </p>
<p>对于第一次二分查找, 若target大于mid行中的最后一个元素, 说明在mid行之后, 若小于mid行中的第0个元素, 说明在mid行之前, 否则就是在mid行里</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix.front().empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = matrix.front().<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[m<span class="number">-1</span>][n<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">begin</span> &lt;= <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; matrix[mid][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[mid][n<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">begin</span> = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                row = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> binary_search(matrix[row].<span class="built_in">begin</span>(), matrix[row].<span class="built_in">end</span>(), target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-1次二分查找"><a href="#2-1次二分查找" class="headerlink" title="2 1次二分查找"></a>2 1次二分查找</h2><p>将矩阵想象成一个长的数组, 对这个数组用二分查找. 只不过在寻址的时候要变换一下</p>
<p><strong>长数组中第i个元素为矩阵中 第 i / n 行 第 i % n 列的元素 (n是矩阵列数)</strong></p>
<p>是**”计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”**的思想的应用 在这个题中, 中间层即为函数get1DValue(), 给调用的人一种假象, 用的就是一维数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get1DValue</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> matrix[index / matrix.front().<span class="built_in">size</span>()][index % matrix.front().<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix.front().empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; matrix.front().front() || target &gt; matrix.back().back())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = matrix.front().<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = m * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">begin</span> &lt;= <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> midValue = get1DValue(matrix, mid);</span><br><span class="line">            <span class="keyword">if</span>(target &gt; midValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">begin</span> = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; midValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get1DValue</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[index / matrix.front().<span class="built_in">size</span>()][index % matrix.front().<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 739 Daily Temperatures</title>
    <url>/2020/10/26/Leetcode/Leetcode%20739%20Daily%20Temperatures/</url>
    <content><![CDATA[<p>Given a list of daily temperatures <code>T</code>, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put <code>0</code> instead.</p>
<p>For example, given the list of temperatures <code>T = [73, 74, 75, 71, 69, 72, 76, 73]</code>, your output should be <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>.</p>
<p><strong>Note:</strong> The length of <code>temperatures</code> will be in the range <code>[1, 30000]</code>. Each temperature will be an integer in the range <code>[30, 100]</code>.</p>
<a id="more"></a>
<h2 id="1-辅助数组"><a href="#1-辅助数组" class="headerlink" title="1 辅助数组"></a>1 辅助数组</h2><p>注意到, 温度是从30到100的. 为了方便起见, 我们就假设从0到100好了.</p>
<p>所以设置一个数组<code>int[101] last</code>. <code>last[t]</code>表示超过温度t的所有天数中, 最近的(最靠前的)一天的日期</p>
<p>数组T从后向前遍历, <code>for(int i = T.length - 1; i &gt; -1; --i)</code>, 首先获得当日的温度<code>tmp = T[i]</code></p>
<p>如果last[tmp] = 0, 就说明从i往后的超过温度tmp的日期不存在, 返回0.</p>
<p>如果<code>last[tmp] == x != 0</code>, 就说明在第x天的温度超过了第i天的温度tmp, 此时结果应该为<code>x - i</code></p>
<p>并且要更新数组last, 把last[j] 全部更新为i, 其中j为小于tmp的所有值. 表明温度大于j的所有天数中, 最靠前的一天是第i天</p>
<p>时间复杂度为O(m*n). m是所有可能的温度跨度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = T.length - <span class="number">1</span>; i &gt; -<span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] = (last[T[i]] == <span class="number">0</span>) ? <span class="number">0</span> : last[T[i]] - i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; T[i]; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                last[j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-单调栈"><a href="#2-单调栈" class="headerlink" title="2 单调栈"></a>2 单调栈</h2><p>这个解法还不错. 只不过之前从来没接触过单调栈的肯定想不到</p>
<p>参考于 <a href="https://leetcode-cn.com/problems/daily-temperatures/solution/java-by-sdwwld/">https://leetcode-cn.com/problems/daily-temperatures/solution/java-by-sdwwld/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        Deque&lt;Integer&gt; stk = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stk.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                stk.offerFirst(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!stk.isEmpty() &amp;&amp; T[i] &gt; T[stk.peekFirst()])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> j = stk.pollFirst();</span><br><span class="line">                    ans[j] = i - j;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.offerFirst(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-伪动态规划"><a href="#3-伪动态规划" class="headerlink" title="3 伪动态规划"></a>3 伪动态规划</h2><p>之所以叫伪动态规划, 是因为我不知道这算不算动态规划. 但是它确实利用了动态规划的思想. 利用之前已经计算过的信息.</p>
<p>我们从后向前计算, 首先最后一个肯定是0</p>
<p>对于i, 假设i之后的ans都已经被正确计算, 我们来计算ans[i]</p>
<p>首先取<code>j = i + 1</code></p>
<p>如果<code>T[j] &gt; T[i]</code>, 那么肯定有<code>ans[i] = j - i</code></p>
<p>否则, 我们判断<code>ans[j]</code>. 如果<code>ans[j] = 0</code>, 就说明往后没有比<code>T[j]</code>更大的值了. 又因为<code>T[i] &gt;= T[j]</code>所以<code>T[i]</code>肯定也等于0</p>
<p>如果<code>ans[j] != 0</code>, 那么令<code>tmp_j = ans[j]</code>. 说明第一个比T[j]大的数是<code>T[j + tmp_j]</code>. 那么第一个比T[i]大的数也只可能出现在j+j_tmp及其后面. 因为<code>T[i] &gt;= T[j]</code>. 所以<code>j += ans[j]</code>, 继续寻找即可</p>
<p>在网上查的这种算法的时间复杂度也为O(n). 但我不会证明.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = T.length - <span class="number">2</span>; i &gt; -<span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; T.length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(T[j] &gt; T[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ans[i] = j - i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans[j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j += ans[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 746 Min Cost Climbing Stairs</title>
    <url>/2020/07/30/Leetcode/Leetcode%20746%20Min%20Cost%20Climbing%20Stairs/</url>
    <content><![CDATA[<p>On a staircase, the <code>i</code>-th step has some non-negative cost <code>cost[i]</code> assigned (0 indexed).</p>
<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: cost &#x3D; [10, 15, 20]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>cost</code> will have a length in the range <code>[2, 1000]</code>.</li>
<li>Every <code>cost[i]</code> will be an integer in the range <code>[0, 999]</code>.</li>
</ol>
<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>最经典的动态规划问题之一了. </p>
<p>边界条件: 当i = 0 或 i= 1 时, 爬到第i层的花费为0</p>
<p>状态方程: 想要爬到第i层只有两种途径, 从i-1层开始爬和从i-2层开始爬, 从i-1爬的花费为cost1 = minCostClimbingStairs(i-1) + cost[i-1],  从i-2爬的花费为cost2 = minCostClimbingStairs(i-2) + cost[i-2], 所以爬到第i层的最小花费为min(cost1, cost2).</p>
<p>递归的求第cost.size()层的最小花费即可. 注意不要重复计算否则超时. 构造一个数组储存已经算出来的最小花费即可. 数组中有就直接用, 没有再递归的计算.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">costSum</span><span class="params">(cost.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        costSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        costSum[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> minCostClimbingStairs(cost, costSum, cost.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costSum, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(costSum[k] != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> costSum[k];</span><br><span class="line">        <span class="keyword">int</span> fromMinus2 = minCostClimbingStairs(cost, costSum, k<span class="number">-2</span>) + cost[k - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> fromMinus1 = minCostClimbingStairs(cost, costSum, k<span class="number">-1</span>) + cost[k - <span class="number">1</span>];</span><br><span class="line">        costSum[k] = <span class="built_in">min</span>(fromMinus2, fromMinus1);</span><br><span class="line">        <span class="keyword">return</span> costSum[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 73 Set Matrix Zeroes</title>
    <url>/2020/08/05/Leetcode/Leetcode%2073%20Set%20Matrix%20Zeroes/</url>
    <content><![CDATA[<p>Given a <em>m</em> x <em>n</em> matrix, if an element is 0, set its entire row and column to 0. Do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<ul>
<li>A straight forward solution using O(<em>m**n</em>) space is probably a bad idea.</li>
<li>A simple improvement uses O(<em>m</em> + <em>n</em>) space, but still not the best solution.</li>
<li>Could you devise a constant space solution?</li>
</ul>
<a id="more"></a>
<h2 id="1-原地标记-失败"><a href="#1-原地标记-失败" class="headerlink" title="1 原地标记(失败)"></a>1 原地标记(失败)</h2><p>本来打算用原地标记的. 某个元素加上(max-min+1)后为标记, 标记后的元素减去(max-min+1)可以还原为原来的元素.</p>
<p>但是测试案例中有INT_MIN和INT_MAX, 这样会溢出.</p>
<p><strong>我也想改进一下原地标记的方法,但我实在想不出来既兼容INT_MAX, INT_MIN, 又只有常数空间占用的方法了😭😭😭</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This method failed when encounters [[-4,-2147483648,6,-7,0],[-8,6,-8,-6,0],[2147483647,2,-9,-6,-10]]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max0 = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> min0 = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; i : matrix)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> max_tmp = *max_element(i.cbegin(), i.cend());</span><br><span class="line">            <span class="keyword">int</span> min_tmp = *min_element(i.cbegin(), i.cend());</span><br><span class="line">            max0 = <span class="built_in">max</span>(max0, max_tmp);</span><br><span class="line">            min0 = <span class="built_in">min</span>(min0, min_tmp);</span><br><span class="line">        &#125;</span><br><span class="line">               </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.front().<span class="built_in">size</span>(); ++j)</span><br><span class="line">                <span class="keyword">if</span>(undoMark(matrix[i][j], min0, max0) == <span class="number">0</span>)</span><br><span class="line">                    markMatrix(matrix, i, j, min0, max0);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.front().<span class="built_in">size</span>(); ++j)</span><br><span class="line">                <span class="keyword">if</span>(isMarked(matrix[i][j], min0, max0))</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">const</span> <span class="keyword">int</span>&amp; min0, <span class="keyword">const</span> <span class="keyword">int</span>&amp; max0)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; min0)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;MinMax Input Error!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value &gt; max0)</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> diff = max0 - min0 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> value + diff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">undoMark</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">const</span> <span class="keyword">int</span>&amp; min0, <span class="keyword">const</span> <span class="keyword">int</span>&amp; max0)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; min0)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;MinMax Input Error!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value &lt;= max0)</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> diff = max0 - min0 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> value - diff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> min0, <span class="keyword">int</span> max0)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            matrix[i][column] = mark(matrix[i][column], min0, max0);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.front().<span class="built_in">size</span>(); ++j)</span><br><span class="line">            matrix[row][j] = mark(matrix[row][j], min0, max0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMarked</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> min0, <span class="keyword">int</span> max0)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt; max0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-原地标记2"><a href="#2-原地标记2" class="headerlink" title="2 原地标记2"></a>2 原地标记2</h2><p>考虑利用matrix的第0行和第0列来标记矩阵的某一行或某一列是否出现过0</p>
<ol>
<li>首先创建两个变量<code>ifrow0has0</code> 和<code>ifcolumn0has0</code> 并检查第0行和第0列是否含有0, 如果是, 将相应的值更新为true.(这时第0行和第0列的信息储存在这两个变量中了, 然后在上面标记含有0的列或含有0的行不会产生影响)</li>
<li>从第1行第1列开始遍历整个矩阵, 若第i行第j列含有0, 则将第0行第j个元素标记为0, 和第i行第0个元素标记为0(意味着接下来第i行所有元素和第j列所有元素都要被归0)</li>
<li>根据<code>ifrow0has0</code> 和<code>ifcolumn0has0</code> 判断是否将第0行的全部元素归0或将第0列的元素归0</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ifrow0has0 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> ifcolumn0has0 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.front().<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ifrow0has0 = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ifcolumn0has0 = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix.front().<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix.front().<span class="built_in">size</span>(); ++j)</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;matrix.front().<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ifrow0has0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.front().<span class="built_in">size</span>(); ++i)</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ifcolumn0has0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 75 Sort Colors</title>
    <url>/2020/08/06/Leetcode/Leetcode%2075%20Sort%20Colors/</url>
    <content><![CDATA[<p>Given an array with <em>n</em> objects colored red, white or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<ul>
<li>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</li>
<li>Could you come up with a one-pass algorithm using only constant space?</li>
</ul>
<a id="more"></a>
<h2 id="三指针"><a href="#三指针" class="headerlink" title="三指针"></a>三指针</h2><p>本问题被称为 荷兰国旗问题<br>，最初由 Edsger W. Dijkstra提出。<br>其主要思想是给每个数字设定一种颜色，并按照荷兰国旗颜色的顺序进行调整。</p>
<p>我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。</p>
<p>本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。</p>
<p>算法</p>
<p>初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0.</p>
<p>初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2.</p>
<p>初始化当前考虑的元素序号 ：curr = 0.</p>
<p>While curr &lt;= p2 :</p>
<p>若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。</p>
<p>若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。</p>
<p>若 nums[curr] = 1 ：将指针curr右移。</p>
<p>算法参考于</p>
<blockquote>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode/">https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[j], nums[i]);</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[j] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[j], nums[k]);</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 763 Partition Labels</title>
    <url>/2020/10/07/Leetcode/Leetcode%20763%20Partition%20Labels/</url>
    <content><![CDATA[<p>A string <code>S</code> of lowercase English letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S &#x3D; &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ul>
<li><code>S</code> will have length in range <code>[1, 500]</code>.</li>
<li><code>S</code> will consist of lowercase English letters (<code>&#39;a&#39;</code> to <code>&#39;z&#39;</code>) only.</li>
</ul>
<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>首先构造一个hashmap, 存储字符i和字符i最后一次出现的位置.(换成int数组也可以, 更省空间).</p>
<p>解题思路不愿意写了, 贴一个吧<a href="https://www.cnblogs.com/yuzhenzero/p/10713254.html">https://www.cnblogs.com/yuzhenzero/p/10713254.html</a></p>
<p>假设我们有一个片段是符合要求的，我们给这个片段设一个标签叫<code>a</code>，那字母<code>a</code>最后出现的位置肯定也在这个片段中（如果不在这个片段中，而在其他的地方出现了，就不符合题目一个字母只在一个片段出现的要求）。</p>
<p>在两个<code>a</code>之间，一般来讲也会有其他字母，同理，在这期间其他字母最后一次出现也要包含在这个片段中，这就会导致这个符合要求的片段扩张一部分。举个例子，原字符串是<code>“abccaddbeffe”</code>，则第一个符合要求的片段是<code>“abccaddb”</code>。</p>
<p>利用上述这个思想，我们可以使用如下方法来解题：</p>
<ol>
<li>构造一个数组，存放给定字符串<code>s</code>中，每个字符最后出现的索引</li>
<li>设置两个指针<code>start</code>和<code>end</code>分别表示符合要求的片段的开始索引和结束索引</li>
<li>按字符遍历字符串，不断更新<code>end</code>的值，直到<code>i == end</code>说明已经搜寻到一个符合要求的片段了，此时重置<code>start</code>的值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = S.length() - <span class="number">1</span>; i &gt; -<span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            map.putIfAbsent(S.charAt(i), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; S.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= end; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                end = Math.max(map.get(S.charAt(i)), end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = end - begin + <span class="number">1</span>;</span><br><span class="line">            list.add(len);</span><br><span class="line">            begin = end = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 77 Combinations</title>
    <url>/2020/10/19/Leetcode/Leetcode%2077%20Combinations/</url>
    <content><![CDATA[<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>
<p>You may return the answer in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 1, k &#x3D; 1</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<a id="more"></a>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>容易得到, 从1到n选择k个数的所有方式等于从2到n选择k个数的所有方式A加上从2到n选择k-1个数的所有方式B. 其中, B中的所有list都要add上1. 那么A并B就得到了从1到n选择k个数的所有方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">return</span> combine(<span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//assert(k &gt;= 1)</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(end - begin + <span class="number">1</span> &lt; k)</span><br><span class="line">            <span class="keyword">return</span> lists; <span class="comment">//you must return [] not [[]]!</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= end; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;Integer&gt; oneElemList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                oneElemList.add(i);</span><br><span class="line">                lists.add(oneElemList);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lists;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; listsWithoutBegin = combine(begin + <span class="number">1</span>, end, k);</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; listsWithBegin = combine(begin + <span class="number">1</span>, end, k - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(List&lt;Integer&gt; list : listsWithBegin)</span><br><span class="line">                list.add(begin);</span><br><span class="line">            listsWithoutBegin.addAll(listsWithBegin);</span><br><span class="line">            <span class="keyword">return</span> listsWithoutBegin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 747 Largest Number At Least Twice Of Others</title>
    <url>/2020/07/30/Leetcode/Leetcode%20747%20Largest%20Number%20At%20Least%20Twice%20Of%20Others/</url>
    <content><![CDATA[<p>In a given integer array <code>nums</code>, there is always exactly one largest element.</p>
<p>Find whether the largest element in the array is at least twice as much as every other number in the array.</p>
<p>If it is, return the <strong>index</strong> of the largest element, otherwise return -1.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3, 6, 1, 0]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 6 is the largest integer, and for every other number in the array x,</span><br><span class="line">6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1, 2, 3, 4]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: 4 isn&#39;t at least as big as twice the value of 3, so we return -1.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><p><code>nums</code> will have a length in the range <code>[1, 50]</code>.</p>
</li>
<li><p>Every <code>nums[i]</code> will be an integer in the range <code>[0, 99]</code>.</p>
<h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2></li>
</ol>
<p>这太简单了吧, 不会数据结构和算法的都能直接写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator <span class="built_in">max</span> = max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == *<span class="built_in">max</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span> * i &gt; *<span class="built_in">max</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span> - nums.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 78 Subsets</title>
    <url>/2020/07/25/Leetcode/Leetcode%2078%20Subsets/</url>
    <content><![CDATA[<p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>关键点是 <strong>假如已经找到数组[nums[0],…,nums[n-1]]的全部子集(记为s), 那么数组[nums[0], …, nums[n]]的全部子集就等于s中所有元素加上nums[n]产生的集合 ∪ 集合s</strong></p>
<p>例如, [1,2,3]中前2个元素的全部子集s为{[], [1], [2], [1, 2]}</p>
<p>那么前2个元素的全部子集s中每个元素加上3产生的集合为{[3], [1,3], [2,3], [1,2,3]}</p>
<p>并上s = {[], [1], [2], [1, 2]}</p>
<p>所以前3个元素的子集为[], [1], [2], [1, 2], [3], [1,3], [2,3], [1,2,3]</p>
<p>复杂度分析,由于每一次计算0到n都需要先计算0到n-1的结果res(res中有2^(n-1)个元素), 然后再花费2^(n-1)将res的结果添加到0</p>
<p>到n的结果中,所以<code>T(n) = T(n - 1) + O(2^(n-1))</code>, 即2^n的复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subsets(nums, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvc;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vvc;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vvc.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            vvc.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[<span class="number">0</span>]&#125;);</span><br><span class="line">            <span class="keyword">return</span> vvc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> subsetWithoutNums_n = subsets(nums, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; vectorWithout_n : subsetWithoutNums_n)</span><br><span class="line">            &#123;</span><br><span class="line">                vvc.push_back(vectorWithout_n);</span><br><span class="line">                <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vectorWith_n</span><span class="params">(vectorWithout_n.cbegin(), vectorWithout_n.cend())</span></span>;</span><br><span class="line">                vectorWith_n.push_back(nums[n]);</span><br><span class="line">                vvc.push_back(vectorWith_n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 79 Word Search</title>
    <url>/2020/09/20/Leetcode/Leetcode%2079%20Word%20Search/</url>
    <content><![CDATA[<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">board &#x3D;</span><br><span class="line">[</span><br><span class="line">  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],</span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word &#x3D; &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word &#x3D; &quot;SEE&quot;, return true.</span><br><span class="line">Given word &#x3D; &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>board</code> and <code>word</code> consists only of lowercase and uppercase English letters.</li>
<li><code>1 &lt;= board.length &lt;= 200</code></li>
<li><code>1 &lt;= board[i].length &lt;= 200</code></li>
<li><code>1 &lt;= word.length &lt;= 10^3</code></li>
</ul>
<a id="more"></a>
<h2 id="1-暴力递归-超时"><a href="#1-暴力递归-超时" class="headerlink" title="1 暴力递归(超时)"></a>1 暴力递归(超时)</h2><p>对于一个字符串, 和一个开始位置, 若开始位置与字符串第0个字符相等(不相等返回false), 则判断开始位置的四周是否和字符串第1个字符相等(不相等返回false), 再判断开始位置四周的四周是不是和第2个位置相等, 依次类推. 如果一直到字符串最后都有相等的, 那就返回true.同时要创建一个isMarked数组防止一个元素被纳入两次.</p>
<p>**但是这种方法复杂度很高. 每一次字符相等后需要判断接下来前后左右4个位置的字符和下一个字符是否相等. 最坏条件下复杂度为O(4^n), n为字符串长度 **</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">isMarked</span><span class="params">(board.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(board.front().<span class="built_in">size</span>(),<span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.front().<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> tmp = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(&#123;i,j&#125;), isMarked, board, <span class="keyword">word</span>.<span class="built_in">begin</span>(), <span class="keyword">word</span>.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">if</span>(tmp) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; beginLocation, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isMarked, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>::iterator <span class="built_in">begin</span>, <span class="built_in">string</span>::iterator <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// empty string always matches</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> i = beginLocation.first;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> j = beginLocation.second;</span><br><span class="line">        <span class="keyword">if</span>(isOutOfBoundary(board, i, j)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// use Array isMarked avoid using one element two times</span></span><br><span class="line">        <span class="keyword">if</span>(isMarked[i][j] || board[i][j] != *<span class="built_in">begin</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == *<span class="built_in">begin</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isMarked[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">bool</span> isLeftAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i, j - <span class="number">1</span>&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">bool</span> isRightAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i, j + <span class="number">1</span>&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">bool</span> isUpAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i - <span class="number">1</span>, j&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">bool</span> isDownAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i + <span class="number">1</span>, j&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">return</span> isLeftAvailable || isRightAvailable || isUpAvailable || isDownAvailable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;In no case you could enter this block. Logic Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOutOfBoundary</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= board.<span class="built_in">size</span>() || i &lt; <span class="number">0</span> || j &gt;= board.front().<span class="built_in">size</span>() || j &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-递归2"><a href="#2-递归2" class="headerlink" title="2 递归2"></a>2 递归2</h2><p>一开始超时我还以为是算法的问题, 想了好久找一个最坏时间复杂度低于O(4^n)的算法, 没想出来. 后来看了答案之后发现这样做是对的, 只不过递归的时候要注意细节, 尽可能的减少时间复杂度.</p>
<p><strong>第一个细节就是一定要剪枝剪的彻底!</strong></p>
<p>在递归1中, 是这样递归的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isLeftAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i, j - <span class="number">1</span>&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">bool</span> isRightAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i, j + <span class="number">1</span>&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">bool</span> isUpAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i - <span class="number">1</span>, j&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">bool</span> isDownAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i + <span class="number">1</span>, j&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">return</span> isLeftAvailable || isRightAvailable || isUpAvailable || isDownAvailable;</span><br></pre></td></tr></table></figure>

<p>这样就意味着, 如果算出来isLeftAvailable是可行的, 下面还会继续算isRightAvailable, isUpAvailable, isDownAvailable. 但是可以直接返回true即可. 不需要再算后面三个了. 未改进时最坏的情况下要多花3倍的时间!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isLeftAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i, j - <span class="number">1</span>&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">if</span>(isLeftAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> isRightAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i, j + <span class="number">1</span>&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">if</span>(isRightAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> isUpAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i - <span class="number">1</span>, j&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">if</span>(isUpAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> isDownAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i + <span class="number">1</span>, j&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">if</span>(isDownAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><strong>第二个细节就是一定要传引用, 不要传值!</strong></p>
<p>在递归1中是这样设计递归函数的                                                                                         ⬇</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; beginLocation, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isMarked, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>::iterator <span class="built_in">begin</span>, <span class="built_in">string</span>::iterator <span class="built_in">end</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>递归2                                                                                                                                       ⬇</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; beginLocation, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isMarked, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>::iterator <span class="built_in">begin</span>, <span class="built_in">string</span>::iterator <span class="built_in">end</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>不断的复制isMarked非常耗费时间. </p>
<p>当时想的是因为每个函数都可能对isMarked修改, 为了不让不同的递归之间产生影响, 索性就传值了. 但是这么做费时间.</p>
<p><strong>实际上传引用也能使不同的递归之间不产生影响, 只需要递归完恢复原来的值即可</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">isMarked[i][j] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> isLeftAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i, j - <span class="number">1</span>&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">if</span>(isLeftAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> isRightAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i, j + <span class="number">1</span>&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">if</span>(isRightAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> isUpAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i - <span class="number">1</span>, j&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">if</span>(isUpAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> isDownAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i + <span class="number">1</span>, j&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">if</span>(isDownAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">isMarked[i][j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// &lt;-- restore array isMarked</span></span><br></pre></td></tr></table></figure>

<p>即在返回false之前将遍历过的位置恢复为false, 这样上一个递归不会影响下一个递归.</p>
<p>这两个细节缺一不可!!! 少一个都会超时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">isMarked</span><span class="params">(board.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(board.front().<span class="built_in">size</span>(),<span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.front().<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> tmp = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(&#123;i,j&#125;), isMarked, board, <span class="keyword">word</span>.<span class="built_in">begin</span>(), <span class="keyword">word</span>.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">if</span>(tmp) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; beginLocation, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isMarked, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>::iterator <span class="built_in">begin</span>, <span class="built_in">string</span>::iterator <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// empty string always matches</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> i = beginLocation.first;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> j = beginLocation.second;</span><br><span class="line">        <span class="keyword">if</span>(isOutOfBoundary(board, i, j)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// use Array isMarked avoid using one element two times</span></span><br><span class="line">        <span class="keyword">if</span>(isMarked[i][j] || board[i][j] != *<span class="built_in">begin</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == *<span class="built_in">begin</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isMarked[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">bool</span> isLeftAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i, j - <span class="number">1</span>&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">if</span>(isLeftAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">bool</span> isRightAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i, j + <span class="number">1</span>&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">if</span>(isRightAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">bool</span> isUpAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i - <span class="number">1</span>, j&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">if</span>(isUpAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">bool</span> isDownAvailable = exist(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(&#123;i + <span class="number">1</span>, j&#125;), isMarked, board, <span class="built_in">begin</span> + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">if</span>(isDownAvailable) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            isMarked[i][j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;In no case you could enter this block. Logic Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOutOfBoundary</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= board.<span class="built_in">size</span>() || i &lt; <span class="number">0</span> || j &gt;= board.front().<span class="built_in">size</span>() || j &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 766 Toeplitz Matrix</title>
    <url>/2020/08/05/Leetcode/Leetcode%20766%20Toeplitz%20Matrix/</url>
    <content><![CDATA[<p>A matrix is <em>Toeplitz</em> if every diagonal from top-left to bottom-right has the same element.</p>
<p>Now given an <code>M x N</code> matrix, return <code>True</code> if and only if the matrix is <em>Toeplitz</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix &#x3D; [</span><br><span class="line">  [1,2,3,4],</span><br><span class="line">  [5,1,2,3],</span><br><span class="line">  [9,5,1,2]</span><br><span class="line">]</span><br><span class="line">Output: True</span><br><span class="line">Explanation:</span><br><span class="line">In the above grid, the diagonals are:</span><br><span class="line">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.</span><br><span class="line">In each diagonal all elements are the same, so the answer is True.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix &#x3D; [</span><br><span class="line">  [1,2],</span><br><span class="line">  [2,2]</span><br><span class="line">]</span><br><span class="line">Output: False</span><br><span class="line">Explanation:</span><br><span class="line">The diagonal &quot;[1, 2]&quot; has different elements.</span><br></pre></td></tr></table></figure>


<p><strong>Note:</strong></p>
<ol>
<li><code>matrix</code> will be a 2D array of integers.</li>
<li><code>matrix</code> will have a number of rows and columns in range <code>[1, 20]</code>.</li>
<li><code>matrix[i][j]</code> will be integers in range <code>[0, 99]</code>.</li>
</ol>
<p><strong>Follow up:</strong></p>
<ol>
<li>What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?</li>
<li>What if the matrix is so large that you can only load up a partial row into the memory at once?</li>
</ol>
<a id="more"></a>
<h2 id="逐个比较"><a href="#逐个比较" class="headerlink" title="逐个比较"></a>逐个比较</h2><p>对于第i行第j个元素, 如果和第i-1行第j-1个元素不相等, 就返回false</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = matrix.front().<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] != matrix[i<span class="number">-1</span>][j<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 8 String To Integer Atoi</title>
    <url>/2020/09/24/Leetcode/Leetcode%208%20String%20To%20Integer%20Atoi/</url>
    <content><![CDATA[<p>Implement <code>atoi</code> which converts a string to an integer.</p>
<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Only the space character <code>&#39; &#39;</code> is considered as whitespace character.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &#39;-&#39;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &#39;w&#39;, which is not a numerical </span><br><span class="line">             digit or a +&#x2F;- sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="从左到右扫描"><a href="#从左到右扫描" class="headerlink" title="从左到右扫描"></a>从左到右扫描</h2><p>首先先去除左边的空格</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str = <span class="built_in">string</span>(<span class="built_in">std</span>::find_if(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(),[](<span class="keyword">char</span> ch)&#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">std</span>::<span class="built_in">isspace</span>(ch);</span><br><span class="line">        &#125;), str.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>然后检查第0个字符是不是’+’, ‘-‘,数字. 如果不是直接返回0</p>
<p>然后判断正负, 储存在变量isNegative中</p>
<p>接下来就是创建一个变量ans, 读一个字母储存一次<code>ans = ans * 10 + tmp</code> 其中, <code>tmp = str[i] - &#39;0&#39;</code>.</p>
<p>假如读到的不是digit, 返回ans即可</p>
<p><strong>上面的步骤看起来并不算难, 但难的地方在于处理INT_MIN, INT_MAX</strong></p>
<p>在更新ans前, 要检查更新后是不是会overflow. </p>
<p>首先检查ans, 如果是正数, 并且ans &gt; INT_MAX/10, 因为我们这次读到的tmp也是数字, 如果更新<code>ans = ans * 10 + tmp</code>的话肯定会overflow! 所以这种情况就直接返回INT_MAX即可.</p>
<p>如果检查发现 ans == INT_MAX/10, 并且tmp &gt;= 7, 因为INT_MAX = 2147483647. 所以更新ans后要么新的值为INT_MAX, 要么就超过INT_MAX, 所以这两种情况都返回INT_MAX也是没有错误的.</p>
<p>负数同理, 不过要注意负数的INT_MIN = -2147483648 所以如果ans == INT_MAX/10, 并且tmp &gt;= 8, 才返回INT_MIN.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保证更新tmp后不会溢出</span></span><br><span class="line"><span class="keyword">if</span>(!isNegative)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans &gt; INT_MAX/<span class="number">10</span> || (ans == INT_MAX/<span class="number">10</span> &amp;&amp; tmp &gt;= <span class="number">7</span>))</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans &gt; INT_MAX/<span class="number">10</span> || (ans == INT_MAX/<span class="number">10</span> &amp;&amp; tmp &gt;= <span class="number">8</span>))</span><br><span class="line">        <span class="keyword">return</span> INT_MIN;</span><br><span class="line">&#125;</span><br><span class="line">ans = ans * <span class="number">10</span> + tmp;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//trim left space</span></span><br><span class="line">        str = <span class="built_in">string</span>(<span class="built_in">std</span>::find_if(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(),[](<span class="keyword">char</span> ch)&#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">std</span>::<span class="built_in">isspace</span>(ch);</span><br><span class="line">        &#125;), str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(!isSign(str[<span class="number">0</span>]) &amp;&amp; !<span class="built_in">std</span>::<span class="built_in">isdigit</span>(str[<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> isNegative = (str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; isSign(str[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">std</span>::<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">                <span class="keyword">return</span> isNegative ? -ans : ans;</span><br><span class="line">            <span class="keyword">int</span> tmp = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!isNegative)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &gt; INT_MAX/<span class="number">10</span> || (ans == INT_MAX/<span class="number">10</span> &amp;&amp; tmp &gt;= <span class="number">7</span>))</span><br><span class="line">                    <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &gt; INT_MAX/<span class="number">10</span> || (ans == INT_MAX/<span class="number">10</span> &amp;&amp; tmp &gt;= <span class="number">8</span>))</span><br><span class="line">                    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">10</span> + tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSign</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch == <span class="string">&#x27;-&#x27;</span> || ch == <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 81 Search In Rotated Sorted Array II</title>
    <url>/2020/08/07/Leetcode/Leetcode%2081%20Search%20In%20Rotated%20Sorted%20Array%20II/</url>
    <content><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,0,1,2,2,5,6]</code> might become <code>[2,5,6,0,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return <code>true</code>, otherwise return <code>false</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<ul>
<li>This is a follow up problem to <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/">Search in Rotated Sorted Array</a>, where <code>nums</code> may contain duplicates.</li>
<li>Would this affect the run-time complexity? How and why?</li>
</ul>
<a id="more"></a>
<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1 暴力"></a>1 暴力</h2><p>我也不想使用暴力, 但是这个重复元素加进来想不出来怎么应对</p>
<blockquote>
<p>[1,3,1,1,1,1] tar=3 , 和[1,1,1,1,3,1] tar=3中,  nums[mid], nums.front, nums.back都为1, 所以无法判断tar在数组的左半部分和右半部分. 只能暴力</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">            <span class="keyword">if</span>(target == i) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-改进的改进的二分查找"><a href="#2-改进的改进的二分查找" class="headerlink" title="2 改进的改进的二分查找"></a>2 改进的改进的二分查找</h2><p>上面二分失败的原因是nums[mid], nums.front, nums.back都相等, 导致的无法判断tar在数组的左半部分和右半部分. </p>
<p>下面分析, 如果nums[mid]和nums.front, nums.back不等(即使nums.front == nums.back也可以), 那么就能判断nums[mid]在左上升的子数组中还是nums[mid]在右上升的子数组中.  那接下来也好根据tar的值和nums[mid]判断是在左半数组或是在右半数组中了. 使用和leetcode 33相同的方法即可</p>
<p>所以问题的关键变成了如何确保nums[mid]和nums.front, nums.back不等, 假设对于迭代每一次的起点和终点begin, end, 可以从begin向右边去重, end向左边去重</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(nums[<span class="built_in">begin</span>] == nums[<span class="built_in">begin</span>+<span class="number">1</span>]) ++<span class="built_in">begin</span>;</span><br><span class="line"><span class="keyword">while</span>(nums[<span class="built_in">end</span>] == nums[<span class="built_in">end</span><span class="number">-1</span>]) --<span class="built_in">end</span>;</span><br></pre></td></tr></table></figure>

<p>这样去重之后的数组绝对不可能出现nums[mid]和nums[begin]相等或nums[mid]和nums[end]相等的情况了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> front = nums.front();</span><br><span class="line">            <span class="keyword">int</span> back = nums.back();</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[i] == nums[i+<span class="number">1</span>]) ++i;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]) --j;</span><br><span class="line">                <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">bool</span> midInLeft = (nums[mid] &gt;= front);</span><br><span class="line">                <span class="keyword">if</span>(midInLeft)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target &gt;= front &amp;&amp; target &lt;= nums[mid])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> regularBinarySearch(nums, target, i, mid - <span class="number">1</span>) != <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        i = mid + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i &gt; j) <span class="keyword">break</span>;  <span class="comment">//if not break nums[i] may be illegal address</span></span><br><span class="line">                        front = nums[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;= back)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> regularBinarySearch(nums, target, mid + <span class="number">1</span>, j) != <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        j = mid - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(j &lt; i) <span class="keyword">break</span>;  <span class="comment">//if not break nums[j] may be illegal address</span></span><br><span class="line">                        back = nums[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">regularBinarySearch</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 83 Remove Duplicates From Sorted List</title>
    <url>/2020/09/26/Leetcode/Leetcode%2083%20Remove%20Duplicates%20From%20Sorted%20List/</url>
    <content><![CDATA[<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="常规做法"><a href="#常规做法" class="headerlink" title="常规做法"></a>常规做法</h2><p>对于一个节点curr, 比较curr和curr-&gt;next的值, 如果相同就删除curr-&gt;next节点<code>curr-&gt;next =curr-&gt;next-&gt;next </code>.否则, 前进节点curr.<code>curr = curr-&gt;next</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == curr.next.val)</span><br><span class="line">            &#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 82 Remove Duplicates From Sorted List II</title>
    <url>/2020/09/26/Leetcode/Leetcode%2082%20Remove%20Duplicates%20From%20Sorted%20List%20II/</url>
    <content><![CDATA[<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>
<p>Return the linked list sorted as well.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">Output: 2-&gt;3</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>这题的思路很简单, 就是对于每一个元素value, 用双指针begin, end来界定value的范围, 如果这个范围大于1, 说明就有重复的. <strong>就要删去这个范围的所有节点</strong>.</p>
<p>例如, 链表 <code>head -&gt; 1 -&gt; 1 -&gt; 1 -&gt; 2 -&gt; 3</code></p>
<p>首先令begin = head, end = head, 当前的元素值currVal = begin-&gt;next-&gt;val = 1.</p>
<p>然后, 我们去寻找链表中最后一个currVal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> currVal = begin.next.val;</span><br><span class="line"><span class="keyword">while</span>(end.next != <span class="keyword">null</span> &amp;&amp; end.next.val == currVal)</span><br><span class="line">&#123;</span><br><span class="line">    end = end.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时退出循环后, end指向第3个1. 因为<code>end != begin.next</code> 说明元素1肯定是重复的, 所以就删除所有的1, <code>begin.next = end.next;</code>. 链表变为<code>head -&gt; 2 -&gt; 3</code></p>
<p>然后进入第二次外部的while循环, 当前的元素值currVal = begin-&gt;next-&gt;val = 2.</p>
<p>寻找最后一个currVal, 因为只有1个2, 所以最后一个currVal的指针<code>end</code>等于<code>begin.next</code>, 所以元素2没有重复, 不用删除. 将begin前进一步进入下一次外部的while循环即可.</p>
<p>以此类推, 直到<code>begin.next == null</code> (我们在循环中控制着当<code>end.next == null</code>时就停止继续向下查找相同的元素, 所以不用担心<code>begin == null</code> 或 <code>end = null</code>这种事情的发生)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head);</span><br><span class="line">        ListNode <span class="built_in">begin</span> = dummyHead;</span><br><span class="line">        ListNode <span class="built_in">end</span> = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">begin</span>.next != null)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> currVal = <span class="built_in">begin</span>.next.val;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">end</span>.next != null &amp;&amp; <span class="built_in">end</span>.next.val == currVal)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">end</span> = <span class="built_in">end</span>.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">end</span> != <span class="built_in">begin</span>.next)</span><br><span class="line">                <span class="built_in">begin</span>.next = <span class="built_in">end</span>.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">begin</span> = <span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 80 Remove Duplicates From Sorted Array II</title>
    <url>/2020/08/07/Leetcode/Leetcode%2080%20Remove%20Duplicates%20From%20Sorted%20Array%20II/</url>
    <content><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1,1,1,2,2,3],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,0,1,1,1,1,2,3,3],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; any modification to nums in your function would be known by the caller.</span><br><span class="line">&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>和leetcode 26的解法类似, 构造扫描指针j和插入指针i, 当j扫描到满足条件的值时就插入到i中. </p>
<p>本题需要两个变量存储信息. currentNumber储存当前的值, 来判断是否和前面重复. currentCount储存currentNumber重复的次数. \</p>
<p>首先判断当前的nums[j]和currentNumber是否相等. 若相等则判断重复次数, 若重复的次数超过2次, 则j直接自增. 不超过2次, 则currentCount自增, 并将nums[j++]插入到nums[i++]. </p>
<p>若不相等, 则更新currentNumber为nums[j], 并将nums[j++]插入到nums[i++]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> currentNumber = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> currentCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != currentNumber)</span><br><span class="line">            &#123;</span><br><span class="line">                currentNumber = nums[j];</span><br><span class="line">                currentCount = <span class="number">1</span>;</span><br><span class="line">                nums[i++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++currentCount;</span><br><span class="line">                <span class="keyword">if</span>(currentCount == <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[i++] = nums[j++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(currentCount &gt; <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 86 Partition List</title>
    <url>/2020/09/26/Leetcode/Leetcode%2086%20Partition%20List/</url>
    <content><![CDATA[<p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="构造新链表"><a href="#构造新链表" class="headerlink" title="构造新链表"></a>构造新链表</h2><p>这题一开始想的是不用额外空间做, 后来发现做不了</p>
<p>允许使用额外空间就很简单了,</p>
<p>构造两个新的空链表, less储存小于x的所有节点, greater储存大于等于x的所有节点, 原链表遍历一遍, 把每个节点都加到对应的新链表里, 然后这两条链表连起来就ok了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode less = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode greater = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode lessTail = less;</span><br><span class="line">        ListNode greaterTail = greater;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val &lt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                lessTail.next = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">                lessTail = lessTail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                greaterTail.next = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">                greaterTail = greaterTail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        lessTail.next = greater.next;</span><br><span class="line">        <span class="keyword">return</span> less.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 9 Palindrome Number</title>
    <url>/2020/08/21/Leetcode/Leetcode%209%20Palindrome%20Number/</url>
    <content><![CDATA[<p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>Coud you solve it without converting the integer to a string?</p>
<a id="more"></a>
<h2 id="1-队列"><a href="#1-队列" class="headerlink" title="1 队列"></a>1 队列</h2><p>既然不让转化成字符串, 那就用队列吧, 慢点归慢点, 实在想不到更好的办法了, 要防止数组倒置后超出INT范围, 所以要加判断<code>x1 &lt; INT_MAX / 10</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x0 = x;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = x0 % <span class="number">10</span>;</span><br><span class="line">            q.push(tmp);</span><br><span class="line">            x0 /= <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(x0 &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty() &amp;&amp; x1 &lt; INT_MAX / <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x1 = x1 * <span class="number">10</span> + q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x1 == x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-方法2"><a href="#2-方法2" class="headerlink" title="2 方法2"></a>2 方法2</h2><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/">https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/</a></p>
<p>映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。</p>
<p>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于 \text{int.MAX}int.MAX，我们将遇到整数溢出问题。</p>
<p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p>
<p>例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。</p>
<p>算法</p>
<p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。</p>
<p>现在，让我们来考虑如何反转后半部分的数字。</p>
<p>对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。</p>
<p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p>
<p>由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">10</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; x1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            x1 = x1 * <span class="number">10</span> + tmp;</span><br><span class="line">            <span class="keyword">if</span>(x1 == x || x1 == x / <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 830 Positions Of Large Groups</title>
    <url>/2020/08/31/Leetcode/Leetcode%20830%20Positions%20Of%20Large%20Groups/</url>
    <content><![CDATA[<p>In a string <code>S</code> of lowercase letters, these letters form consecutive groups of the same character.</p>
<p>For example, a string like <code>S = &quot;abbxxxxzyy&quot;</code> has the groups <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> and <code>&quot;yy&quot;</code>.</p>
<p>Call a group <em>large</em> if it has 3 or more characters. We would like the starting and ending positions of every large group.</p>
<p>The final answer should be in lexicographic order.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abbxxxxzzy&quot;</span><br><span class="line">Output: [[3,6]]</span><br><span class="line">Explanation: &quot;xxxx&quot; is the single large group with starting  3 and ending positions 6.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abc&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: We have &quot;a&quot;,&quot;b&quot; and &quot;c&quot; but no large group.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">Output: [[3,5],[6,9],[12,14]]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>感觉不难, 直接双指针即可.  别忘了最后退出循环之后还要再判断一次最后的Group是不是LargeGroup.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">largeGroupPositions</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvc;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span> != S.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[<span class="built_in">end</span>] == S[<span class="built_in">begin</span>])</span><br><span class="line">                ++<span class="built_in">end</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> groupLen = <span class="built_in">end</span> - <span class="built_in">begin</span>;</span><br><span class="line">                <span class="keyword">if</span>(groupLen &gt;= <span class="number">3</span>)</span><br><span class="line">                    vvc.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="built_in">begin</span>,<span class="built_in">end</span> - <span class="number">1</span>&#125;));</span><br><span class="line">                <span class="built_in">begin</span> = <span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(<span class="built_in">end</span> == S.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> groupLen = <span class="built_in">end</span> - <span class="built_in">begin</span>;</span><br><span class="line">        <span class="keyword">if</span>(groupLen &gt;= <span class="number">3</span>)</span><br><span class="line">            vvc.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="built_in">begin</span>,<span class="built_in">end</span> - <span class="number">1</span>&#125;));</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 88 Merge Sorted Array</title>
    <url>/2020/08/05/Leetcode/Leetcode%2088%20Merge%20Sorted%20Array/</url>
    <content><![CDATA[<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>
<li>You may assume that <em>nums1</em> has enough space (size that is <strong>equal</strong> to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>-10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9</code></li>
<li><code>nums1.length == m + n</code></li>
<li><code>nums2.length == n</code></li>
</ul>
<a id="more"></a>
<h2 id="1-归并排序1"><a href="#1-归并排序1" class="headerlink" title="1 归并排序1"></a>1 归并排序1</h2><p>简单的归并排序, 分类讨论即可, 注意nums1或nums2中元素用光的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num1 = nums1;  <span class="comment">//get the copy of nums1</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">//index of nums1</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">//index of nums2</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; m || j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == m)</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[k++] = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == n)</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[k++] = num1[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(num1[i] &lt; nums2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    nums1[k++] = num1[i++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nums1[k++] = nums2[j++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-归并排序2"><a href="#2-归并排序2" class="headerlink" title="2 归并排序2"></a>2 归并排序2</h2><p>归并排序1需要使用额外空间, 这次从nums1的末尾开始插入, 不需要额外空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] &gt; nums2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    nums1[k--] = nums1[i--];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nums1[k--] = nums2[j--];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 92 Reverse Linked List II</title>
    <url>/2020/09/30/Leetcode/Leetcode%2092%20Reverse%20Linked%20List%20II/</url>
    <content><![CDATA[<p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>
<p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="原地reverse"><a href="#原地reverse" class="headerlink" title="原地reverse"></a>原地reverse</h2><p>思路和leetcode 206 中的原地reverse相同.</p>
<p>首先要记录第m-1个节点, 代码中为<code>mPrev</code>. </p>
<p>然后建立双指针, <code>p1 = mPrev.next; p2 = p1.next;</code>因为题目确保了1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.所以也不用检查p1和p2是不是null了.</p>
<p>此时开始reverse, <strong>reverse n - m 次</strong>, 就能保证m到n的次序是reverse过的. 而其他的不变.</p>
<p>循环结束后, p2指向第n+1个节点, 也就是在reverse range 之后, 并且没有被reverse的第一个节点. p1指向原链表第n个节点, 但是因为reverse了, 应该指向新链表第m个节点. 新链表第n个节点应该是原链表第m个节点也就是<code>mPrev.next</code>. 所以将新链表第n个节点与n+1个节点连接起来<code>mPrev.next.next = p2;</code>, 并且将原来链表第m-1节点与新链表第m节点连接起来<code>mPrev.next = p1;</code></p>
<p>最后返回第1个节点.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, head);</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m &gt;= n)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode mPrev = dummyHead;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                mPrev = mPrev.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode p1 = mPrev.next;</span><br><span class="line">            ListNode p2 = p1.next;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-m; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode tmp = p2.next;</span><br><span class="line">                p2.next = p1;</span><br><span class="line">                p1 = p2;</span><br><span class="line">                p2 = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ListNode tmp = p2.next;</span></span><br><span class="line">            mPrev.next.next = p2;</span><br><span class="line">            mPrev.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 90 Subsets II</title>
    <url>/2020/07/25/Leetcode/Leetcode%2090%20Subsets%20II/</url>
    <content><![CDATA[<p>Given a collection of integers that might contain duplicates, <strong><em>nums\</em></strong>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>本例和leetcode78相似, 但是关键在于去重. 如果使用leetcode78的方法后, 再排序去重, 时间复杂度会高(leetcode78返回的是规模为2^n的vector, 排序去重操作使得总操作变为n*2^n).</p>
<p>关键是将相同的元素看作一个整体!下面说明如何操作</p>
<ul>
<li><p>首先将nums排序, 构造一个statDup的映射, 统计相同的元素出现了多少次. 例如数组[1,2,2,3,3] 构造的statDup就为{(1,1), (2,2), (3,2)}</p>
</li>
<li><p>假设0到nums[n]的子集s为所有0到nums[n]出现过的元素在数组中组成的集合, 例如n = 1, 所有出现过的元素为{1,2},{1,2}对应的数组范围为[1,2,2]. 所以所有子集s为[], [1], [2], [1,2], [1,2,2]</p>
</li>
<li><p>当n = 2时所有出现过的元素仍为{1,2},所以所有子集仍为[], [1], [2], [1,2], [1,2,2], 也就是说,当nums[n] == nums[n-1]时, 0到nums[n]的子集就是0到nums[n-1]的子集</p>
</li>
<li><p>当n=3时,这时<code>nums[n]  !=  nums[n-1]</code>, 我们根据之前statDup的计算结果,发现数组中有2个3, 所以构造附加集tmp = [], [3], [3,3], 对于0到nums[2]子集中的每一个元素, [], [1], [2], [1,2], [1,2,2], 都加上tmp中的一种([]或 [3]或 [3,3]).最后将这些结果合并, 即为所求</p>
</li>
<li><blockquote>
<p>tmp = []   subset of n-1 append tmp is [], [1], [2], [1,2], [1,2,2]</p>
<p>tmp = [3]   subset of n-1 append tmp is [3], [1,3], [2,3], [1,2,3], [1,2,2,3]</p>
<p>tmp = [3,3]   subset of n-1 append tmp is [3,3], [1,3,3], [2,3,3], [1,2,3,3], [1,2,2,3,3]</p>
<p>这三个append tmp之后的集合并起来即为所求</p>
</blockquote>
</li>
<li><p>当 n=4 时, nums[4],  = nums[3], 所以所求集合还是上面那些.</p>
</li>
<li><p>n遍历到数组末尾,即可求出结果</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; statDup;</span><br><span class="line">        <span class="comment">//construct statDup</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++statDup[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subsetsWithDup(nums, statDup, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; statDup, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvc;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vvc;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//find the first element count</span></span><br><span class="line">            <span class="keyword">int</span> cnt_0 = statDup[nums[<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt_0; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(i,nums[<span class="number">0</span>])</span></span>;</span><br><span class="line">                vvc.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vvc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[n] == nums[n<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> subsetsWithDup(nums, statDup, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt_n = statDup[nums[n]];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetBefore_n = subsetsWithDup(nums, statDup, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//subset append nums[n]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt_n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(i,nums[n])</span></span>;</span><br><span class="line">            <span class="comment">//cannot be wirtten an for(auto&amp; vc : subsetBefore_n) !!!!! think why?</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> vc : subsetBefore_n)</span><br><span class="line">            &#123;</span><br><span class="line">                vc.insert(vc.<span class="built_in">end</span>(),tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">                vvc.push_back(vc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vvc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 91 Decode Ways</title>
    <url>/2020/10/16/Leetcode/Leetcode%2091%20Decode%20Ways/</url>
    <content><![CDATA[<p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>

<p>Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p>
<p>The answer is guaranteed to fit in a <strong>32-bit</strong> integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;0&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no character that is mapped to a number starting with &#39;0&#39;. We cannot ignore a zero when we face it while decoding. So, each &#39;0&#39; should be part of &quot;10&quot; --&gt; &#39;J&#39; or &quot;20&quot; --&gt; &#39;T&#39;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;1&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> contains only digits and may contain leading zero(s).</li>
</ul>
<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>令<code>dp[i]</code>表示从0到i的字串有多少种解码方式.</p>
<p><code>dp[0] = s.charAt(0) == &#39;0&#39; ? 0 : 1</code></p>
<p>对于dp[i], 显然等于 <code>A*dp[i-1] + B*dp[i-2]</code></p>
<p>其中, A代表第i个字符能否单独的成为一个解码单元, B代表第i-1个字符和第i个字符合起来能否成为一个解码单元.</p>
<p>还要考虑i-2是否小于0的问题.</p>
<p>还可以将空间复杂度化简, 因为dp[i]只和i-1, i-2有关.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(s) || <span class="string">&quot;0&quot;</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        dp[<span class="number">0</span>] = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dp_iMinus1 = s.charAt(i) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : dp[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> dp_iMinus2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span> || s.charAt(i-<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span> &gt; <span class="number">2</span>)</span><br><span class="line">                dp_iMinus2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span> == <span class="number">2</span> &amp;&amp; s.charAt(i) - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">7</span>)</span><br><span class="line">                dp_iMinus2 = (i - <span class="number">2</span> &lt; <span class="number">0</span>) ? <span class="number">1</span> : dp[i-<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span> == <span class="number">1</span>)</span><br><span class="line">                dp_iMinus2 = (i - <span class="number">2</span> &lt; <span class="number">0</span>) ? <span class="number">1</span> : dp[i-<span class="number">2</span>];</span><br><span class="line">            dp[i] = dp_iMinus1 + dp_iMinus2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 93 Restore Ip Addresses</title>
    <url>/2020/10/21/Leetcode/Leetcode%2093%20Restore%20Ip%20Addresses/</url>
    <content><![CDATA[<p>Given a string <code>s</code> containing only digits, return all possible valid IP addresses that can be obtained from <code>s</code>. You can return them in <strong>any</strong> order.</p>
<p>A <strong>valid IP address</strong> consists of exactly four integers, each integer is between <code>0</code> and <code>255</code>, separated by single dots and cannot have leading zeros. For example, “0.1.2.201” and “192.168.1.1” are <strong>valid</strong> IP addresses and “0.011.255.245”, “192.168.1.312” and “<a href="mailto:&#49;&#x39;&#x32;&#x2e;&#49;&#54;&#x38;&#64;&#x31;&#x2e;&#x31;">&#49;&#x39;&#x32;&#x2e;&#49;&#54;&#x38;&#64;&#x31;&#x2e;&#x31;</a>“ are <strong>invalid</strong> IP addresses. </p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;25525511135&quot;</span><br><span class="line">Output: [&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;0000&quot;</span><br><span class="line">Output: [&quot;0.0.0.0&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;1111&quot;</span><br><span class="line">Output: [&quot;1.1.1.1&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;010010&quot;</span><br><span class="line">Output: [&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;101023&quot;</span><br><span class="line">Output: [&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 3000</code></li>
<li><code>s</code> consists of digits only.</li>
</ul>
<a id="more"></a>
<h2 id="1-DFS"><a href="#1-DFS" class="headerlink" title="1 DFS"></a>1 DFS</h2><p>每一个结点可以选择截取的方法只有 3 种：截 1 位、截 2 位、截 3 位，因此每一个结点可以生长出的分支最多只有 3 条分支；</p>
<p> 假设当前的ip地址已经找到了前i个值, 还剩4-i个. 这里假设ip地址总共有4个值, 每个值都是0到255.</p>
<p>注意剪枝. 当剩余的字符串长度小于4-i时或者剩余字符串长度大于3*(4-i)时, 直接返回.因为无论如何后面都凑不出合法的ip地址了</p>
<p>当出现大于255的数时, 直接返回. 当出现2位数或3位数并且是0开头时, 直接返回.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">4</span> || s.length() &gt; <span class="number">4</span> * <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        restoreIPAddress(ans, curr, s, <span class="number">0</span>, s.length());</span><br><span class="line">        List&lt;String&gt; ans1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; i : ans)</span><br><span class="line">        &#123;</span><br><span class="line">            String tmp = i.get(<span class="number">0</span>) + <span class="string">&quot;.&quot;</span> + i.get(<span class="number">1</span>) + <span class="string">&quot;.&quot;</span> + i.get(<span class="number">2</span>) + <span class="string">&quot;.&quot;</span> + i.get(<span class="number">3</span>);</span><br><span class="line">            ans1.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restoreIPAddress</span><span class="params">(List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; curr, String s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin == end &amp;&amp; curr.size() == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> currSize = curr.size();</span><br><span class="line">        <span class="keyword">int</span> s_len = end - begin;</span><br><span class="line">        <span class="keyword">if</span>(s_len &lt; <span class="number">4</span> - currSize || s_len &gt; (<span class="number">4</span> - currSize) * <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// get 1-len ip</span></span><br><span class="line">        <span class="keyword">if</span>(end &lt; begin + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        String tmp = s.substring(begin, begin + <span class="number">1</span>);</span><br><span class="line">        curr.add(tmp);</span><br><span class="line">        restoreIPAddress(ans, curr, s, begin + <span class="number">1</span>, end);</span><br><span class="line">        curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// get 2-len ip</span></span><br><span class="line">        <span class="keyword">if</span>(end &lt; begin + <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        tmp = s.substring(begin, begin + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(tmp.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        curr.add(tmp);</span><br><span class="line">        restoreIPAddress(ans, curr, s, begin + <span class="number">2</span>, end);</span><br><span class="line">        curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// get 3-len ip</span></span><br><span class="line">        <span class="keyword">if</span>(end &lt; begin + <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        tmp = s.substring(begin, begin + <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(tmp.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(Integer.parseInt(tmp) &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        curr.add(tmp);</span><br><span class="line">        restoreIPAddress(ans, curr, s, begin + <span class="number">3</span>, end);</span><br><span class="line">        curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2 动态规划"></a>2 动态规划</h2><p><strong>我本以为动态规划应该比DFS快的, 没想到反而比DFS慢, 并且标准答案用的就是DFS!!</strong></p>
<p>dp[i] 存储所有s从0到i的字串可能组成的ip地址前缀.</p>
<p>例如 s = “25525511135” 那么</p>
<blockquote>
<p><code>dp[0] = [[2]]</code></p>
<p><code>dp[1] = [[25], [2, 5]]</code></p>
<p><code>dp[2] = [[255], [25, 5], [2, 55], [2, 5, 5]]</code></p>
</blockquote>
<p>所以对于dp[i], 可以直接从dp[i-1]得到. </p>
<p>对于所有的dp[i-1]的元素, 可以选择在后面添加一个新的8位ip地址, 例如<code>[2, 5] -&gt; [2, 5, 5]</code>. 但要保证size &lt; 4</p>
<p>也可以选择append在最后一个8位ip地址后面, 例如 <code>[2, 5] -&gt; [2, 55]</code>. 但要保证值小于255并且不能以0开头.</p>
<p>最后将<code>dp[s.length() - 1]</code>转化成<code>List&lt;String&gt;</code>即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">4</span> || s.length() &gt; <span class="number">4</span> * <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt;[] dp = <span class="keyword">new</span> List[s.length()];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        List&lt;String&gt; dp0 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;&quot;</span> + s.charAt(<span class="number">0</span>)));</span><br><span class="line">        dp[<span class="number">0</span>].add(dp0);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(List&lt;String&gt; list : dp[i-<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// [2.5] -&gt; [2.5.5]</span></span><br><span class="line">                <span class="keyword">if</span>(list.size() &lt; <span class="number">4</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;String&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;(list);</span><br><span class="line">                    newList.add(<span class="string">&quot;&quot;</span> + s.charAt(i));</span><br><span class="line">                    dp[i].add(newList);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// [2.5] -&gt; [2.55]</span></span><br><span class="line">                List&lt;String&gt; newList1 = <span class="keyword">new</span> ArrayList&lt;&gt;(list);</span><br><span class="line">                <span class="comment">// check if the last element valid after append s.charAt(i)</span></span><br><span class="line">                String lastString = newList1.remove(newList1.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(lastString.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                lastString = lastString + s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span>(Integer.parseInt(lastString) &gt; <span class="number">255</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                newList1.add(lastString);</span><br><span class="line">                dp[i].add(newList1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; ans = stringListToIp(dp[s.length() - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">stringListToIp</span><span class="params">(List&lt;List&lt;String&gt;&gt; a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; i : a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.size() != <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            String tmp = i.get(<span class="number">0</span>) + <span class="string">&quot;.&quot;</span> + i.get(<span class="number">1</span>) + <span class="string">&quot;.&quot;</span> + i.get(<span class="number">2</span>) + <span class="string">&quot;.&quot;</span> + i.get(<span class="number">3</span>);</span><br><span class="line">            ans.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 95 Unique Binary Search Trees II</title>
    <url>/2020/10/17/Leetcode/Leetcode%2095%20Unique%20Binary%20Search%20Trees%20II/</url>
    <content><![CDATA[<p>Given an integer <code>n</code>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&#39;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 8</code></li>
</ul>
<a id="more"></a>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>首先, 和leetcode 96一样, 要先选取根节点. 根节点选定了, 所有的组合方式也就确定了.</p>
<blockquote>
<p>举例 input = 6, 那么我们需要在(1,2,3,4,5,6)中选一个作为根节点. 不妨假设我们选择3作为根节点.</p>
<p>那么左子树就需要找到(1,2)对应的所有BST, 右子树就需要找到(4,5,6)对应的所有BST.</p>
<p>左子树好说, 就是<code>generateTrees(2)</code>返回的所有值. </p>
<p>**对于右子树, (4,5,6)构成的所有的BST形状上和(1,2,3)对应的所有BST一样, 只不过每个节点都加了3. **</p>
<p>也就是说, 找到了<code>generateTrees(3)</code>返回的所有子树的所有节点都加3, 就变成了所有右子树的BST. </p>
<p>那么我们新构造一个函数<code>List&lt;TreeNode&gt; generateTrees(int n, int base)</code>, base是构造出从1到n的所有可能子树之后每个节点都加上base之后的所有子树. </p>
<p>对于根节点3, 所有的可能方式就是<code>generateTrees(2, 0)</code>和<code>generateTrees(3, 3)</code>两者组合一下的结果.</p>
<p>然后遍历根节点, 从1到6, 就找出所有可能方式了.</p>
</blockquote>
<p>计算的过程中发现了很多重复计算, 比如计算<code>generateTrees(5)</code>, 当选取3为根节点时, 要计算<code>generateTrees(2, 0)</code>和<code>generateTrees(2, 2)</code>. 这两个返回的结果<strong>形状上</strong>完全一样, 只不过后一个每一个节点都比前一个对应的节点多了2.</p>
<p>所以可以不用递归, 打表储存从1到i的所有BST的形状即可, <code>dp[i] = generateTrees(i)</code> 用到的时候拿出来再在每个节点上加上base即可.</p>
<p>但是他给的这个TreeNode类没有实现clone()方法, 所以就没有试.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> generateTrees(n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> base)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; trees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            trees.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> trees;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            trees.add(<span class="keyword">new</span> TreeNode(<span class="number">1</span> + base));</span><br><span class="line">            <span class="keyword">return</span> trees;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(i - <span class="number">1</span>, <span class="number">0</span> + base);</span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(n - i, i + base);</span><br><span class="line">            <span class="keyword">for</span>(TreeNode leftTree : leftTrees)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode rightTree : rightTrees)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode rootWithi = <span class="keyword">new</span> TreeNode(i + base);</span><br><span class="line">                    rootWithi.left = leftTree;</span><br><span class="line">                    rootWithi.right = rightTree;</span><br><span class="line">                    trees.add(rootWithi);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 98 Validate Binary Search Tree</title>
    <url>/2020/10/04/Leetcode/Leetcode%2098%20Validate%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">Input: [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line"></span><br><span class="line">Input: [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>题解不愿意写了, 从官网上摘一段吧<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/">https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/</a></p>
<p>要解决这道题首先我们要了解二叉搜索树有什么性质可以给我们利用，由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p>
<p>这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r)(l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r)(l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p>
<p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</p>
<p>函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; min &amp;&amp; root.val &lt; max)</span><br><span class="line">            <span class="keyword">return</span> isValidBST(root.left, min, root.val) &amp;&amp; isValidBST(root.right, root.val, max);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>利用BST的中序遍历一定是升序这个条件来做.</p>
<p>虽然复杂度一样, 但是这个方法比上面那个慢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorderTraversal(root, list);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) &lt;= list.get(i-<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inorderTraversal(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorderTraversal(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 96 Unique Binary Search Trees</title>
    <url>/2020/10/05/Leetcode/Leetcode%2096%20Unique%20Binary%20Search%20Trees/</url>
    <content><![CDATA[<p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>?</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n &#x3D; 3, there are a total of 5 unique BST&#39;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<a id="more"></a>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>令f(i)为把1,2,3,…i放到BST中的所有不同方法数量.</p>
<p>假设要把1,2,3,4…,n这些数放到BST中, 可以从1到n中任意选一个点作为root. 不妨设选择i为root. 那么左子树肯定是1到i-1的这些值, 所以左子树有f(i-1)种可能性. 右子树的值肯定是从i+1到n的这些值, 这些值组成的BST子树的可能数量等于从1到n-i这些值组成的BST子树的可能数量. 所以, 当选择i为root时, 有f(i-1)*f(n-i)种可能. i从1遍历到n, 相加就能得到结果.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i-j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2(Ubuntu18.04)安装MySQL8.0</title>
    <url>/2020/10/09/WSL/WSL2InstallMysql/</url>
    <content><![CDATA[<p>WSL2(Ubuntu 18.04)安装MySQL</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为在windows下面mysql安装很简单, 所以没把安装MySQL当成一个很难的事情. 结果踩了一晚上的坑. </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先是按照网上的各种教程按部就班的安装. (这里我还没有意识到WSL的Ubuntu18.04和普通的Ubuntu18.04有什么不同)</p>
<p>这里我是跟着<a href="https://zhuanlan.zhihu.com/p/64080934">https://zhuanlan.zhihu.com/p/64080934</a>上面的步骤来做的. 要注意以下两点</p>
<ul>
<li>Ubuntu18.04是不兼容MySQL5.7的. 安装MySQL5.7可能导致有些功能不正常使用.</li>
<li>在安装的过程中, 输入两次默认root密码之后, 会让你选择验证插件<code>default authentication plugin</code> , 这时候<strong>一定要选择下面那个”Use Legacy Authentication Method (Retain MySQL 5.x Compatibility)”</strong>. 否则也可能出现兼容问题。</li>
</ul>
<h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>这时候看着安装教程的你以为安装完了? NO!</p>
<p>当你兴高采烈的使用<code>mysql -u root -p</code>想开启mysql时, 会发现他出了这么一个错</p>
<blockquote>
<p>ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’ (2)</p>
</blockquote>
<p>这时, 你原本以为复制一下错误信息Google一下怎么解决就完事了.</p>
<p>但是会发现网上几乎所有的解决方案都是建立一个软连接, 并且人家都是有<code>mysqld.sock</code>这个文件, 只不过不在<code>/var/run/mysqld/</code>目录下面. 这时人家建立一个软连接<code>ln -s /storage/db/mysql/mysql.sock /var/lib/mysql/mysql.sock</code>就能解决问题了.</p>
<p>而你呢, 找了半天都找不到<code>mysqld.sock</code>这个文件在哪里!!!</p>
<p>之后, 你再Google解决方案, 会发现, 别人的解决办法对你根本不适用.</p>
<a id="more"></a>

<h2 id="脱坑"><a href="#脱坑" class="headerlink" title="脱坑"></a>脱坑</h2><p>根本原因在于<strong>WSL的Ubuntu18.04和普通的Ubuntu18.04是不一样的</strong>!</p>
<p>意识到这个问题之后, 找到了这样的一篇文章, <a href="https://www.cnblogs.com/panlq/p/13704965.html">https://www.cnblogs.com/panlq/p/13704965.html</a> 完美解决了问题. 是因为我们没有办法通过<code>sudo service mysql start</code>这样的命令来启动MySQL. 即<code>/etc/init.d/</code>目录下面没有对应的启动文件. 自然没法连接上mysql服务器.</p>
<p>这里可以通过复制<a href="https://raw.githubusercontent.com/mysql/mysql-server/8.0/support-files/mysql.server.sh">https://raw.githubusercontent.com/mysql/mysql-server/8.0/support-files/mysql.server.sh</a> 上面的内容到一个文件<code>mysql.server.sh</code>,</p>
<p>要注意这个sh文件是需要自己改一些配置的, 需要配置以下字段</p>
<blockquote>
<p>basedir=/usr </p>
<p>datadir=/var/lib/mysql</p>
<p>mysqld_pid_file_path=/var/run/mysqld/mysqld.pid</p>
</blockquote>
<p>配置好之后将这个文件移动到<code>/etc/init.d/</code>中并设置为可执行. </p>
<blockquote>
<p>mv mysql.server.sh /etc/init.d/mysql</p>
<p>chmod +x /etc/init.d/mysql</p>
</blockquote>
<p>这样就可以正常启动mysql了. </p>
<p>由于<a href="raw.githubusercontent.com">raw.githubusercontent.com</a>需要科学上网才能下载, 特此将文件复制到本文中以供参考. 侵权删</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Copyright Abandoned 1996 TCX DataKonsult AB &amp; Monty Program KB &amp; Detron HB</span></span><br><span class="line"><span class="comment"># This file is public domain and comes with NO WARRANTY of any kind</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL daemon start/stop script.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Usually this is put in /etc/init.d (at least on machines SYSV R4 based</span></span><br><span class="line"><span class="comment"># systems) and linked to /etc/rc3.d/S99mysql and /etc/rc0.d/K01mysql.</span></span><br><span class="line"><span class="comment"># When this is done the mysql server will be started when the machine is</span></span><br><span class="line"><span class="comment"># started and shut down when the systems goes down.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Comments to support chkconfig on RedHat Linux</span></span><br><span class="line"><span class="comment"># chkconfig: 2345 64 36</span></span><br><span class="line"><span class="comment"># description: A very fast and reliable SQL database engine.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Comments to support LSB init script conventions</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides: mysql</span></span><br><span class="line"><span class="comment"># Required-Start: $local_fs $network $remote_fs</span></span><br><span class="line"><span class="comment"># Should-Start: ypbind nscd ldap ntpd xntpd</span></span><br><span class="line"><span class="comment"># Required-Stop: $local_fs $network $remote_fs</span></span><br><span class="line"><span class="comment"># Default-Start:  2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop: 0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: start and stop MySQL</span></span><br><span class="line"><span class="comment"># Description: MySQL is a very fast and reliable SQL database engine.</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># If you install MySQL on some other places than @prefix@, then you</span></span><br><span class="line"><span class="comment"># have to do one of the following things for this script to work:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># - Run this script from within the MySQL installation directory</span></span><br><span class="line"><span class="comment"># - Create a /etc/my.cnf file with the following information:</span></span><br><span class="line"><span class="comment">#   [mysqld]</span></span><br><span class="line"><span class="comment">#   basedir=&lt;path-to-mysql-installation-directory&gt;</span></span><br><span class="line"><span class="comment"># - Add the above to any other configuration file (for example ~/.my.ini)</span></span><br><span class="line"><span class="comment">#   and copy my_print_defaults to /usr/bin</span></span><br><span class="line"><span class="comment"># - Add the path to the mysql-installation-directory to the basedir variable</span></span><br><span class="line"><span class="comment">#   below.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you want to affect other MySQL variables, you should make your changes</span></span><br><span class="line"><span class="comment"># in the /etc/my.cnf, ~/.my.cnf or other MySQL configuration files.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If you change base dir, you must also change datadir. These may get</span></span><br><span class="line"><span class="comment"># overwritten by settings in the MySQL configuration files.</span></span><br><span class="line"></span><br><span class="line">basedir=/usr</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># Default value, in seconds, afterwhich the script should timeout waiting</span></span><br><span class="line"><span class="comment"># for server start. </span></span><br><span class="line"><span class="comment"># Value here is overriden by value in my.cnf. </span></span><br><span class="line"><span class="comment"># 0 means don&#x27;t wait at all</span></span><br><span class="line"><span class="comment"># Negative numbers mean to wait indefinitely</span></span><br><span class="line">service_startup_timeout=900</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lock directory for RedHat / SuSE.</span></span><br><span class="line">lockdir=<span class="string">&#x27;/var/lock/subsys&#x27;</span></span><br><span class="line">lock_file_path=<span class="string">&quot;<span class="variable">$lockdir</span>/mysql&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The following variables are only set for letting mysql.server find things.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set some defaults</span></span><br><span class="line">sudo mkdir /var/run/mysqld</span><br><span class="line">sudo chmod -R 777 /var/run/mysqld</span><br><span class="line">mysqld_pid_file_path=/var/run/mysqld/mysqld.pid</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -z <span class="string">&quot;<span class="variable">$basedir</span>&quot;</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  basedir=@prefix@</span><br><span class="line">  bindir=@bindir@</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">test</span> -z <span class="string">&quot;<span class="variable">$datadir</span>&quot;</span></span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    datadir=@localstatedir@</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  sbindir=@sbindir@</span><br><span class="line">  libexecdir=@sbindir@</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  bindir=<span class="string">&quot;<span class="variable">$basedir</span>/bin&quot;</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">test</span> -z <span class="string">&quot;<span class="variable">$datadir</span>&quot;</span></span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    datadir=<span class="string">&quot;<span class="variable">$basedir</span>/data&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  sbindir=<span class="string">&quot;<span class="variable">$basedir</span>/sbin&quot;</span></span><br><span class="line">  libexecdir=<span class="string">&quot;<span class="variable">$basedir</span>/libexec&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># datadir_set is used to determine if datadir was set (and so should be</span></span><br><span class="line"><span class="comment"># *not* set inside of the --basedir= handler.)</span></span><br><span class="line">datadir_set=</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use LSB init script functions for printing messages, if possible</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">lsb_functions=<span class="string">&quot;/lib/lsb/init-functions&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -f <span class="variable">$lsb_functions</span> ; <span class="keyword">then</span></span><br><span class="line">  . <span class="variable">$lsb_functions</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  log_success_msg()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot; SUCCESS! <span class="variable">$@</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  log_failure_msg()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot; ERROR! <span class="variable">$@</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">PATH=<span class="string">&quot;/sbin:/usr/sbin:/bin:/usr/bin:<span class="variable">$basedir</span>/bin&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line">mode=<span class="variable">$1</span>    <span class="comment"># start or stop</span></span><br><span class="line"></span><br><span class="line">[ <span class="variable">$#</span> -ge 1 ] &amp;&amp; <span class="built_in">shift</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">other_args=<span class="string">&quot;$*&quot;</span>   <span class="comment"># uncommon, but needed when called from an RPM upgrade action</span></span><br><span class="line">           <span class="comment"># Expected: &quot;--skip-networking --skip-grant-tables&quot;</span></span><br><span class="line">           <span class="comment"># They are not checked here, intentionally, as it is the resposibility</span></span><br><span class="line">           <span class="comment"># of the &quot;spec&quot; file author to give correct arguments only.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> `<span class="built_in">echo</span> <span class="string">&quot;testing\c&quot;</span>`,`<span class="built_in">echo</span> -n testing` <span class="keyword">in</span></span><br><span class="line">    *c*,-n*) echo_n=   echo_c=     ;;</span><br><span class="line">    *c*,*)   echo_n=-n echo_c=     ;;</span><br><span class="line">    *)       echo_n=   echo_c=<span class="string">&#x27;\c&#x27;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">parse_server_arguments</span></span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> arg <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$arg</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">      --basedir=*)  basedir=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$arg</span>&quot;</span> | sed -e <span class="string">&#x27;s/^[^=]*=//&#x27;</span>`</span><br><span class="line">                    bindir=<span class="string">&quot;<span class="variable">$basedir</span>/bin&quot;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">test</span> -z <span class="string">&quot;<span class="variable">$datadir_set</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">              datadir=<span class="string">&quot;<span class="variable">$basedir</span>/data&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            sbindir=<span class="string">&quot;<span class="variable">$basedir</span>/sbin&quot;</span></span><br><span class="line">            libexecdir=<span class="string">&quot;<span class="variable">$basedir</span>/libexec&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">      --datadir=*)  datadir=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$arg</span>&quot;</span> | sed -e <span class="string">&#x27;s/^[^=]*=//&#x27;</span>`</span><br><span class="line">            datadir_set=1</span><br><span class="line">    ;;</span><br><span class="line">      --pid-file=*) mysqld_pid_file_path=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$arg</span>&quot;</span> | sed -e <span class="string">&#x27;s/^[^=]*=//&#x27;</span>` ;;</span><br><span class="line">      --service-startup-timeout=*) service_startup_timeout=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$arg</span>&quot;</span> | sed -e <span class="string">&#x27;s/^[^=]*=//&#x27;</span>` ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">wait_for_pid</span></span> () &#123;</span><br><span class="line">  verb=<span class="string">&quot;<span class="variable">$1</span>&quot;</span>           <span class="comment"># created | removed</span></span><br><span class="line">  pid=<span class="string">&quot;<span class="variable">$2</span>&quot;</span>            <span class="comment"># process ID of the program operating on the pid-file</span></span><br><span class="line">  pid_file_path=<span class="string">&quot;<span class="variable">$3</span>&quot;</span> <span class="comment"># path to the PID file.</span></span><br><span class="line"></span><br><span class="line">  i=0</span><br><span class="line">  avoid_race_condition=<span class="string">&quot;by checking again&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="built_in">test</span> <span class="variable">$i</span> -ne <span class="variable">$service_startup_timeout</span> ; <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$verb</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">      <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">        <span class="comment"># wait for a PID-file to pop into existence.</span></span><br><span class="line">        <span class="built_in">test</span> -s <span class="string">&quot;<span class="variable">$pid_file_path</span>&quot;</span> &amp;&amp; i=<span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">      <span class="string">&#x27;removed&#x27;</span>)</span><br><span class="line">        <span class="comment"># wait for this PID-file to disappear</span></span><br><span class="line">        <span class="built_in">test</span> ! -s <span class="string">&quot;<span class="variable">$pid_file_path</span>&quot;</span> &amp;&amp; i=<span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">      *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;wait_for_pid () usage: wait_for_pid created|removed pid pid_file_path&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if server isn&#x27;t running, then pid-file will never be updated</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$pid</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">kill</span> -0 <span class="string">&quot;<span class="variable">$pid</span>&quot;</span> 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        :  <span class="comment"># the server still runs</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># The server may have exited between the last pid-file check and now.  </span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$avoid_race_condition</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">          avoid_race_condition=<span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="built_in">continue</span>  <span class="comment"># Check again.</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># there&#x27;s nothing that will affect the file.</span></span><br><span class="line">        log_failure_msg <span class="string">&quot;The server quit without updating PID file (<span class="variable">$pid_file_path</span>).&quot;</span></span><br><span class="line">        <span class="built_in">return</span> 1  <span class="comment"># not waiting any more.</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$echo_n</span> <span class="string">&quot;.<span class="variable">$echo_c</span>&quot;</span></span><br><span class="line">    i=`expr <span class="variable">$i</span> + 1`</span><br><span class="line">    sleep 1</span><br><span class="line"></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">test</span> -z <span class="string">&quot;<span class="variable">$i</span>&quot;</span> ; <span class="keyword">then</span></span><br><span class="line">    log_success_msg</span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    log_failure_msg</span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get arguments from the my.cnf file,</span></span><br><span class="line"><span class="comment"># the only group, which is read from now on is [mysqld]</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -x <span class="string">&quot;<span class="variable">$bindir</span>/my_print_defaults&quot;</span>;  <span class="keyword">then</span></span><br><span class="line">  print_defaults=<span class="string">&quot;<span class="variable">$bindir</span>/my_print_defaults&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># Try to find basedir in /etc/my.cnf</span></span><br><span class="line">  conf=/etc/my.cnf</span><br><span class="line">  print_defaults=</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">test</span> -r <span class="variable">$conf</span></span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    subpat=<span class="string">&#x27;^[^=]*basedir[^=]*=\(.*\)$&#x27;</span></span><br><span class="line">    <span class="built_in">dirs</span>=`sed -e <span class="string">&quot;/<span class="variable">$subpat</span>/!d&quot;</span> -e <span class="string">&#x27;s//\1/&#x27;</span> <span class="variable">$conf</span>`</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="variable">$dirs</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      d=`<span class="built_in">echo</span> <span class="variable">$d</span> | sed -e <span class="string">&#x27;s/[     ]//g&#x27;</span>`</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">test</span> -x <span class="string">&quot;<span class="variable">$d</span>/bin/my_print_defaults&quot;</span></span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">        print_defaults=<span class="string">&quot;<span class="variable">$d</span>/bin/my_print_defaults&quot;</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Hope it&#x27;s in the PATH ... but I doubt it</span></span><br><span class="line">  <span class="built_in">test</span> -z <span class="string">&quot;<span class="variable">$print_defaults</span>&quot;</span> &amp;&amp; print_defaults=<span class="string">&quot;my_print_defaults&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Read defaults file from &#x27;basedir&#x27;.   If there is no defaults file there</span></span><br><span class="line"><span class="comment"># check if it&#x27;s in the old (depricated) place (datadir) and read it from there</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">extra_args=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -r <span class="string">&quot;<span class="variable">$basedir</span>/my.cnf&quot;</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  extra_args=<span class="string">&quot;-e <span class="variable">$basedir</span>/my.cnf&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">parse_server_arguments `<span class="variable">$print_defaults</span> <span class="variable">$extra_args</span> mysqld server mysql_server mysql.server`</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set pid file if not given</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -z <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  mysqld_pid_file_path=<span class="variable">$datadir</span>/`hostname`.pid</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    /* ) ;;</span><br><span class="line">    * )  mysqld_pid_file_path=<span class="string">&quot;<span class="variable">$datadir</span>/<span class="variable">$mysqld_pid_file_path</span>&quot;</span> ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$mode</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="comment"># Start daemon</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Safeguard (relative paths, core dumps..)</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$basedir</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$echo_n</span> <span class="string">&quot;Starting MySQL&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -x <span class="variable">$bindir</span>/mysqld_safe</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="comment"># Give extra arguments to mysqld with the my.cnf file. This script</span></span><br><span class="line">      <span class="comment"># may be overwritten at next upgrade.</span></span><br><span class="line">      <span class="variable">$bindir</span>/mysqld_safe --datadir=<span class="string">&quot;<span class="variable">$datadir</span>&quot;</span> --pid-file=<span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span> <span class="variable">$other_args</span> &gt;/dev/null &amp;</span><br><span class="line">      wait_for_pid created <span class="string">&quot;$!&quot;</span> <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span>; return_value=$?</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Make lock for RedHat / SuSE</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">test</span> -w <span class="string">&quot;<span class="variable">$lockdir</span>&quot;</span></span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">        touch <span class="string">&quot;<span class="variable">$lock_file_path</span>&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">exit</span> <span class="variable">$return_value</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      log_failure_msg <span class="string">&quot;Couldn&#x27;t find MySQL server (<span class="variable">$bindir</span>/mysqld_safe)&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;stop&#x27;</span>)</span><br><span class="line">    <span class="comment"># Stop daemon. We use a signal here to avoid having to know the</span></span><br><span class="line">    <span class="comment"># root password.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -s <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="comment"># signal mysqld_safe that it needs to stop</span></span><br><span class="line">      touch <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>.shutdown&quot;</span></span><br><span class="line"></span><br><span class="line">      mysqld_pid=`cat <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span>`</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">kill</span> -0 <span class="variable">$mysqld_pid</span> 2&gt;/dev/null)</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$echo_n</span> <span class="string">&quot;Shutting down MySQL&quot;</span></span><br><span class="line">        <span class="built_in">kill</span> <span class="variable">$mysqld_pid</span></span><br><span class="line">        <span class="comment"># mysqld should remove the pid file when it exits, so wait for it.</span></span><br><span class="line">        wait_for_pid removed <span class="string">&quot;<span class="variable">$mysqld_pid</span>&quot;</span> <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span>; return_value=$?</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        log_failure_msg <span class="string">&quot;MySQL server process #<span class="variable">$mysqld_pid</span> is not running!&quot;</span></span><br><span class="line">        rm <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Delete lock for RedHat / SuSE</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">test</span> -f <span class="string">&quot;<span class="variable">$lock_file_path</span>&quot;</span></span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">        rm -f <span class="string">&quot;<span class="variable">$lock_file_path</span>&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">      <span class="built_in">exit</span> <span class="variable">$return_value</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      log_failure_msg <span class="string">&quot;MySQL server PID file could not be found!&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;restart&#x27;</span>)</span><br><span class="line">    <span class="comment"># Stop the service and regardless of whether it was</span></span><br><span class="line">    <span class="comment"># running or not, start it again.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$0</span> stop  <span class="variable">$other_args</span>; <span class="keyword">then</span></span><br><span class="line">      <span class="variable">$0</span> start <span class="variable">$other_args</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      log_failure_msg <span class="string">&quot;Failed to stop running server, so refusing to try to start.&quot;</span></span><br><span class="line">      <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;reload&#x27;</span>|<span class="string">&#x27;force-reload&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -s <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span> ; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">read</span> mysqld_pid &lt;  <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span></span><br><span class="line">      <span class="built_in">kill</span> -HUP <span class="variable">$mysqld_pid</span> &amp;&amp; log_success_msg <span class="string">&quot;Reloading service MySQL&quot;</span></span><br><span class="line">      touch <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      log_failure_msg <span class="string">&quot;MySQL PID file could not be found!&quot;</span></span><br><span class="line">      <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&#x27;status&#x27;</span>)</span><br><span class="line">    <span class="comment"># First, check to see if pid file exists</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -s <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span> ; <span class="keyword">then</span> </span><br><span class="line">      <span class="built_in">read</span> mysqld_pid &lt; <span class="string">&quot;<span class="variable">$mysqld_pid_file_path</span>&quot;</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">kill</span> -0 <span class="variable">$mysqld_pid</span> 2&gt;/dev/null ; <span class="keyword">then</span> </span><br><span class="line">        log_success_msg <span class="string">&quot;MySQL running (<span class="variable">$mysqld_pid</span>)&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        log_failure_msg <span class="string">&quot;MySQL is not running, but PID file exists&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># Try to find appropriate mysqld process</span></span><br><span class="line">      mysqld_pid=`@PIDOF@ <span class="variable">$libexecdir</span>/mysqld`</span><br><span class="line"></span><br><span class="line">      <span class="comment"># test if multiple pids exist</span></span><br><span class="line">      pid_count=`<span class="built_in">echo</span> <span class="variable">$mysqld_pid</span> | wc -w`</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$pid_count</span> -gt 1 ; <span class="keyword">then</span></span><br><span class="line">        log_failure_msg <span class="string">&quot;Multiple MySQL running but PID file could not be found (<span class="variable">$mysqld_pid</span>)&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 5</span><br><span class="line">      <span class="keyword">elif</span> <span class="built_in">test</span> -z <span class="variable">$mysqld_pid</span> ; <span class="keyword">then</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">test</span> -f <span class="string">&quot;<span class="variable">$lock_file_path</span>&quot;</span> ; <span class="keyword">then</span> </span><br><span class="line">          log_failure_msg <span class="string">&quot;MySQL is not running, but lock file (<span class="variable">$lock_file_path</span>) exists&quot;</span></span><br><span class="line">          <span class="built_in">exit</span> 2</span><br><span class="line">        <span class="keyword">fi</span> </span><br><span class="line">        log_failure_msg <span class="string">&quot;MySQL is not running&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 3</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        log_failure_msg <span class="string">&quot;MySQL is running but PID file could not be found&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 4</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">      <span class="comment"># usage</span></span><br><span class="line">      basename=`basename <span class="string">&quot;<span class="variable">$0</span>&quot;</span>`</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$basename</span>  &#123;start|stop|restart|reload|force-reload|status&#125;  [ MySQL server options ]&quot;</span></span><br><span class="line">      <span class="built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 94 Binary Tree Inorder Traversal</title>
    <url>/2020/10/01/Leetcode/Leetcode%2094%20Binary%20Tree%20Inorder%20Traversal/</url>
    <content><![CDATA[<p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2,3]</span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>Follow up:</strong></p>
<p>Recursive solution is trivial, could you do it iteratively?</p>
<a id="more"></a>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h2><p>记得之前看到过这个非递归解法, 但是实在想不出来了😭😭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorderTraversal(ans, root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(List&lt;Integer&gt; ans, TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            inorderTraversal(ans, root.left);</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            inorderTraversal(ans, root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-非递归"><a href="#2-非递归" class="headerlink" title="2 非递归"></a>2 非递归</h2><p>具体方法还是看代码吧. 感觉很难描述.</p>
<p>当初看解析的时候也看了半天才懂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; inorder = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> || !stk.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p = stk.pop();</span><br><span class="line">            inorder.add(p.val);</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j2的踩坑日记</title>
    <url>/2020/12/03/Others/log4j2%E7%9A%84%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>最近在做一个项目, 需要用到log4j来生成日志, 方便debug</p>
<p>但是log4j是分版本的, 现在的最新版是log4j2, 而不是log4j. </p>
<p>我一开始以为只是版本新旧有不同, 后来发现配置文件log4j.properties怎么都加载不进去. 查了好多资料才发现log4j2和log4j是不兼容的.</p>
<a id="more"></a>

<h2 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1. pom.xml"></a>1. pom.xml</h2><p>事实上从maven导包这一过程中就可以看出来两者的不一样了, </p>
<p><code>log4j</code>的依赖为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>log4j2</code>的依赖为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很明显的不一样嘛. </p>
<p><strong>只可惜第一次接触日志系统的我显然没有意识到事情的严重性, 天真的以为反之都是log4j, 差不到哪里去. 就没当回事. 所以引入依赖后就开始了谷歌和必应各种示例</strong>  😂😂</p>
<h2 id="2-创建实例"><a href="#2-创建实例" class="headerlink" title="2. 创建实例"></a>2. 创建实例</h2><p>在官网搜到了示例, 自然就是自己运行测试一下了, 把demo复制下来竟然发现报错了, </p>
<p>报错的原因是log4j这个类没有找到. 很奇怪, 明明我导入了maven依赖啊. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Import log4j classes.</span></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Define a static logger variable so that it references the</span></span><br><span class="line">  <span class="comment">// Logger instance named &quot;MyApp&quot;.</span></span><br><span class="line">  <span class="keyword">static</span> Logger logger = Logger.getLogger(MyApp.class);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;Entering application.&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;Exiting application.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时, <strong>我又自作聪明地分析起来了</strong>, 官网的导入是在<code>org.apache.log4j</code>下面, 而我导入的maven依赖是<code>org.apache.logging.log4j</code>, 少一个<code>logging</code>啊. 于是我自以为是的把<code> import org.apache.log4j.Logger;</code> 修改为了<code> import org.apache.logging.log4j.Logger;</code></p>
<p>这下发现<code>Logger</code>中没有<code>getLogger()</code>方法, 又搜了几篇博客. 发现应该要用这个<code>LogManager</code></p>
<p><code>static Logger logger ==LogManager.getLogger(Test.class);</code></p>
<p>然后看似这下所有的错误都解决了, 即将能用了, 事实上我又踩进了一个坑</p>
<h2 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3. 配置文件"></a>3. 配置文件</h2><p>上面的问题解决后, 我就开始考虑写配置文件自定义日志输出. 但是这时候问题就来了, 配置文件<code>log4j.properties</code>无论如何也不会生效.</p>
<p>我一开始认为是配置文件放的位置有问题, 反复检查发现没错, 又上网搜, 办法都试过了也没用. classpath什么的又检查了一遍也没问题</p>
<p>快要放弃的时候看到一篇博客, 配置文件是<code>log4j2.xml</code>, 我这才想起来版本的问题. 后来一查才发现这两个版本的配置文件确实不一样. 一个是<code>log4j.xml</code>一个是<code>log4j2.xml</code>!!!   据说log4j2之前的版本不支持<code>log4j2.properties</code>, 但是在后来的版本也加入了支持.</p>
<p>把配置文件改为<code>log4j2.xml</code>就ok了, 真没想到一个小小的<code>2</code>会造成这么大的麻烦.</p>
<p>事实上, 前面有2次提早发现错误的机会maven依赖的异常和创建实例时的异常, 如果趁早发现趁早弄清楚, 不会在这个坑上越陷越深. </p>
<p><strong>也提醒自己以后碰到一个新组件的话还是要先弄清楚原理, 不要网上拿过一个demo就用, 会避免很多坑</strong></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>b站爬虫api和代码分享</title>
    <url>/2020/10/29/Python/PythonCrawler/</url>
    <content><![CDATA[<p>这几天在做b站的一个爬虫项目. </p>
<p>先放api. 感觉爬虫阶段最难的地方就在于通过抓包或者其他手段来找api了, 需要与被爬网站斗智斗勇. 但是说实话b站对爬虫还算比较友好的了. 像京东什么的都需要直接上selenium了.</p>
<p><code>https://api.bilibili.com/x/web-interface/view?aid=&#123;&#125;</code></p>
<p>aid应该是递增的. 所以从某个值开始遍历就可以了. 中间可能会碰到一些已经被删除了的视频, 这时返回的json文件中是没有”data”这个标签的, 直接跳过即可. </p>
<a id="more"></a>

<p><strong>注意, 爬的太频繁会被封ip. 我自己的测试中, 不控制发送请求的速度的话会很快被封, 如果控制爬虫1秒1次请求的话在爬取3000次左右被封. 如果控制爬虫2秒1次请求的话在爬取7000次左右被封.</strong>  所以买ip池才是王道.</p>
<p>这里我是从aid = 40000000 开始遍历的. 对应的时间是2019年1月左右.  视频的发布时间越早, aid越小.  aid = 30000000的时候就是对应2018年8月左右的时间了. 想要爬取特定的某个时间段的话就可以酌情增减aid.</p>
<p>爬下来的所有信息都是json格式, 很方便解析. 下面说明各个字段的含义. 参考于github和知乎上各种b站爬虫项目. 以<a href="https://github.com/SocialSisterYi/bilibili-API-collect/blob/master/video/info.md">https://github.com/SocialSisterYi/bilibili-API-collect/blob/master/video/info.md</a> 为主</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into av_interpret(columnName, interpret) values(&quot;bvid&quot;, &quot;视频的bvid号, 唯一&quot;), (&quot;aid&quot;, &quot;视频的av号, 唯一&quot;), (&quot;videos&quot;, &quot;01变量, 代表是否为视频&quot;),</span><br><span class="line">(&quot;tid&quot;, &quot;视频标签id&quot;), (&quot;tname&quot;, &quot;视频标签&quot;), (&quot;copyright&quot;, &quot;1原创, 2转载&quot;), (&quot;title&quot;, &quot;视频题目&quot;), (&quot;pubdate&quot;, &quot;稿件发布时间. Unix时间戳类型， 自 1970 年 1 月 1 日00:00:00 GMT以来的秒数&quot;), </span><br><span class="line">(&quot;ctime&quot;, &quot;用户提交稿件的时间&quot;), (&quot;descript&quot;, &quot;视频简介&quot;), (&quot;state&quot;, &quot;视频状态, 作用不详&quot;), (&quot;attribute&quot;, &quot;作用不详&quot;), (&quot;duration&quot;, &quot;视频总时长(秒)&quot;), (&quot;mid&quot;, &quot;视频作者id, 通过此Key连接另外一张表up&quot;),</span><br><span class="line">(&quot;name_&quot;, &quot;视频作者昵称&quot;), (&quot;view_&quot;, &quot;视频播放数&quot;), (&quot;danmaku&quot;, &quot;视频弹幕数&quot;), (&quot;reply&quot;, &quot;视频回复数&quot;), (&quot;favorite&quot;, &quot;收藏数&quot;), (&quot;coin&quot;, &quot;投币数&quot;), (&quot;share_&quot;, &quot;分享数&quot;),</span><br><span class="line">(&quot;now_rank&quot;, &quot;当前排名&quot;), (&quot;his_rank&quot;, &quot;历史最高排名&quot;), (&quot;like&quot;, &quot;点赞数&quot;), (&quot;dislike&quot;, &quot;点踩数(恒为0)&quot;), (&quot;dynamic_&quot;, &quot;和视频同步发布的动态的文字内容&quot;),</span><br><span class="line">(&quot;rights_elec&quot;, &quot;是否支持充电&quot;), (&quot;rights_download&quot;, &quot;是否允许下载&quot;), (&quot;rights_hd5&quot;, &quot;是否有高码率&quot;), (&quot;rights_no_reprint&quot;, &quot;是否有&#39;禁止转载&#39;标志&quot;),</span><br><span class="line">(&quot;rights_autoplay&quot;, &quot;是否自动播放&quot;), (&quot;rights_is_cooperation&quot;, &quot;是否为联合投稿&quot;), (&quot;allow_submit&quot;, &quot;是否允许提交字幕    &quot;);</span><br></pre></td></tr></table></figure>

<p>现在, 我们获得了每个视频对应的up主mid字段. 但是不清楚up主的相关信息. 例如粉丝数等.</p>
<p>我们还需要一个api, 通过mid获取对应up主的全部信息. </p>
<p><code>https://api.bilibili.com/x/web-interface/card?mid=&#123;&#125;&amp;jsonp=jsonp</code></p>
<p>爬取下来的json各个字段含义如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into up_interpret(columnName, interpret) values(&quot;mid&quot;, &quot;up主id&quot;), (&quot;name_&quot;, &quot;up主昵称&quot;), (&quot;sex&quot;, &quot;up主性别&quot;), (&quot;fans&quot;, &quot;粉丝数&quot;),(&quot;friend&quot;, &quot;up主关注的人数&quot;), (&quot;sign&quot;, &quot;个性签名&quot;), (&quot;current_level&quot;, &quot;当前等级&quot;), (&quot;pendant_id&quot;, &quot;头像挂件id&quot;), (&quot;pendant_name&quot;, &quot;头像挂件名称(头像挂件仅手机端可见, pc端不可见)&quot;),</span><br><span class="line">(&quot;nameplate_id&quot;, &quot;成就id&quot;), (&quot;nameplate_name&quot;, &quot;成就名称(成就勋章仅手机端可见, pc端不可见)&quot;), (&quot;nameplate_level&quot;, &quot;成就级别&quot;), (&quot;nameplate_condition&quot;, &quot;达成成就条件&quot;),(&quot;official_role&quot;, &quot;意义不详&quot;), (&quot;official_title&quot;, &quot;官方认证名称&quot;), (&quot;official_verify_type&quot;, &quot;官方认证种类&quot;), (&quot;official_verify_desc&quot;, &quot;官方认证描述&quot;),(&quot;vipType&quot;, &quot;会员类型. 0 无会员, 1 大会员, 2 年度大会员&quot;), (&quot;vipStatus&quot;, &quot;vip状态. 0 已到期. 1 未到期&quot;), (&quot;archive_count&quot;, &quot;总投稿数&quot;);</span><br></pre></td></tr></table></figure>

<p>所以接下来就可以用mid作为外键连接两张表了. 爬虫到此结束. 源代码如下所示.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime, gmtime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: (<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36&#x27;</span></span><br><span class="line">                   <span class="string">&#x27;(KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#cid 3889776</span></span><br><span class="line"><span class="comment">#54388599</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    begin = <span class="number">40000000</span></span><br><span class="line">    end = <span class="number">50000000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">24</span>):</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">&quot;./bilibili&#123;&#125;.txt&quot;</span>.format(i),<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> av <span class="keyword">in</span> range(<span class="number">40005000</span> + i * <span class="number">3600</span>, <span class="number">40005000</span> + (i + <span class="number">1</span>) * <span class="number">3600</span>):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    url = <span class="string">&quot;https://api.bilibili.com/x/web-interface/view?aid=&#123;&#125;&quot;</span>.format(av)</span><br><span class="line">                    <span class="comment"># url = &quot;https://api.bilibili.com/x/web-interface/archive/stat?aid=&#123;&#125;&quot;.format(av)</span></span><br><span class="line">                    get_json = requests.get(url=url, headers=headers)</span><br><span class="line">                    time.sleep(<span class="number">1</span>)</span><br><span class="line">                    text = get_json.text</span><br><span class="line">                    data = json.loads(text)</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">&quot;data&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                        f.write(text)</span><br><span class="line">                        f.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    print(text)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    print(<span class="string">&quot;aid &#123;&#125; failed&quot;</span>.format(av))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: (<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36&#x27;</span></span><br><span class="line">                   <span class="string">&#x27;(KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#https://api.bilibili.com/x/web-interface/card?mid=9824766&amp;jsonp=jsonp</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;./AllMID.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        mids = f.readlines()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;./upInfo2.txt&quot;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3326</span>,len(mids)):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                url = <span class="string">&quot;https://api.bilibili.com/x/web-interface/card?mid=&#123;&#125;&amp;jsonp=jsonp&quot;</span>.format(mids[i].strip())</span><br><span class="line">                get_json = requests.get(url=url, headers=headers)</span><br><span class="line">                time.sleep(<span class="number">2</span>)</span><br><span class="line">                text = get_json.text</span><br><span class="line">                f.write(text)</span><br><span class="line">                print(i)</span><br><span class="line">                print(text)</span><br><span class="line">                f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2001.%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>如下为类型CMyString的声明, 请为该类型添加赋值运算符函数.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="1-override-clone-方法"><a href="#1-override-clone-方法" class="headerlink" title="1. override clone() 方法"></a>1. override clone() 方法</h2><p>由于Java里面不支持运算符重载, 所以只能用实现<code>clone()</code>方法来模拟<code>=</code>运算符重载.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] m_pData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CMyString</span><span class="params">(<span class="keyword">char</span>[] pData)</span> </span>&#123;</span><br><span class="line">        m_pData = pData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CMyString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;     <span class="comment">//finalize方法在jdk9及之后被标记为Deprecated</span></span><br><span class="line">        <span class="keyword">super</span>.finalize();                           <span class="comment">//并且极度不推荐使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CMyString <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        CMyString another = (CMyString) <span class="keyword">super</span>.clone();</span><br><span class="line">        another.m_pData = (<span class="keyword">this</span>.m_pData == <span class="keyword">null</span>) ? <span class="keyword">null</span> : <span class="keyword">this</span>.m_pData.clone();</span><br><span class="line">        <span class="keyword">return</span> another;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pData == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(m_pData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Arrays.fill(m_pData, <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        CMyString string = <span class="keyword">new</span> CMyString(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;);</span><br><span class="line">        CMyString other = string.clone();</span><br><span class="line">        string.changeArray();</span><br><span class="line">        System.out.println(string);</span><br><span class="line">        System.out.println(other);</span><br><span class="line">        CMyString string1 = <span class="keyword">new</span> CMyString(<span class="keyword">null</span>);</span><br><span class="line">        CMyString other1 = string1.clone();</span><br><span class="line">        string.changeArray();</span><br><span class="line">        System.out.println(string1);</span><br><span class="line">        System.out.println(other1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97I/</url>
    <content><![CDATA[<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p>
<p>限制：</p>
<p>2 &lt;= n &lt;= 100000</p>
<a id="more"></a>

<h2 id="1-原地哈希"><a href="#1-原地哈希" class="headerlink" title="1 原地哈希"></a>1 原地哈希</h2><p>因为0到n-1这些值刚好对应数组下标. 所以每次碰到数组中一个数nums[i], 就在下标为nums[i]的元素上加n. 如果发现一个数两次被加到n, 说明nums[i]出现了2次, 返回即可. 取负数也可以但是里面有0不好处理.</p>
<p>缺点是如果数组太大, <code>2*n-1 &gt; INT_MAX</code>, 这个方法就不太好用了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i] % n;</span><br><span class="line">            <span class="keyword">if</span>(nums[tmp] &gt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums[tmp] += n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-数组重排"><a href="#2-数组重排" class="headerlink" title="2 数组重排"></a>2 数组重排</h2><p>我们重新安排顺序. 试图将每个元素m放置到位置m上. <strong>如果有两个元素都试图放置到同一个位置, 说明这两个元素肯定是相同的.</strong></p>
<p>具体安排如下, 我们对于第i个位置的元素nums[i], 检查i是否等于nums[i]</p>
<ul>
<li>如果<code>i == nums[i]</code>, 就说明元素nums[i]已经被置于正确的位置上了, 直接i++判断下一个即可</li>
<li>如果<code>i != nums[i]</code>, 就说明需要调整元素位置, 把nums[i]放到正确的位置上. 这时要判断对于<code>j = nums[i]</code>, <strong>我们检查<code>nums[i]</code>和<code>nums[j]</code>的元素是否相同</strong><ul>
<li>如果相同, 即<code>nums[i] == nums[j]</code>, 说明我们找到了数组中两个相同的元素, 他们对应的下标分别是i和j. 返回nums[i]即可</li>
</ul>
</li>
<li>如果不相同即<code>nums[i] != nums[j]</code>, 就swap(nums[i], nums[j]), 即把元素nums[i]放到正确的位置上. 重复此循环直到nums[i] == i 或者找到了一个重复的元素. </li>
</ul>
<p>由于每一次swap都会使一个元素被正确归位, 所以最多执行n次就可以正确的归位整个数组, 找到重复的元素.</p>
<p>故虽然有个嵌套循环, 但是时间复杂度仍为O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[j])</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="comment">//swap nums[i] and nums[j]</span></span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>通过Windows上MySQL Workbench连接WSL上的MySQL</title>
    <url>/2020/10/29/WSL/WSLMySQLConnection/</url>
    <content><![CDATA[<p>在WSL上安装好后MySQL, 但是WSL并没有图形界面. 每次用命令行不方便. 于是想用win下面的MySQL workbench连接wsl上的MySQL.</p>
<p>在网上查了很多解决方案, 最后都没有解决问题. 踩了很多坑. 特此记录下解决问题的步骤, 供网友参考.</p>
<a id="more"></a>

<p>有的是直接填上wsl的ip地址和端口号3306就可以用了, 但是我的不行.</p>
<p>有的是修改配置文件<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>, 将<code>bind-address = 127.0.0.1</code>这一行配置注释掉. 也不管用.</p>
<p>最后发现直接修改端口号即可. 在文件<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>添加<code>port = 3307 </code>, 然后进入数据库执行允许远程操作的命令. </p>
<p>这里还有个坑, 如果你用的是mysql 8.0+, 那么网上搜的有的命令是会报错的. 因为那是5.7版本用的命令. 8.0不兼容.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># before 5.7</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">&#x27;你的密码&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;</span><br></pre></td></tr></table></figure>

<p>在8.0之后， 应该这样操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;你的密码&#x27;</span>; </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>; </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;你的密码&#x27;</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>

<p>然后重启mysql <code>sudo service mysql restart</code>即可</p>
<p>在windows的workbench下, 使用<code>localhost:3307 </code> 用户名为<code>root</code>即可完成远程连接.</p>
<p>最后还要注意, 以后再连接的时候, 也必须进入wsl手动开启mysql服务<code>sudo service mysql start</code>. 因为默认状态下wsl不会开启mysql服务. </p>
]]></content>
      <categories>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2002.%20%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计一个类, 我们只能生成该类的一个实例</p>
<h2 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//饿汉式浪费空间, 一上来就把对象加载到内存中</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(); <span class="comment">//假设单例模式中的资源</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Hungry HUNGRY = <span class="keyword">new</span> Hungry();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atomicLong.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能防住多线程, 不能防住反射.</p>
<h2 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lazy</span></span>&#123;</span><br><span class="line">    <span class="comment">//单线程下没问题, 多线程不行</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;one lazy singleton has been created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy LAZY;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LAZY == <span class="keyword">null</span>)&#123;</span><br><span class="line">            LAZY = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LAZY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atomicLong.incrementAndGet();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>不能防住多线程, 不能防住反射.</p>
<h2 id="3-加锁懒汉式"><a href="#3-加锁懒汉式" class="headerlink" title="3. 加锁懒汉式"></a>3. 加锁懒汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁之后的懒汉式单例模式, DCL</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockLazy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LockLazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;one locklazy singleton has been created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LockLazy LOCKLAZY;</span><br><span class="line">    <span class="comment">//双重检查, 如果单例已经创建了, 就不加锁. 单例未创建才加锁.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LockLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LOCKLAZY == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LockLazy.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(LOCKLAZY == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    LOCKLAZY = <span class="keyword">new</span> LockLazy();         </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LOCKLAZY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atomicLong.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但是这样也还是不安全, 如果一个线程进行new LockLazy();操作,这个操作不是原子性的, 会被jvm大体分为3个阶段. </span></span><br><span class="line"><span class="comment">//1. 分配内存空间 2. 初始化对象, 进行属性赋值. 3. 将对象指向这个空间</span></span><br><span class="line"><span class="comment">//如果没有发生指令重排, 是安全的. 如果指令重排为 132这样的顺序, 当一个线程执行完第3步, 还没有执行第2步, 这时时间片用尽, 切换到另一个线程, 另外一个线程执行getInstance()方法, 一看LOCKLAZY非空, 就直接返回了这个对象了, 但是这个对象内还没有初始化. 自然就会报错, 所以为了安全一定要将单例的引用加volatile</span></span><br></pre></td></tr></table></figure>

<h2 id="4-加锁加volatile懒汉式"><a href="#4-加锁加volatile懒汉式" class="headerlink" title="4. 加锁加volatile懒汉式"></a>4. 加锁加volatile懒汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeLazy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SafeLazy SAFELAZY;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeLazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(SAFELAZY == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SafeLazy.class)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(SAFELAZY == <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    SAFELAZY = <span class="keyword">new</span> SafeLazy();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> SAFELAZY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SAFELAZY;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atomicLong.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多线程足够安全, 仍然防不住反射</p>
<h2 id="5-静态内部类实现单例模式"><a href="#5-静态内部类实现单例模式" class="headerlink" title="5. 静态内部类实现单例模式"></a>5. 静态内部类实现单例模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Holder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Holder HOLDER = <span class="keyword">new</span> Holder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.HOLDER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atomicLong.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态内部类单例模式也称单例持有者模式，实例由内部类创建，由于 JVM 在加载外部类的过程中,</span></span><br><span class="line"><span class="comment">// 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性</span></span><br></pre></td></tr></table></figure>

<p>就是把饿汉式的new 单例模式的过程<code>private final static Hungry HUNGRY = new Hungry();</code>放到个静态内部类中, 通过静态内部类的加载机制实现懒惰加载. 仍然防不住反射</p>
<h2 id="6-枚举类实现单例模式"><a href="#6-枚举类实现单例模式" class="headerlink" title="6. 枚举类实现单例模式"></a>6. 枚举类实现单例模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton</span><br><span class="line">&#123;</span><br><span class="line">    SINGLETON;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atomicLong.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个最安全, 多线程和反射都破坏不了, 反序列化的方法也破解不了. 也最简洁, 核心代码只需要3行. 加载模式和饿汉式一样, 都是提前加载. 怪不得都推荐使用这种方法</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97II/</url>
    <content><![CDATA[<p>这个题等价于leetcode 287.</p>
<p>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p>
<p>There is only <strong>one duplicate number</strong> in <code>nums</code>, return <em>this duplicate number</em>.</p>
<p><strong>Follow-ups:</strong></p>
<ol>
<li>How can we prove that at least one duplicate number must exist in <code>nums</code>? </li>
<li>Can you solve the problem <strong>without</strong> modifying the array <code>nums</code>?</li>
<li>Can you solve the problem using only constant, <code>O(1)</code> extra space?</li>
<li>Can you solve the problem with runtime complexity less than <code>O(n2)</code>?</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,2]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 3 * 104</code></li>
<li><code>nums.length == n + 1</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
<li>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</li>
</ul>
<a id="more"></a>

<h2 id="1-原地修改再改回来-原地哈希"><a href="#1-原地修改再改回来-原地哈希" class="headerlink" title="1 原地修改再改回来(原地哈希)"></a>1 原地修改再改回来(原地哈希)</h2><p>面试的时候可以问问面试官可不可以这么做. 如果可以的话这种方法最简单. </p>
<p>**对于遍历的i, 把nums[i]位置的元素置为负. 当遍历到另一个下标j的时候, 如果<code>nums[i] == nums[j]</code>, 那么将nums[j]位置的元素置为负的时候发现nums[j]位置的元素已经是负数了, 所以肯定出现了重复!**最后把数组所有元素变为正数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> value = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nums[value] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums[value] = -Math.abs(nums[value]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = Math.abs(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h2><p>不同于之前的二分查找, 都是按照下标二分数组. </p>
<p>但是这次要按照值域来二分.</p>
<p>因为所有的数都在1到n中, 我们可以设置<code>mid = begin + (end - begin) / 2</code></p>
<p><strong>在数组中统计等于mid的个数cnt0, 小于mid并且大于等于begin的个数为cnt1, 大于mid并且小于等于end的个数为cnt2.</strong></p>
<ul>
<li>如果<code>cnt0 &gt; 1</code>说明mid重复, 返回mid</li>
<li>如果<code>cnt1 &gt; mid - begin</code> 说明小于mid的元素有重复的. (因为从<code>begin</code>到<code>mid-1</code>一共就只有<code>mid - begin</code>个元素, cnt1比这个值大, 肯定有重复的元素!) 再令<code>begin = begin, end = mid - 1</code>重新查找即可</li>
<li>如果<code>cnt2 &gt; end - mid</code>说明大于mid的元素有重复的. (因为从<code>mid + 1</code>到<code>end</code>一共就只有<code>end - mid</code>个元素, cnt2比这个值大, 肯定有重复的元素!) 再令<code>begin = mid + 1, end = end</code>重新查找即可</li>
</ul>
<p>但是这种方法慢, 复杂度O(nlogn) 不是线性复杂度</p>
<p><strong>同时, 这种方法只能在数字范围==小于==数组元素数量的情况下使用.</strong>  举个例子, 如果是剑指offer 03题第一问的描述</p>
<blockquote>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
</blockquote>
<p><strong>就找不出来了. 因为数字范围为n, 数组长度也为n. 反例<code>int[] a = &#123;0, 1, 2, 3, 5, 5, 6, 7, 8, 9, 10, 11, 12&#125;;</code></strong></p>
<p><strong>因为<code>cnt0 + cnt1 + cnt2 = 数组长度</code>. 完全有机会使得<code>cnt0 == 1, cnt1 == mid - begin, cnt2 == end - mid </code>. 导致在循环的时候会满足上述3个条件都不满足<code>cnt0 &gt; 1</code>, <code>cnt1 &gt; mid - begin</code> , <code>cnt2 &gt; end - mid</code>. while进入死循环.</strong> </p>
<p><strong>而在本题中, 数字范围为n, 数组长度为n-1, 所以不会出现上述3个条件<code>cnt0 &gt; 1</code>, <code>cnt1 &gt; mid - begin</code> , <code>cnt2 &gt; end - mid</code>至少会满足一个条件! while不会进入死循环.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt0 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != nums.length; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == mid)</span><br><span class="line">                    ++cnt0;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; mid &amp;&amp; nums[i] &gt;= begin)</span><br><span class="line">                    ++cnt1;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; mid &amp;&amp; nums[i] &lt;= end)</span><br><span class="line">                    ++cnt2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt0 &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt1 &gt; mid - begin)</span><br><span class="line">            &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt2 &gt; end - mid)</span><br><span class="line">            &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-将数组看成有环链表"><a href="#3-将数组看成有环链表" class="headerlink" title="3. 将数组看成有环链表"></a>3. 将数组看成有环链表</h2><p>首先将数组看成链表, 第i个元素的下一个元素为第nums[i]个元素.</p>
<p><strong>因为数组中的值都是在1到n中的, 我们可以不断重复地做<code>i = nums[i]</code>的操作并且不越界.</strong> </p>
<p><strong>这就说明了链表肯定有环!!</strong> </p>
<p>可以这样理解 : 因为每个next指针(nums[i])都指向了一个确定的元素, 而不是指向了null (nums[i] = -1). 我们可以无限的进行i = i-&gt;next (i= nums[i])的操作.</p>
<p><strong>所以环最开始的节点肯定有两个指针指向它. 在数组中就对应了有两个值相同, 都等于成环第一个节点的下标.</strong></p>
<p><strong>但是要注意, 数组中一定不能含有元素0. 如果含有0, 就错了.</strong> </p>
<p>比如 数组 a = [1,0,2,2]. 我们从0开始寻找环的第一个节点. 会发现一直在1-&gt;0-&gt;1-&gt;0-&gt;1中循环而找不到重复的元素2.</p>
<p>没有0的时候, 是可以的. 例如, 数组 a = [1,3,2,2] 1-&gt;3-&gt;2-&gt;2-&gt;2-&gt;…..所以找到了环2-&gt;2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<p><code>0 &lt;= 节点个数 &lt;= 5000</code></p>
<a id="more"></a>

<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h2><p>和leetcode 105一样. 在前序遍历中找到根节点, 然后中序遍历中查找根节点的位置, 得到左子树元素个数和右子树元素个数. 然后再递归的构造.</p>
<p><strong>注意, 要先给中序遍历数组构建一个hashmap, 加快查找速度, 复杂度为O(n).</strong> 否则, 时间复杂度会退化到O(nlogn). </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder,inorder, <span class="number">0</span>, preorder.length -<span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preorderBegin, <span class="keyword">int</span> preorderEnd, <span class="keyword">int</span> inorderBegin, <span class="keyword">int</span> inorderEnd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorderBegin &gt; preorderEnd || inorderBegin &gt; inorderEnd)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(preorderBegin == preorderEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorderBegin == inorderEnd)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[preorderBegin]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;traverse size not match&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = preorder[preorderBegin];</span><br><span class="line">        <span class="keyword">int</span> rootIndex = map.get(root) - inorderBegin;</span><br><span class="line">        TreeNode ans = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        ans.left = buildTree(preorder, inorder, preorderBegin + <span class="number">1</span>, preorderBegin + rootIndex, inorderBegin, inorderBegin + rootIndex - <span class="number">1</span>);</span><br><span class="line">        ans.right = buildTree(preorder, inorder, preorderBegin + rootIndex + <span class="number">1</span>, preorderEnd, inorderBegin + rootIndex + <span class="number">1</span>, inorderEnd);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2004.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>等价于leetcode 240</p>
<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p><strong>Example:</strong></p>
<p>Consider the following matrix:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Given target = <code>5</code>, return <code>true</code>.</p>
<p>Given target = <code>20</code>, return <code>false</code>.</p>
<a id="more"></a>

<h2 id="1-分治"><a href="#1-分治" class="headerlink" title="1. 分治"></a>1. 分治</h2><p><strong>这是我看答案之前想出来的方法. 这个方法贼麻烦.</strong> 但是复杂度并不高</p>
<p>对于一个矩阵, 我们考虑对角线元素.</p>
<p>对对角线元素组成的数组进行二分查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,   4,  7, 11, 15],</span><br><span class="line">[2,   5,  8, 12, 19],</span><br><span class="line">[3,   6,  9, 16, 22],</span><br><span class="line">[10, 13, 14, 17, 24],</span><br><span class="line">[18, 21, 23, 26, 30]</span><br></pre></td></tr></table></figure>

<p>例如在上面这个矩阵中, 我们要寻找15. 对角线数组为[1, 5, 9, 17, 30]. 15位于9和17之间. (如果对角线中含有15, 就直接返回15即可. 不用继续查找了)</p>
<p>那么可以把矩阵分为4部分, 左上角为小于等于9的, 右下角为大于17的, 左下角和右上角的元素可能是9到17中间的, 也可能大于17. 所以元素15只有可能出现在左下和右上的子矩阵中.</p>
<blockquote>
<p>  [<strong>1,   4,  7</strong>,  ==11, 15==],<br>  [<strong>2,   5,  8</strong>,  ==12, 19==],<br>  [<strong>3,   6,  9,</strong>  ==16, 22==],<br>  [==10, 13, 14==, <strong>17, 24</strong>],<br>  [==18, 21, 23==, <strong>26,</strong> <strong>30</strong>]</p>
</blockquote>
<p>所以, 接下来就可以从这两个子矩阵中递归地查找元素15了. 递归边界为矩阵退化为行向量或列向量. 这时只需要用普通的二分查找即可.</p>
<p>这里还有个要注意的点, 就是对角线的二分查找问题.</p>
<p>如果矩阵是不是方阵, 那么如果target小于对角线第一个元素, target肯定小于这个子矩阵的所有元素. 但是, 如果target大于对角线最后一个元素, target却不一定大于这个子矩阵所有元素. </p>
<blockquote>
<p> [<strong>1</strong>,   4,  7, ==11, 15==],<br>  [2,   <strong>5</strong>,  8, ==12, 19==],<br>  [3,   6,  <strong>9</strong>, ==16, 22==],           如果target = 10, 大于对角线最后一个元素9, 就要从后面的元素中开始找</p>
</blockquote>
<blockquote>
<p>[<strong>1</strong>,   4,  7],<br>[2,   <strong>5</strong>,  8],<br>[3,   6,  <strong>9</strong>],<br>[==10, 13, 14==],<br>[==18, 21, 23==]                   如果target = 10, 大于对角线最后一个元素9, 就要从后面的元素中开始找</p>
</blockquote>
<blockquote>
<p>[1,   4,  7]<br>[2,   5,  8]<br>[3,   6,  9]                    如果矩阵是方阵, target = 10 大于对角线最后一个元素9, 那么矩阵中不可能存在target</p>
</blockquote>
<p>复杂度分析: 为了简单起见, 设矩阵为方阵, 有<code>n</code>个元素. <strong>注意, 这里是假设矩阵的元素个数为n, 而不是矩阵的维数为n.</strong> <strong>矩阵的维数应该为<code>sqrt(n) * sqrt(n)</code></strong></p>
<p>那么每一次对size为<code>sqrt(n)</code>的矩阵进行查找, 就需要先进行一次对角线的二分查找. 花费<code>log(sqrt(n))</code>, 然后对2个size为<code>n / 4</code>的矩阵进行查找.</p>
<p>故有<code>T(n) = log(sqrt(n)) + 2T(n/4)</code></p>
<p>做个换元, <code>n = 2 ^ k</code>, 得到<code>T(2^k) = k/2 + 2*T(2^(k-2))</code> 然后经过漫长的推到, 得到结果是<code>T(n) ~ sqrt(n)</code>.</p>
<p>即时间复杂度和矩阵大小成正比例.</p>
<p>如果矩阵是a * b的话, 复杂度应该为<code>sqrt(a*b)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> searchMatrix(matrix, target, <span class="number">0</span>, matrix.length - <span class="number">1</span>, <span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target, <span class="keyword">int</span> beginRow, <span class="keyword">int</span> endRow, <span class="keyword">int</span> beginColumn, <span class="keyword">int</span> endColumn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beginRow == endRow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearchRow(matrix, target, beginColumn, endColumn, beginRow);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(beginColumn == endColumn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearchColumn(matrix, target, beginRow, endRow, beginColumn);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = endRow - beginRow + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = endColumn - beginColumn + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> diagonalLen = Math.min(m, n);</span><br><span class="line">        <span class="keyword">int</span> minDiagonal = matrix[beginRow][beginColumn];</span><br><span class="line">        <span class="keyword">int</span> maxDiagonal = matrix[beginRow + diagonalLen - <span class="number">1</span>][beginColumn + diagonalLen - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target &lt; minDiagonal)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; maxDiagonal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m == n)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m &gt; n)</span><br><span class="line">                <span class="keyword">return</span> searchMatrix(matrix, target, beginRow + n, endRow, beginColumn, endColumn);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> searchMatrix(matrix, target, beginRow, endRow, beginColumn + m, endColumn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = diagonalLen - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[beginRow + mid][beginColumn + mid] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[beginRow + mid][beginColumn + mid] &lt; target)</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> searchMatrix(matrix, target, beginRow, beginRow + j, beginColumn + i, endColumn) || searchMatrix(matrix, target, beginRow + i, endRow, beginColumn, beginColumn + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">binarySearchRow</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target, <span class="keyword">int</span> beginColumn, <span class="keyword">int</span> endColumn, <span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = beginColumn;</span><br><span class="line">        <span class="keyword">int</span> end = endColumn;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][mid] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">binarySearchColumn</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target, <span class="keyword">int</span> beginRow, <span class="keyword">int</span> endRow, <span class="keyword">int</span> column)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = beginRow;</span><br><span class="line">        <span class="keyword">int</span> end = endRow;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid][column] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[mid][column] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-线性搜索法"><a href="#2-线性搜索法" class="headerlink" title="2. 线性搜索法"></a>2. 线性搜索法</h2><p><strong>这种方法真的是又简单又快! 但是感觉如果第一次做应该想不出来.</strong></p>
<p>从左下或右上开始找, 不妨假设从左下开始.</p>
<p>找的时候只能向上或向右. 原因如下, 记当前的坐标为(row, column)初始为左下角. </p>
<blockquote>
<p>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],            target = 12, curr = 18 &gt; target.  因为curr是最后一行的最小值<br>  [==18, 21, 23, 26, 30==]             所以最底下一整行都不可能是target, 全部排除掉. curr向上移动变为10</p>
</blockquote>
<blockquote>
<p>  [==1==,   4,  7, 11, 15],<br>  [==2==,   5,  8, 12, 19],<br>  [==3==,   6,  9, 16, 22],<br>  [==10==, 13, 14, 17, 24],            target = 12, curr = 10 &lt; target. 因为curr是第一行的最大值<br>  [==18, 21, 23, 26, 30==]             所以最左侧一整列都不可能是target, 全部排除掉. curr向右移动变为13</p>
</blockquote>
<blockquote>
<p>  [==1==,   4,  7, 11, 15],<br>  [==2==,   5,  8, 12, 19],<br>  [==3==,   6,  9, 16, 22],<br>  [==10==, ==13, 14, 17, 24==],            target = 12, curr = 13 &gt; target. 因为curr是倒数第二行的最小值<br>  [==18, 21, 23, 26, 30==]             所以倒数第二行都不可能是target, 全部排除掉. curr向上移动变为6</p>
</blockquote>
<blockquote>
<p> [==1==,   ==4==,  7, 11, 15],<br>  [==2==,   ==5==,  8, 12, 19],<br>  [==3==,   ==6==,  9, 16, 22],<br>  [==10==, ==13, 14, 17, 24==],            target = 12, curr = 6 &lt; target. 因为curr是第二列的最大值<br>  [==18, 21, 23, 26, 30==]             所以第二列都不可能是target, 全部排除掉. curr向右移动变为9</p>
</blockquote>
<blockquote>
<p> [==1==,   ==4==,  ==7==, 11, 15],<br>  [==2==,   ==5==,  ==8==, 12, 19],<br>  [==3==,   ==6==,  ==9==, 16, 22],<br>  [==10==, ==13, 14, 17, 24==],            target = 12, curr = 9 &lt; target. 因为curr是第三列的最大值<br>  [==18, 21, 23, 26, 30==]             所以第三列都不可能是target, 全部排除掉. curr向右移动变为16</p>
</blockquote>
<blockquote>
<p> [==1==,   ==4==,  ==7==, 11, 15],<br>  [==2==,   ==5==,  ==8==, 12, 19],<br>  [==3==,   ==6==,  ==9==, ==16, 22==],<br>  [==10==, ==13, 14, 17, 24==],            target = 12, curr = 16 &gt; target. 因为curr是第三行的最大值<br>  [==18, 21, 23, 26, 30==]             所以第三行都不可能是target, 全部排除掉. curr向上移动变为12, 找到解了!</p>
</blockquote>
<p>时间复杂度O(a + b). 虽然时间复杂度一样, 但是这种方法空间复杂度是O(1). 并且代码<strong>极其简洁</strong>!!!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; -<span class="number">1</span> &amp;&amp; j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = matrix[i][j];</span><br><span class="line">            <span class="keyword">if</span>(curr == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curr &lt; target)</span><br><span class="line">                ++j;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>


<p>限制：</p>
<p><code>0 &lt;= s 的长度 &lt;= 10000</code></p>
<a id="more"></a>

<h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><p>和leetcode 26的双指针解法差不多.</p>
<p>假设字符串后面的空间充足, 可以从后向前的构造, i指向原来字符串的最后一个元素, k指向新字符串的最后一个元素.</p>
<p>每当碰到一个空格时,就在k上插入”%20”, 没有碰到空格时, 就插入s[i]. 同时更新i和k.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> spaceCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                ++spaceCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[s.length() + <span class="number">2</span> * spaceCount];</span><br><span class="line">        <span class="keyword">int</span> k = chars.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt; -<span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                chars[k--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                chars[k--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                chars[k--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                chars[k--] = s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<p><code>0 &lt;= 链表长度 &lt;= 10000</code></p>
<a id="more"></a>

<h2 id="1-链表反转"><a href="#1-链表反转" class="headerlink" title="1. 链表反转"></a>1. 链表反转</h2><p>如果可以改变链表结构, 直接翻转过来再打印即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head == <span class="keyword">null</span> ? <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>] : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;head.val&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[getLength(head)];</span><br><span class="line">        ListNode newHead = reverseLinkedList(head);</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode i = newHead; i != <span class="keyword">null</span>; i= i.next)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[k++] = i.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode i = head; i != <span class="keyword">null</span>; i = i.next)</span><br><span class="line">        &#123;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseLinkedList</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head.next;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-直接打印"><a href="#2-直接打印" class="headerlink" title="2. 直接打印"></a>2. 直接打印</h2><p>如果不要求链表可以翻转, 只能先用个数组存储, 然后翻转即可. 但是栈可以更简洁的做到这个操作.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(ListNode i = head; i != <span class="keyword">null</span>; i = i.next)</span><br><span class="line">        &#123;</span><br><span class="line">            dq.offerFirst(i.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[dq.size()];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            ans[k++] = dq.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2010-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p><code>0 &lt;= n &lt;= 100</code></p>
<h2 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1. 迭代"></a>1. 迭代</h2><p>这题不能用递归, 要么就是时间复杂度太高, 要么就是空间太高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> fib_i_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fib_i_1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = (fib_i_1 + fib_i_2) %<span class="number">1000000007</span>;</span><br><span class="line">            fib_i_2 = fib_i_1;</span><br><span class="line">            fib_i_1 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib_i_1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p><code>1 &lt;= values &lt;= 10000</code><br>最多会对 appendTail、deleteHead 进行 10000 次调用</p>
<a id="more"></a>

<h2 id="1-栈实现队列"><a href="#1-栈实现队列" class="headerlink" title="1. 栈实现队列"></a>1. 栈实现队列</h2><p>等价于leetcode 232</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; deq1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; deq2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deq1.size() + deq2.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        deq2.offerFirst(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(deq1.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!deq2.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                deq1.offerFirst(deq2.pollFirst());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deq1.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p><code>0 &lt;= n &lt;= 100</code></p>
<h2 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1. 迭代"></a>1. 迭代</h2><p>等价于Fibonacci问题, 只不过初始值成了(1, 1)而不是(0,1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fib_i_2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fib_i_1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = (fib_i_1 + fib_i_2) %<span class="number">1000000007</span>;</span><br><span class="line">            fib_i_2 = fib_i_1;</span><br><span class="line">            fib_i_1 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib_i_1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2008.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>给定一棵二叉树和其中的一个节点, 如何找出中序遍历序列的下一个节点? 树中的节点除了有两个分别指向左,右子节点的指针, 还有一个指向父节点的指针.</p>
<a id="more"></a>

<h2 id="1-逻辑判断"><a href="#1-逻辑判断" class="headerlink" title="1.逻辑判断"></a>1.逻辑判断</h2><p>根据中序遍历的特点, 左子树-&gt;根节点-&gt;右子树.</p>
<p>如果这个节点的右子树不为空, <strong>一个节点中序遍历的下一个节点就等价于这个节点右子树中序遍历的第一个节点!!</strong>, 也就是这个节点右子树的最左侧节点.</p>
<p>如果这个节点的右子树为空, 并且这个节点是一个左孩子, 那么也根据中序遍历的特点, 下一个遍历的就是它的父节点.</p>
<p>如果这个节点的右子树为空, 并且没有父节点,  那么这个节点应该是中序遍历的最后一个节点了, 返回空即可.</p>
<p>**如果这个节点的右子树为空, 并且这个节点是一个右孩子, 这种情况比较难处理, 我们需要判断父节点是左孩子还是右孩子, 如果是左孩子的话, 那么返回这个父节点的父节点即可. **</p>
<p><strong>如果父节点仍然是右孩子, 再继续往上找, 直到找到某个祖先A是一个左孩子, 返回祖先A的父节点.</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F;</span><br><span class="line">2    &lt;- 第2步. 2是一个左孩子, 所以直接返回2的父节点1</span><br><span class="line">\</span><br><span class="line">  3  &lt;- 第1步. 查找3的下一个遍历节点, 3的右子树为空并且是一个右孩子,去查看3的父节点2</span><br><span class="line"> &#x2F;</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  0</span><br><span class="line"> &#x2F;</span><br><span class="line">1          &lt;- 第4步. 1是一个左孩子, 所以1的父节点0是节点6的下一个遍历节点</span><br><span class="line"> \</span><br><span class="line">  2        &lt;- 第3步. 2也是一个右孩子, 继续查找2的父节点1.</span><br><span class="line"> &#x2F; \</span><br><span class="line">3   4      &lt;- 第2步. 4是一个右孩子, 继续查找4的父节点2.</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  5    6   &lt;- 第1步. 查找6的下一个遍历节点, 6的右子树为空, 并且是一个右孩子, 查找父节点4</span><br><span class="line">      &#x2F;</span><br><span class="line">     7</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;                //这里的next表示当前节点的父节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeLinkNode ans = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(ans.left != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = ans.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeLinkNode curr = pNode;</span><br><span class="line">        <span class="keyword">while</span>(curr.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.left == curr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],</span><br><span class="line">[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],</span><br><span class="line">[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]</span><br></pre></td></tr></table></figure>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p><code>1 &lt;= board.length &lt;= 200</code><br><code>1 &lt;= board[i].length &lt;= 200</code></p>
<h2 id="1-DFS"><a href="#1-DFS" class="headerlink" title="1. DFS"></a>1. DFS</h2><p>普通的dfs做法. 创建一个boolean二维数组, 储存某个元素是否遍历过.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] isTraversed = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(exists(board, i, j, word, <span class="number">0</span>, isTraversed))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, String word, <span class="keyword">int</span> stringIndex, <span class="keyword">boolean</span>[][] isTraversed)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stringIndex == word.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isValid(board, i, j) || board[i][j] != word.charAt(stringIndex) || isTraversed[i][j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isTraversed[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ans = exists(board, i+<span class="number">1</span>, j, word, stringIndex+<span class="number">1</span>, isTraversed) || exists(board, i-<span class="number">1</span>, j, word, stringIndex+<span class="number">1</span>, isTraversed) || exists(board, i, j+<span class="number">1</span>, word, stringIndex+<span class="number">1</span>, isTraversed) || exists(board, i, j-<span class="number">1</span>, word, stringIndex+<span class="number">1</span>, isTraversed);</span><br><span class="line">        isTraversed[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[i].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-空间复杂度为O-1-的算法"><a href="#2-空间复杂度为O-1-的算法" class="headerlink" title="2. 空间复杂度为O(1)的算法"></a>2. 空间复杂度为O(1)的算法</h2><p>这次不用多余的数组存储某个元素有没有被遍历过了.</p>
<p>我们直接用<code>&#39;\0&#39;</code>来表示一个字符被遍历过. 完成dfs之后再把这个位置的<code>&#39;\0&#39;</code>改回原来的字符</p>
<p>注意, 必须保证原来的矩阵中没有<code>&#39;\0&#39;</code>. 否则会出错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] isTraversed = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(exists(board, i, j, word, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, String word, <span class="keyword">int</span> stringIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stringIndex == word.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isValid(board, i, j) || board[i][j] != word.charAt(stringIndex))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;       <span class="comment">//equals isTraversed[i][j] = true;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> ans = exists(board, i+<span class="number">1</span>, j, word, stringIndex+<span class="number">1</span>) || exists(board, i-<span class="number">1</span>, j, word, stringIndex+<span class="number">1</span>) || exists(board, i, j+<span class="number">1</span>, word, stringIndex+<span class="number">1</span>) || exists(board, i, j-<span class="number">1</span>, word, stringIndex+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        board[i][j] = tmp;       <span class="comment">//equals isTraversed[i][j] = false;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[i].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="1-一次失败的尝试"><a href="#1-一次失败的尝试" class="headerlink" title="1.一次失败的尝试"></a>1.一次失败的尝试</h2><p>这题思路很简单, 就是求出mid之后然后和两端元素比较, 判断最小值在mid左边还是右边.</p>
<p>重点是处理重复的元素. 如果<code>numbers[mid] == numbers[begin]</code>或<code>numbers[end]</code>会怎样.</p>
<p>我一开始是同时用了三个元素来判断, <code>numbers[mid], numbers[begin], numbers[end]</code></p>
<ul>
<li><p>如果<code>numbers[begin] == numbers[mid]</code>, 就将begin右移直到不等于<code>numbers[mid]</code></p>
</li>
<li><p>如果<code>numbers[end] == numbers[mid]</code>, 就将end左移直到不等于<code>numbers[mid]</code></p>
</li>
<li><p>如果<code>numbers[mid] &gt; numbers[begin] </code>就说明最小值在mid到end中</p>
</li>
<li><p>如果<code>numbers[mid] &lt; numbers[end]</code>就说明最小值在begin到mid中.</p>
</li>
</ul>
<p>后来发现这三个元素是不必要的. 只需要判断<code>numbers[mid], numbers[end]</code>即可. 因为比<code>numbers[end]</code>大并且比<code>numbers[begin]</code>小的元素是不存在的. 只要比<code>numbers[end]</code>大就可以说明最小值在<code>mid</code>到<code>end</code>中了.</p>
<p>而且, 如果碰到了<code>numbers[end] == numbers[mid]</code>的情况, 只需要end左移一次就好, 下一次迭代重新计算mid和end就好, 不用一直移动end直到<code>numbers[end] != numbers[mid]</code>. 时间上不会有任何提升而且会使得逻辑错误.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//失败代码, 最后被numbers[mid] == numbers[end]和numbers[mid] == numbers[begin]这种情况搞得一团糟</span></span><br><span class="line"><span class="comment">//并且会得到错误的解! 反例[10,1,10,10,10]</span></span><br><span class="line"><span class="comment">//第一次有begin = 0, mid = 2, end = 4</span></span><br><span class="line"><span class="comment">//然后因为numbers[mid] == numbers[end]和numbers[mid] == numbers[begin]不断地右移begin和左移end</span></span><br><span class="line"><span class="comment">//得到begin = 1, mid = 2, end = 2</span></span><br><span class="line"><span class="comment">//然后因为有判断numbers[mid] &gt; numbers[begin]成立, 进入mid到end中查找最小值, 得到10. 但是事实上错过了最小值1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;InvalidInputException&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[end] &gt; numbers[begin])</span><br><span class="line">            <span class="keyword">return</span> numbers[begin];</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(numbers[mid] == numbers[begin] &amp;&amp; begin &lt; mid)</span><br><span class="line">            &#123;</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(numbers[mid] == numbers[end] &amp;&amp; end &gt; mid)</span><br><span class="line">            &#123;</span><br><span class="line">                --end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt; numbers[begin])</span><br><span class="line">            &#123;</span><br><span class="line">                begin = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; numbers[end])</span><br><span class="line">            &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(numbers[begin], numbers[end]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-正确解法"><a href="#2-正确解法" class="headerlink" title="2. 正确解法"></a>2. 正确解法</h2><p>只需要判断<code>numbers[mid], numbers[end]</code>即可. 因为比<code>numbers[end]</code>大并且比<code>numbers[begin]</code>小的元素是不存在的. 只要比<code>numbers[end]</code>大就可以说明最小值在<code>mid</code>到<code>end</code>中了.</p>
<p>而且, 如果碰到了<code>numbers[end] == numbers[mid]</code>的情况, 只需要end左移一次就好, 下一次迭代重新计算mid和end就好, 不用一直移动end直到<code>numbers[end] != numbers[mid]</code>. 时间上不会有任何提升而且会使得逻辑错误.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;InvalidInputException&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[end] &gt; numbers[begin])</span><br><span class="line">            <span class="keyword">return</span> numbers[begin];</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt; numbers[end])</span><br><span class="line">            &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; numbers[end])</span><br><span class="line">            &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                --end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[begin];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2013.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p><code>1 &lt;= n,m &lt;= 100</code><br><code>0 &lt;= k &lt;= 20</code></p>
<a id="more"></a>

<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h2><p><code>dp[i][j]</code>表示是否能达到<code>(i, j)</code></p>
<p>所以得到关系, <code>dp[i][j] = (dp[i-1][j] == true || dp[i][j-1] == true) &amp;&amp; (intToDigitSum(i) + intToDigitSum(j) &lt;= k)</code>. <strong>即能达到(i, j)的条件为至少能到(i-1, j)或(i, j-1), 并且i和j的数位和小于等于k</strong></p>
<p>这里有个问题, 就是<strong>为什么只判断能到(i-1, j)或(i, j-1)就可以了?</strong> </p>
<p>事实上, 这个假设确实是对的, 也就是说, 不会出现一种情况, <code>(i-1, j)</code>和<code>(i, j-1)</code>不可达, 但<code>(i,j)</code>可达. 具体证明我还不会, 但是画个图慢慢理解还是能理解出来的.</p>
<p>我感觉这个题BFS或DFS更适合. 不会出现上面的状态方程正确性证明证不出来的问题, 直接模拟就完事了. 而且复杂度还一样.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = (dp[<span class="number">0</span>][i-<span class="number">1</span>] == <span class="keyword">true</span>) &amp;&amp; (intToDigitSum(i) &lt;= k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = (dp[i-<span class="number">1</span>][<span class="number">0</span>] == <span class="keyword">true</span>) &amp;&amp; (intToDigitSum(i) &lt;= k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = (dp[i-<span class="number">1</span>][j] == <span class="keyword">true</span> || dp[i][j-<span class="number">1</span>] == <span class="keyword">true</span>) &amp;&amp; (intToDigitSum(i) + intToDigitSum(j) &lt;= k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">boolean</span>[] i : dp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">boolean</span> j : i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j)</span><br><span class="line">                    ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">intToDigitSum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2. BFS"></a>2. BFS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;Pair&lt;Integer, Integer&gt;&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] di = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dj = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        q.offer(<span class="keyword">new</span> Pair&lt;Integer,Integer&gt;(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            Pair&lt;Integer, Integer&gt; curr = q.poll();</span><br><span class="line">            <span class="keyword">int</span> i = curr.getKey();</span><br><span class="line">            <span class="keyword">int</span> j = curr.getValue();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; di.length; ++s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> newI = i + di[s];</span><br><span class="line">                <span class="keyword">int</span> newJ = j + dj[s];</span><br><span class="line">                <span class="keyword">if</span>(newI &gt;=<span class="number">0</span> &amp;&amp; newI &lt; m &amp;&amp; newJ &gt;= <span class="number">0</span> &amp;&amp; newJ &lt; n &amp;&amp; !dp[newI][newJ] &amp;&amp; intToDigitSum(newI) + intToDigitSum(newJ) &lt;= k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[newI][newJ] = <span class="keyword">true</span>;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> Pair&lt;Integer, Integer&gt;(newI, newJ));</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">intToDigitSum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2014-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p><code>2 &lt;= n &lt;= 58</code></p>
<h2 id="1-贪心"><a href="#1-贪心" class="headerlink" title="1. 贪心"></a>1. 贪心</h2><p>如果我们给定了绳子长度n, 和绳子个数m, 那么就可以在O(1)时间内算出来最大乘积.</p>
<p>假设绳子可以取值实数, 最大解肯定是每个绳子的长度都一样长, 这样才能最大. 很简单的原理, 如果一个绳子长为a, 一个绳子长为b, (a != b), 那么换一种剪法, 都剪成(a + b) / 2的长度, 那么新的乘积<code>((a + b) / 2) ^ 2</code>肯定大于原来的乘积<code>ab</code>. (均值不等式)</p>
<p>所以, 每个绳子的长度就为n/m的时候最大. 但是这里要求绳子长度为整数, 所以必定有的绳子长度是<code>floor(n/m)</code>, 有的长度为<code>floor(n/m) + 1</code>. 但是不会出现任意两条绳子的差值超过1的情况. </p>
<p>所以, 应该有<code>n % m</code>条绳子长为<code>floor(n/m) + 1</code>, <code>m - n % m </code>条绳子长为<code>floor(n/m)</code>. 计算乘积即可.</p>
<p>最后, m由2遍历到n, 找出最大的返回即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> maxProduct = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">2</span>; m &lt;= n; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            maxProduct = Math.max(maxProduct, cuttingRope(n,m));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = n / m;</span><br><span class="line">        <span class="keyword">int</span> len_Plus1 = len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count_len_Plus1 = n % m;</span><br><span class="line">        <span class="keyword">int</span> count_len = m - count_len_Plus1;</span><br><span class="line">        <span class="keyword">return</span> Math.pow(len, count_len) * Math.pow(len_Plus1, count_len_Plus1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-数学推导"><a href="#2-数学推导" class="headerlink" title="2. 数学推导"></a>2. 数学推导</h2><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/">https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/</a></p>
<p>这个方法真的巧妙, 我一开始用的绳子的个数m推导的, 即求(n/m)^m的最大值, 得到m = n/e. 然后去用两个整数逼近m. 但是这个是不对的, 因为当n = 30的时候, m = 11.03. 如果用11和12逼近的话, 永远不会找到最大值是m = 10.</p>
<p>但是用绳子的长度x就可以, 推导出来x = e的时候有最大值. 整数逼近e为2或3, 同时, 2个3的乘积比3个2的乘积大, 就一段一段的截取3就可以了.</p>
<p>同时要注意特殊情况, 如果最后一段是1, 那么把上一段的3匀出来成为2 * 2, 会比3 * 1大.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> m = n / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> remain = n % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(remain == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, m-<span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, m) * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2014-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/</url>
    <content><![CDATA[<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p><code>2 &lt;= n &lt;= 1000</code></p>
<h2 id="1-快速幂求余-递归"><a href="#1-快速幂求余-递归" class="headerlink" title="1. 快速幂求余(递归)"></a>1. 快速幂求余(递归)</h2><p>和上一题<code>剑指 Offer 14- I. 剪绳子</code>一样, 只不过这次要求出的数很大, 需要取模.</p>
<p>整道题的难点都在pow(3,m) % c上面了</p>
<p>先用java内置函数求出pow(3,m)再取模肯定是不行的, 那样pow(3,m)会太大了超过long的范围. 所以我们只能自己定义一个函数<code>long pow(int a, int b, int c)</code> 来计算a ^ b % c.</p>
<p>这里就用到了快速幂.  递归的快速幂很简单, 但是循环的快速幂想要理解并不简单. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> ans = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">int</span> m = n / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> remain = n % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">1000000007</span>;</span><br><span class="line">            <span class="keyword">if</span>(remain == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = pow(<span class="number">3</span>, m, c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = pow(<span class="number">3</span>, m-<span class="number">1</span>, c) * <span class="number">4</span> % c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans = pow(<span class="number">3</span>, m, c) * <span class="number">2</span> % c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> a % c;</span><br><span class="line">        <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> pow(a, b/<span class="number">2</span>, c) * pow(a, b/<span class="number">2</span>, c) % c;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (pow(a, b/<span class="number">2</span>, c) * a % c) * pow(a, b/<span class="number">2</span>, c) % c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-快速幂-循环"><a href="#2-快速幂-循环" class="headerlink" title="2. 快速幂(循环)"></a>2. 快速幂(循环)</h2><p>参考于<a href="https://zhuanlan.zhihu.com/p/95902286">https://zhuanlan.zhihu.com/p/95902286</a></p>
<p>通过2进制的运算, 转化指数.</p>
<p>例如要计算a的10次幂, 10写为2进制之后为1010</p>
<p>可以转化为 0个a的1次幂, 1个a的2次幂, 0个a的4次幂, 1个a的8次幂.</p>
<p>所以依次计算即可. </p>
<p>记a的起始值为a0</p>
<p>从a的1次幂开始, 如果n末尾为0, 就说明没有a的1次幂, ans不变,  a变为a * a. n = n / 2.</p>
<p>现在n = 5, 末尾为1, a = a0^2, 说明有1个a的2次幂, *<em>ans <em>= a,</em></em> 再次更新a变为a * a. n = n / 2.</p>
<p>现在n = 2, 末尾为0, a = a0^4, 说明没有a的4次幂, ans不变, 再次更新a变为a * a. n = n / 2.</p>
<p>现在n = 1, 末尾为1, a = a0^8, 说明有1个a的8次幂, *<em>ans <em>= a,</em></em> 再次更新a变为a * a. n = n / 2.</p>
<p>现在 n = 0, 结束循环.</p>
<p>从上面看出, ans 与a0^2相乘过一次, 与a0^8相乘一次, 刚好为a0^10.</p>
<p>这种方法应该是快速幂最优解法了, 对数复杂度, 常数空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a0, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a = a0;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = b;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = ans * a % c;</span><br><span class="line">            &#125;</span><br><span class="line">            a = a * a % c;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2015.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p><code>输入必须是长度为 32 的 二进制串 。</code></p>
<h2 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1. 位运算"></a>1. 位运算</h2><p>和leetcode 191相同, 不断地使用n = n &amp; (n - 1)操作即可, 直到n == 0</p>
<p>也可以使用一个游标cursor = 1, cursor每次左移一位, 每次都与n进行AND位运算, 统计位运算中1的个数.</p>
<p>也可以判断n最后一位是不是1, 然后将n不断地右移, 直到n = 0. 这种方法要注意一定要用无符号右移, 即java中的&gt;&gt;&gt;.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2016.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ul>
<li>-100.0 &lt; x &lt; 100.0</li>
<li>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li>
</ul>
<h2 id="1-快速幂"><a href="#1-快速幂" class="headerlink" title="1. 快速幂"></a>1. 快速幂</h2><p>题本身不难, 就是要注意先判断边界条件, 这个题边界条件非常多!</p>
<p>首先要判断x是不是等于0. 而不是先判断n是不是等于0. (如果你先判断n, n为负, 返回1/x的-n次方. 如果这时候x为0就gg了.)</p>
<p>x如果等于0, 对于大于0的n, 小于0的n, 等于0的n都有处理方法.</p>
<p>这里还要注意判断x为0的时候是浮点数直接用<code>==</code>来判断还是要指定eps. 如果是面试可以问面试官怎么处理.</p>
<p>处理完x等于0之后, 再处理n小于等于0了</p>
<p>等于0, 小于0都好说, <strong>但是不要忘了这有个坑<code>n = -2147483648 = INT_MIN</code>. 如果直接判断n&lt;0就转化成1/x的-n次方那肯定这里会出错!!!</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">&quot;Undefined behavior&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> Double.POSITIVE_INFINITY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span> &amp;&amp; n != Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> myPow(<span class="number">1</span>/x, -n);</span><br><span class="line">        <span class="keyword">if</span>(n == Integer.MIN_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> myPow(x, Integer.MIN_VALUE + <span class="number">1</span>) * myPow(x, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2017.%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p><code>用返回一个整数列表来代替打印</code><br><code>n 为正整数</code></p>
<h2 id="1-大数运算"><a href="#1-大数运算" class="headerlink" title="1. 大数运算"></a>1. 大数运算</h2><p>这题要是按照leetcode来, 肯定不行. leetcode上面的函数是<code>public int[] printNumbers(int n)</code>. 因为返回值是<code>int[]</code>, 自然不需要考虑int溢出的问题. 没法达到使用大数的效果. </p>
<p>还是自己写一个吧. 这题的关键在于</p>
<ul>
<li>是否判断n&lt;=0的情况</li>
<li>字符串表示的数的加1操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        String begin = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (begin.length() &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(begin);</span><br><span class="line">            begin = stringIncrement(begin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">stringIncrement</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = chars.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] != <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span>[] ans = <span class="keyword">new</span> <span class="keyword">char</span>[chars.length + <span class="number">1</span>];</span><br><span class="line">            ans[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; ans.length; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[k] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  String.valueOf(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            chars[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; chars.length; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                chars[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//test cases</span></span><br><span class="line">        <span class="comment">// n = 0, -1, 1, 2, 3</span></span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(s.printNumbers(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2020.%20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<a id="more"></a>

<h2 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h2><p>和leetcode 65一样。 这题极其繁琐, 错一点都不行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S0 = <span class="number">0</span>;  <span class="comment">// begin state</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S1 = <span class="number">1</span>;  <span class="comment">// digits before &#x27;e&#x27; and &#x27;.&#x27;, after head &#x27;+/-&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S2 = <span class="number">2</span>; <span class="comment">// state to absorb the first &quot;+/-&quot; before &#x27;e&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S3 = <span class="number">3</span>; <span class="comment">// state that absorb a &quot;.&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S4 = <span class="number">4</span>; <span class="comment">// digits after &#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S5 = <span class="number">5</span>; <span class="comment">// state that absorb &#x27;e&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S6 = <span class="number">6</span>; <span class="comment">// digits after &#x27;e&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S7 = <span class="number">7</span>; <span class="comment">// state that absorb &#x27;+/-&#x27; after &#x27;e&#x27;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Serr = -<span class="number">1</span>; <span class="comment">//error state</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; validSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] tran = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,<span class="number">7</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        validSet.add(S1);</span><br><span class="line">        validSet.add(S4);</span><br><span class="line">        validSet.add(S6);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">make</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit(ch))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">if</span>(s.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> state = S0;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> curr = make(ch);</span><br><span class="line">            <span class="keyword">if</span>(curr == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            state = tran[state][curr];</span><br><span class="line">            <span class="keyword">if</span>(state == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> validSet.contains(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9I/</url>
    <content><![CDATA[<p>给定单向链表的头指针和一个要删除的节点，定义一个函数删除该节点。</p>
<a id="more"></a>

<h2 id="1-分类讨论"><a href="#1-分类讨论" class="headerlink" title="1. 分类讨论"></a>1. 分类讨论</h2><p>这题leetcode有类似的题, 给定一个指向非尾节点的指针, 用O(1)的时间删除这个节点. 方法就是复制下一个节点的值到这一个节点上， 然后删除下一个节点.</p>
<p>这个题也一样, 如果被删除的节点不是最后一个, 就按照上面的方法来判断. 如果是最后一个, 那么只能遍历一遍链表来删除了</p>
<p>一定要注意2种特=特殊情况</p>
<ul>
<li>给的链表或被删除的节点为null</li>
<li>被删除的节点是链表的头节点, 并且链表只有1个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ListNode curr = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(curr.val);</span><br><span class="line">            sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode toBeDeleted)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || toBeDeleted == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;input is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(toBeDeleted.next == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head == toBeDeleted)&#123;      <span class="comment">//特别要注意这一行</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode curr = head;</span><br><span class="line">            <span class="keyword">while</span>(curr != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(curr.next == toBeDeleted)</span><br><span class="line">                &#123;</span><br><span class="line">                    curr.next = curr.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            toBeDeleted.val = toBeDeleted.next.val;</span><br><span class="line">            toBeDeleted.next = toBeDeleted.next.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode a1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode a2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode a3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode a4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode a5 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        ListNode a6 = <span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">        a1.next = a2;</span><br><span class="line">        a2.next = a3;</span><br><span class="line">        a3.next = a4;</span><br><span class="line">        a4.next = a5;</span><br><span class="line">        a5.next = a6;</span><br><span class="line">        ListNode single = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="comment">//test null LinkedList, one element LinkedList, regular LinkedList</span></span><br><span class="line">        System.out.println(s.deleteNode(a1, a4));</span><br><span class="line">        System.out.println(s.deleteNode(single, single));</span><br><span class="line">        System.out.println(s.deleteNode(<span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2019.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<p>示例 1:</p>
<p>输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 5:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和无连续的 ‘*’。</p>
<a id="more"></a>

<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h2><p>还是动态规划好理解</p>
<p><code>dp[i][j]</code>表示字符串<code>s</code>的字串<code>[0, ..., i-1]</code>是不是与正则表达式<code>p</code>的字串<code>[0, ..., j-1]</code>是不是匹配.</p>
<p>注意这里代表的是不包含第<code>i</code>个元素和第<code>j</code>个元素的字串.</p>
<p>所以<code>dp[i][j]</code>为true的条件就是<code>s</code>的字串<code>s[0, ..., i-1]</code>和<code>p</code>的字串<code>p[0, ..., j-1]</code>匹配</p>
<p>显然p字串的最后一个元素<code>p[j-1]</code>很关键. </p>
<ul>
<li><p>如果<code>p[j-1] == &#39;.&#39;</code>, 那么这个<code>&#39;.&#39;</code>必然消耗s的一个字符, 并且是什么字符都行. 所以只要<code>s[0, ..., i-2]</code>和<code>p[0, ..., j-2]</code>匹配即可. 即只要<code>dp[i][j] = dp[i-1][j-1]</code></p>
</li>
<li><p>如果<code>p[j-1]</code>为一个普通字符, 普通字符也必须消耗s中的一个字符, 并且消耗的字符必须和这个字符相等. 所以需要<code>s[0, ..., i-2]</code>和<code>p[0, ..., j-2]</code>匹配, 并且<code>s[i-1] == p[j-1]</code>. 即<code>dp[i][j] = dp[i-1][j-1] &amp;&amp; s[i-1] == p[j-1]</code></p>
</li>
<li><p>如果<code>p[j-1] == &#39;*&#39;</code>, 那么我们需要找到星号前的字符<code>charBeforeStar</code>. 并且星号也可以匹配0个字符或多个字符.</p>
<ul>
<li>如果星号匹配0个字符, 那么就要保证<code>dp[i][j-2]</code>为true. 例如<code>s = &quot;123&quot;</code>, <code>p = &quot;.234*&quot;</code>. 判断<code>.234*</code>能不能匹配<code>123</code>只需要判断<code>.23</code>能不能匹配<code>123</code>.</li>
<li>如果星号匹配多个字符, 那么就要保证星号代表的字符和s里面的字符相等, 即<code>charBeforeStar == &#39;.&#39; || charBeforeStar == s.charAt(i-1)</code>. 并且要保证<code>dp[i-1][j]</code>为true. 例如<code>s = &quot;123&quot;</code>, <code>p = &quot;123*&quot;</code> 这时<code>charBeforeStar</code>为’3’, 并且s的最后一个字符也为3, 所以只需要保证<code>&quot;123*&quot;</code>能不能匹配<code>&quot;12&quot;</code>即可</li>
</ul>
</li>
</ul>
<p>同时还要先求出边界条件. 显然空正则表达式可以匹配空字符串<code>dp[0][0] = true</code></p>
<p>空的正则表达式不能匹配任何非空字符串. <code>dp[i][0] = false (i &gt; 0)</code></p>
<p>普通的正则表达式只有在特殊情况下才能匹配空字符串. 特殊情况即为一个普通字符一个星号组成的正则表达式. 例如<code>&quot;1*.*2*3*a*&quot;</code>这样的. 并且所有的星号都按0次匹配来计算. 所以<code>dp[0][j] = (p.charAt(j-1) == &#39;*&#39;) &amp;&amp; dp[0][j-2]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || p == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> pLen = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sLen+<span class="number">1</span>][pLen+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sLen; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pLen; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - <span class="number">2</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid REGEX that starts with &#x27;*&#x27;.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sLen; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pLen; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - <span class="number">2</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid REGEX that starts with &#x27;*&#x27;.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> charBeforeStar = p.charAt(j-<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">boolean</span> notUseStar = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">boolean</span> useStar = (charBeforeStar == <span class="string">&#x27;.&#x27;</span> || charBeforeStar == s.charAt(i-<span class="number">1</span>)) &amp;&amp; dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    dp[i][j] = notUseStar || useStar;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sLen][pLen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h2><p>根据上面的分析, 写出递归的程序就很简单了.</p>
<p>但是速度相比就慢很多了.<strong>(一顿操作猛如虎, 一看击败百分五)</strong> 个人推测应该是因为星号变多的时候会发生指数爆炸.</p>
<p>例如 <code>s = &quot;aaaaaaaaaaaaab&quot;, p = &quot;a*a*a*a*a*a*a*&quot;</code></p>
<p>每一次都走<code>return isMatch(s.substring(1), p) || isMatch(s, p.substring(2));</code>这一条逻辑分支. 最坏情况时复杂度将会为O(2^n)!</p>
<p>同时, 每一次传递参数都会经过string的构造和复制, 也对速度造成了很大的影响. </p>
<p><strong>怀念C的指针, 虽然出了错很难调试, 但是确实快啊</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || p == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(p))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.equals(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatchEmptyString(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.startsWith(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid REGEX that starts with &#x27;*&#x27;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.length() &gt; <span class="number">1</span> &amp;&amp; p.charAt(<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(<span class="number">0</span>) == <span class="string">&#x27;.&#x27;</span> || p.charAt(<span class="number">0</span>) == s.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> isMatch(s.substring(<span class="number">1</span>), p) || isMatch(s, p.substring(<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> isMatch(s, p.substring(<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(<span class="number">0</span>) == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (s.charAt(<span class="number">0</span>) == p.charAt(<span class="number">0</span>)) &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatchEmptyString</span><span class="params">(String p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.length() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.length() &gt; <span class="number">1</span> &amp;&amp; p.charAt(<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatchEmptyString(p.substring(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9II/</url>
    <content><![CDATA[<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<a id="more"></a>

<h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><p>用begin和end查找某一段val相同的范围[begin,end), 这个范围内的值都相同. 如果范围内的值只有1个, 就什么都不做, 如果大于1个就删掉这个范围的所有节点.</p>
<p><strong>总是给链表加头节点是一个好事情, 这样可以免去很多的麻烦</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode begin_prev = dummyHead;</span><br><span class="line">        ListNode begin = dummyHead.next;</span><br><span class="line">        ListNode end = dummyHead.next;</span><br><span class="line">        <span class="keyword">while</span>(begin != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(end != <span class="keyword">null</span> &amp;&amp; end.val == begin.val)</span><br><span class="line">            &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end != begin.next)</span><br><span class="line">            &#123;</span><br><span class="line">                begin_prev.next = end;</span><br><span class="line">                begin = end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                begin_prev = begin_prev.next;</span><br><span class="line">                begin = begin.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2023.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<a id="more"></a>

<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>快慢指针，快指针每次前进两个长度，慢指针每次前进一个长度，若存在环，则一定会在环内相遇。<br>假设起点到环入口长度a，环入口到相遇点长度为b，相遇点到环入口长度为c，环长度为r，则有如下关系:<br>2(a+b) = a+b+nr   =&gt;  a+b = nr<br>b + c = r  ==&gt; a+r-c = nr</p>
<p>a = c+(n-1)r</p>
<p>所以当存在环时，令两个指针分别从相遇点和头出发，相遇点即为环入口</p>
<p>因为如果快指针从相遇点开始走, 慢指针从头开始走, 当慢指针走到环入口的时候, 即走了a, 这次是快慢指针每一次都走一步. 所以快指针也走了a, 根据上面的推导, <code>a = c+(n-1)r</code>, 所以快指针从相遇点走了c+(n-1)r, 即也是正好走到环的入口节点.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = pHead.next.next;</span><br><span class="line">        ListNode slow = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2021.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p><code>1 &lt;= nums.length &lt;= 50000</code><br><code>1 &lt;= nums[i] &lt;= 10000</code></p>
<a id="more"></a>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>方法很简单, 双指针就ok</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; nums[j] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2024.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p>也是很经典的一个问题了, 就不再讲思路了 和leetcode 206相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head.next;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line"></span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dummyHead.next.next = <span class="keyword">null</span>;</span><br><span class="line">        dummyHead.next = p1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h2><p>这个题主要是判断特殊条件, 如果传入的head为null如何处理, 如果k &lt;= 0如何处理, 如果k大于链表长度如何处理. 这些都需要用if逐个判断. 判断后再写出程序就很简单了. 因为保证了head不为空, 并且0 &lt; k &lt;= len</p>
<p>第一次遍历是找出链表长度, 第二次遍历找出倒数第k个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode i = head; i != <span class="keyword">null</span>; i = i.next)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span> || k &gt; len)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rank = len - k;</span><br><span class="line">        ListNode ans = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rank; ++i)&#123;</span><br><span class="line">            ans = ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h2><p>上面方法的改进版, 用两个指针, 快指针走k步之后慢指针再走. 快指针走到链表尾部的时候慢指针刚好走到倒数第k个节点.</p>
<p>同样要注意k大于链表长度的情况, 这时快指针走完慢指针还没开始走</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;k &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span>)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;k &gt; length of list&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2026.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>
<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>限制：</p>
<p><code>0 &lt;= 节点个数 &lt;= 10000</code></p>
<a id="more"></a>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>首先要确定的是我们要完成两件事情, 一件事情是判断某个树A是不是含有树B的子结构, 由于树B的根节点不一定是树A的根节点, 可能是从A的某个子节点开始的, 所以需要另外一个方法<code>doesBeginAtA(someNodeInA, B)</code>. </p>
<p>这个方法是给定两个子树, 判断B是不是包含在A中, 并且是从根节点就开始匹配的. </p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A: 4              B:  4</span><br><span class="line">  &#x2F; \                &#x2F; \</span><br><span class="line"> 8   9              8   9    </span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line">这样我们就可以说明B是在A的头部. 即 doesBeginAtA(A, B) &#x3D;&#x3D; true, 也就是节点A可以作为B的根节点</span><br></pre></td></tr></table></figure>

<p>然后对于A中的每个节点, 检查这个节点是不是可以作为B的根节点, 如果至少有1个节点可以作为B的根节点, 就返回true</p>
<p>即思路是这样的.  首先<code>isSubStructure</code> 方法先序地遍历A中所有的节点, 对于每一个节点, 检查这个节点可不可以作为B的根节点, 如果可以, 就返回true, 如果不行, 在检查当前节点的两个子节点是不是可以作为B的根节点.</p>
<p>复杂度O(m*n). 因为最坏情况下每个节点都要检查一遍可不可以作为B的根节点, 每一次检查最坏的情况就是检查n次, 其中n为B的节点数量</p>
<p><strong>写到这里想到这个题的算法可以用类似KMP算法的思想改进.</strong> </p>
<p>试想这么一个例子, 所有的节点都只有左孩子, 那么树就退化成单链表了, 我们把它想象成字符串. 树A含有树B, 就等价于字符串A含有字符串B, 这时候我们可以用KMP.</p>
<p>对于一般的树也一样, 例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A:  1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   1</span><br><span class="line">B:  2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   4</span><br><span class="line">我的想法是和kmp中的next数组一样, 通过一个数据结构来保存b的特征.</span><br><span class="line">在上面的A, B中, 首先A根节点和B根节点不匹配(1 !&#x3D; 2), 我们按照普通的递归算法应该比较A的两个孩子是不是和B的根节点匹配. </span><br><span class="line">但是A的两个孩子也都是1, 肯定是不匹配的. 如果能记录之前的匹配信息(1 !&#x3D; 2), 就可以免除这两次比较</span><br></pre></td></tr></table></figure>

<p><strong>但是这种优化方法感觉实现起来很难, kmp的next数组让我手写都不一定写出来, 别说更复杂的树结构了. 只是作为一个思路吧.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//这里我感觉应该是空树B肯定是包含在任意的树A中的. 不知道为什么leetcode-cn官网上认定的是返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span>)&#123;   <span class="comment">//空树不可能包含任意一个非空的树</span></span><br><span class="line">            <span class="keyword">return</span> B == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(doesBeginAtA(A, B))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doesBeginAtA</span><span class="params">(TreeNode A, TreeNode B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> B == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A.val == B.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> doesBeginAtA(A.left, B.left) &amp;&amp; doesBeginAtA(A.right, B.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>镜像输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>



<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>
<a id="more"></a>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>翻转root  &lt;=&gt; 翻转root.left和翻转root.right并且把翻转后的root.left放到root的右孩子上, 把翻转后的root.right放到root的左孩子上.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line">        root.right = mirrorTree(left);</span><br><span class="line">        root.left = mirrorTree(right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2028.%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>


<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>
<a id="more"></a>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>两棵子树是对称的 &lt;==&gt; 子树A的左孩子和子树B的右孩子对称， 并且子树A的右孩子和子树B的左孩子对称</p>
<p>而一棵树是对称的又等价于这棵树的两个子树是对称的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode t1, TreeNode t2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t1 != <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span> || t1 == <span class="keyword">null</span> &amp;&amp; t2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t1.val != t2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(t1.left, t2.right) &amp;&amp; isSymmetric(t1.right, t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2025.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<p>限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>这题和归并排序的思想一样, 直接模拟即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tail = head;</span><br><span class="line">        ListNode i = l1;</span><br><span class="line">        ListNode j = l2;</span><br><span class="line">        <span class="keyword">while</span>(i != <span class="keyword">null</span> || j != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="keyword">null</span> || (i != <span class="keyword">null</span> &amp;&amp; j != <span class="keyword">null</span> &amp;&amp; i.val &gt; j.val))&#123;</span><br><span class="line">                ListNode moveNode = j;</span><br><span class="line">                j = j.next;</span><br><span class="line">                tail.next = moveNode;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                tail.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode moveNode = i;</span><br><span class="line">                i = i.next;</span><br><span class="line">                tail.next = moveNode;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                tail.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<p><code>0 &lt;= matrix.length &lt;= 100</code><br><code>0 &lt;= matrix[i].length &lt;= 100</code></p>
<a id="more"></a>

<h2 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1. 模拟"></a>1. 模拟</h2><p>可以模拟顺时针的过程, 但是要新建一个矩阵储存哪些元素被遍历过了哪些没有.</p>
<p>规则是: </p>
<p>对于某个location{i,j}, 分别检查左边,右边, 上边,下边的元素是不是还没有遍历过并且没有超出边界.</p>
<p>  [ 1,  2,  <strong>3</strong>,  4],<br>  [ 5,  6,  7,  8],<br>  [ <strong>9</strong>, 10,11,<strong>12</strong>],<br>  [13,<strong>14</strong>,15,16]</p>
<ol>
<li>如果一个元素的右边和下边都没有遍历 接下来要先遍历右边 对于上图元素3,接下来要遍历4</li>
<li>如果一个元素的下边和左边都没有遍历 接下来要先遍历下边 对于上图元素12,接下来要遍历16</li>
<li>如果一个元素的左边和上边都没有遍历 接下来要先遍历左边 对于上图元素14, 接下来要遍历13</li>
<li>如果一个元素的上边和右边都没有遍历 接下来要先遍历上边 对于上图元素9, 接下来要遍历5</li>
<li>其他情况, 对应角上的元素, 例如4,16,13 只有一个方向没有遍历过. (4只能往下走, 16只能往左走, 13只能往上走) 那就遍历这个方向.</li>
</ol>
<p>这种方法虽然直观, 但是代码实现很复杂.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vc;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix.front().empty())</span><br><span class="line">            <span class="keyword">return</span> vc;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pr = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        vc.push_back(matrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        matrix[<span class="number">0</span>][<span class="number">0</span>] = INT_MIN;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(hasNextPair(matrix,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            getNextPair(matrix,pr);</span><br><span class="line">            vc.push_back(matrix[pr.first][pr.second]);</span><br><span class="line">            matrix[pr.first][pr.second] = INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNextPair</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isRightAvailable(m,pr) || isDownAvailable(m,pr) || isLeftAvailable(m,pr) || isUpAvailable(m,pr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNextPair</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isRightAvailable(m,pr) &amp;&amp; isDownAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isDownAvailable(m,pr) &amp;&amp; isLeftAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isLeftAvailable(m,pr) &amp;&amp; isUpAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isUpAvailable(m,pr) &amp;&amp; isRightAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isRightAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isDownAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            ++pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isLeftAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isUpAvailable(m,pr))</span><br><span class="line">        &#123;</span><br><span class="line">            --pr.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRightAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (j + <span class="number">1</span> &lt; m.front().<span class="built_in">size</span>()) &amp;&amp; (m[i][j+<span class="number">1</span>] != INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDownAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span> &lt; m.<span class="built_in">size</span>()) &amp;&amp; (m[i+<span class="number">1</span>][j] != INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeftAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (j - <span class="number">1</span>  &gt;= <span class="number">0</span>) &amp;&amp; (m[i][j<span class="number">-1</span>] != INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUpAvailable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; pr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = pr.first;</span><br><span class="line">        <span class="keyword">int</span> j = pr.second;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (m[i<span class="number">-1</span>][j] != INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-按圈遍历"><a href="#2-按圈遍历" class="headerlink" title="2. 按圈遍历"></a>2. 按圈遍历</h2><p>一圈一圈地遍历, 从最外圈到最内圈</p>
<p>先用4个变量标记位置信息, </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> beginRow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> endRow = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> beginColumn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> endColumn = n - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这4个变量可以唯一确定每个圈地位置.</p>
<p>遍历的顺序就是先遍历上面的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = beginColumn; j &lt;= endColumn; ++j)&#123;</span><br><span class="line">    ans[k++] = matrix[beginRow][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再遍历右边的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = beginRow + <span class="number">1</span>; i &lt;= endRow; ++i)&#123;</span><br><span class="line">    ans[k++] = matrix[i][endColumn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再遍历下边的(注意边界条件, 如果当前的圈只有一行, 即<code>beginRow == endRow</code>, 就不要遍历了, 要不然就相当于这一行遍历了2遍)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(beginRow &lt; endRow)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = endColumn - <span class="number">1</span>; j &gt;= beginColumn; --j)&#123;</span><br><span class="line">        ans[k++] = matrix[endRow][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再遍历左边的(注意边界条件, 如果当前的圈只有一列, 即<code>beginColumn == endColumn</code>, 就不要遍历了, 要不然就相当于这一列遍历了2遍)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(beginColumn &lt; endColumn)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = endRow - <span class="number">1</span>; i &gt; beginRow; --i)&#123;</span><br><span class="line">        ans[k++] = matrix[i][beginColumn];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时还要注意四个角的元素, 因为这些元素在两个边的相交处, 所以要小心地处理, 保证只被遍历一次</p>
<p>最后递增<code>beginRow, beginColumn</code>, 递减<code>endRow, endColumn</code>, 直到不符合条件<code>beginRow &lt;= endRow &amp;&amp; beginColumn &lt;= endColumn</code>退出while</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>] == <span class="keyword">null</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> size = m * n;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> beginRow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endRow = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> beginColumn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endColumn = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(beginRow &lt;= endRow &amp;&amp; beginColumn &lt;= endColumn)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = beginColumn; j &lt;= endColumn; ++j)&#123;</span><br><span class="line">                ans[k++] = matrix[beginRow][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = beginRow + <span class="number">1</span>; i &lt;= endRow; ++i)&#123;</span><br><span class="line">                ans[k++] = matrix[i][endColumn];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(beginRow &lt; endRow)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = endColumn - <span class="number">1</span>; j &gt;= beginColumn; --j)&#123;</span><br><span class="line">                    ans[k++] = matrix[endRow][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(beginColumn &lt; endColumn)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = endRow - <span class="number">1</span>; i &gt; beginRow; --i)&#123;</span><br><span class="line">                    ans[k++] = matrix[i][beginColumn];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++beginRow;</span><br><span class="line">            --endRow;</span><br><span class="line">            ++beginColumn;</span><br><span class="line">            --endColumn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2031.%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; pushed.length &#x3D;&#x3D; popped.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; pushed[i], popped[i] &lt; 1000</span><br><span class="line">pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure>



<a id="more"></a>

<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>这题我一开始没想到模拟的方法, 想用动态规划做, 通过前m个pushed是否可以弹出为前n个popped来做. 后来怎么想都找不到解决办法. </p>
<p>后来想不下去了, 看了剑指offer上面的答案, 才发现模拟一个stack就能做到……<strong>这都没想到我是🐖么</strong></p>
<p>首先定义两个指针i和j, i表示当前push到哪里了, j表示pop到哪里了</p>
<p>当j != length(popped)时, 我们检查栈顶元素是不是popped[j]</p>
<ul>
<li><p>如果是, 就弹出这个元素, j++, 执行下一轮</p>
</li>
<li><p>如果不是, 或者栈为空, 就要一直按照顺序push, 直到栈顶等于popped[j]. push的过程中如果pushed中的元素用完了, 就返回false</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed == <span class="keyword">null</span> || popped == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j != popped.length)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stack.isEmpty() || stack.peek() != popped[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == pushed.length)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(pushed[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2032%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<p><code>[3,9,20,15,7]</code></p>
<p>提示：</p>
<p><code>节点总数 &lt;= 1000</code></p>
<a id="more"></a>



<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>直接BFS按层遍历即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            TreeNode curr = q.poll();</span><br><span class="line">            ans.add(curr.val);</span><br><span class="line">            <span class="keyword">if</span>(curr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                q.offer(curr.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                q.offer(curr.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Stream&lt;Integer&gt; integerStream = ans.stream();</span><br><span class="line">        IntStream intStream = integerStream.mapToInt(x -&gt; x);</span><br><span class="line">        <span class="keyword">int</span>[] answer = intStream.toArray();</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p><code>各函数的调用总次数不超过 20000 次</code></p>
<a id="more"></a>



<h2 id="1-辅助栈"><a href="#1-辅助栈" class="headerlink" title="1. 辅助栈"></a>1. 辅助栈</h2><p>使用额外的空间, 这样就变得很简单了. </p>
<p>辅助栈存储当前栈里的所有元素的最小值.</p>
<p>例如, 当push(-2)的时候, 由于栈和辅助栈都为空, 所以直接push进去即可<code>stk = [-2], stkAux = [-2]</code></p>
<p>当push(0)的时候, 由于当前栈中所有元素的最小值为<code>stkAux.top() == -2 &lt; 0</code>, 所以stkAux仍然push进去-2. <code>stk = [-2,0], stkAux = [-2,-2]</code></p>
<p>当push(-3)的时候, 由于当前栈中所有元素的最小值为<code>stkAux.top() == -2 &gt; -3</code>, 所以stkAux要push进去-3, 表示stk中最小的元素现在变为了-3. <code>stk = [-2,0,-3], stkAux = [-2,-2,-3]</code></p>
<p>pop的时候直接pop掉stk和stkAux即可</p>
<p>top直接取stk的top</p>
<p>min直接取stkAux的top</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stk = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; stkAux = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stk.push(x);</span><br><span class="line">        <span class="keyword">int</span> min = (stkAux.isEmpty() || stkAux.peek() &gt; x) ? x : stkAux.peek();</span><br><span class="line">        stkAux.push(min);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.pop();</span><br><span class="line">        stkAux.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.util.NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.util.NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stkAux.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2-O-1-额外空间"><a href="#2-O-1-额外空间" class="headerlink" title="2. O(1)额外空间"></a>2. O(1)额外空间</h2><p>只是用一个int类型来保存当前栈中的最小值</p>
<p>这次要改变一下思路, stack不储存各个元素了, 而是存储各个元素与min的差值.</p>
<p>参考自<a href="https://zhuanlan.zhihu.com/p/49854919">https://zhuanlan.zhihu.com/p/49854919</a>, 具体如下: </p>
<ol>
<li>第一次push的时候，把该元素作为最小元素min。</li>
<li>在后面的push操作中，首先判断当前元素<code>num</code>是否小于<code>min</code>,如果不小于<code>min</code>，就向栈中存入元素值<code>data = num-min</code>(这个值肯定大于0，因为num大于min)；如果num小于min，也向栈中存入<code>data = num-min</code>(<code>data</code>小于0)，同时记得更新<code>min</code>值。</li>
<li>pop的时候，首先判断栈顶的元素data是否大于0，如果大于0，则pop的值应该是<code>num=data +min</code>（因为存的时候是<code>data = num-min</code>);如果小于0，则pop的时候应该是<code>min</code>，同时要更新min，<code>min = min- data</code>。</li>
<li>同时get_min时直接返回min的值就是整个栈元素中的最小值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Long&gt; stk = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">long</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.isEmpty())&#123;</span><br><span class="line">            min = x;</span><br><span class="line">            stk.push((<span class="keyword">long</span>) <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= min)&#123;</span><br><span class="line">                stk.push(x - min);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stk.push(x - min);</span><br><span class="line">                min = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> peekValue = stk.peek();</span><br><span class="line">        <span class="keyword">if</span>(peekValue &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            min = min - peekValue;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.peek() &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> stk.peek() + min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</url>
    <content><![CDATA[<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p><code>节点总数 &lt;= 1000</code></p>
<a id="more"></a>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>这次要新建一个变量<code>doesPrintReversed</code>了, 表示是否倒着打印. </p>
<p>然后每一层的list我们都使用LinkedList. 因为LinkedList可以头插也可以尾插.</p>
<p>当需要倒着打印时, 就头插这一层的每个元素, 反之尾插</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> doesPrintReversed = <span class="keyword">false</span>;</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            LinkedList&lt;Integer&gt; layerList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">            <span class="keyword">while</span>(size-- != <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode curr = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(doesPrintReversed)&#123;</span><br><span class="line">                    layerList.addFirst(curr.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    layerList.addLast(curr.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            doesPrintReversed = !doesPrintReversed;</span><br><span class="line">            ans.add(layerList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2032%20-%20II.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/</url>
    <content><![CDATA[<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p><code>节点总数 &lt;= 1000</code></p>
<a id="more"></a>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>和上一题差不多, 就是要用size()方法判断一下每层有多少个元素, 相同层的元素放到同一个list中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            List&lt;Integer&gt; layerList = <span class="keyword">new</span> ArrayList(size);</span><br><span class="line">            <span class="keyword">while</span>(size-- != <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode curr = q.poll();</span><br><span class="line">                layerList.add(curr.val);</span><br><span class="line">                <span class="keyword">if</span>(curr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(layerList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-10000 &lt;&#x3D; Node.val &lt;&#x3D; 10000</span><br><span class="line">Node.random 为空（null）或指向链表中的节点。</span><br><span class="line">节点数目不超过 1000 。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="利用链表作为映射"><a href="#利用链表作为映射" class="headerlink" title="利用链表作为映射"></a>利用链表作为映射</h2><p>这方法太巧妙了(日常感叹答案的巧妙哈哈哈). </p>
<p>对于原链表<code>a-&gt;b-&gt;c</code>, 我们仍然需要原链表某一个节点到对应链表的节点的映射.</p>
<p>这时, 把新链表的那个节点都插入到原链表对应节点的后面, 变成<code>a-&gt;a&#39;-&gt;b-&gt;b&#39;-&gt;c-&gt;c&#39;</code></p>
<p>首先要重新赋值新链表的random指针, </p>
<blockquote>
<p>如果原链表的random指针为<code>a.ramdom == c</code>, 那么根据我们的映射, 就能得到<code>a.next.random == c.next</code>!</p>
</blockquote>
<p>然后再将两条链表分离出来即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Node i = head; i != <span class="keyword">null</span>; i = i.next.next)&#123;</span><br><span class="line">            Node copyI = <span class="keyword">new</span> Node(i.val);</span><br><span class="line">            Node tmp = i.next;</span><br><span class="line">            i.next = copyI;</span><br><span class="line">            copyI.next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Node i = head; i != <span class="keyword">null</span>; i = i.next.next)&#123;</span><br><span class="line">            Node copyI = i.next;</span><br><span class="line">            Node j = i.random;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="keyword">null</span>)&#123;</span><br><span class="line">                copyI.random = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                Node copyJ = j.next;</span><br><span class="line">                copyI.random = copyJ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node cloneListHead = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">        Node cloneListTail = cloneListHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Node i = head; i != <span class="keyword">null</span>; i = i.next)&#123;</span><br><span class="line">            Node copyI = i.next;</span><br><span class="line">            i.next = i.next.next;</span><br><span class="line">            cloneListTail.next = copyI;</span><br><span class="line">            cloneListTail = cloneListTail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cloneListHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>快手大数据开发实习生一面面经</title>
    <url>/2021/03/30/%E9%9D%A2%E7%BB%8F/%E5%BF%AB%E6%89%8B%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="面试描述"><a href="#面试描述" class="headerlink" title="面试描述"></a>面试描述</h2><p>这次还是挺悬的, 幸亏编程题想出来了, 想不出来就gg了</p>
<ol>
<li>自我介绍</li>
<li>问了实习中做的工作内容, 实习里面spark怎么用什么的</li>
<li>spark了解的多吗, 讲一讲spark执行任务的流程</li>
<li>从哪里可以看出spark executor里面任务的执行情况?</li>
<li>又问到DAG图执行的过程, 这里我没太懂面试官的意思, 心想DAG图还有什么执行过程? 然后就回答从textFile()方法或者persist()开始. 后来听面试官的解答才知道问的不是这个, 问的知识点是RDD的<strong>惰性执行操作</strong>. 从最后一个rdd开始求出需要什么父rdd, 然后依次向前执行, 不action不执行.</li>
<li>实习里面kafka怎么用的?</li>
<li>kafka实现高可用的方式?(分区机制, leader和follower,ack参数)</li>
<li>kafka选举?(kafka控制器, leader epoch)</li>
<li>Java线程池(7个参数, 提交一个任务会经过怎样的流程)</li>
<li>JVM垃圾回收算法. (说了三种, 和CMS收集器). 又让讲讲G1收集器</li>
</ol>
<a id="more"></a>

<p>编程题问的是<strong>复原ip地址</strong>. 也是很经典的一道题了. leetcode 93</p>
<p>但这道题很久之前做过的, 有点忘了. 幸亏面试的时候想起来了, 不然又gg了.</p>
<p>需要的边界条件还是比较多的. 要考虑每一组ip是不是0开头, 是不是大于255, 遍历完之后ip段数是不是小于4或大于4, 这些情况都是需要剪枝排除掉的. 我写的时候忘考虑<strong>ip段数是不是小于4</strong>这个条件了. 还好写完之后只让讲思路, 要不然现场写bug太尴尬了.</p>
<p>最后问面试官评价, 面试官说基础掌握的还可以, 但是不深入, 源码看的少(事实上我之前根本没看过spark源码). 以后还是要多学源码多深入吧.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;List&lt;String&gt;&gt; string2ips(String s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        dfs(ans, curr, index, s);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; curr, <span class="keyword">int</span> index, String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.length() &amp;&amp; curr.size() == <span class="number">4</span>)&#123;</span><br><span class="line">            ans.append(curr);          <span class="comment">// 这里应该是 ans.append(new ArrayList&lt;String&gt;(curr));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> ch = s.charAt(index);</span><br><span class="line">        String last = curr.get(curr.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            String last_new = last + ch;</span><br><span class="line">            <span class="keyword">if</span>(Integer.valueOf(last) &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                curr.set(curr.size()-<span class="number">1</span>, last_new);</span><br><span class="line">                dfs(ans, curr, index + <span class="number">1</span>, s);</span><br><span class="line">                curr.set(curr.size()-<span class="number">1</span>, last);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last = last + ch;         <span class="comment">// 这里应该是 String last_new = last + ch;</span></span><br><span class="line">            <span class="keyword">if</span>(Integer.valueOf(last) &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                curr.set(curr.size()-<span class="number">1</span>, last_new);</span><br><span class="line">                dfs(ans, curr, index + <span class="number">1</span>, s);</span><br><span class="line">                curr.set(curr.size()-<span class="number">1</span>, last);</span><br><span class="line">            &#125;</span><br><span class="line">            curr.add(String.valueOf(ch));</span><br><span class="line">            dfs(ans, curr, index + <span class="number">1</span>, s);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E5%89%91%E6%8C%87Offer/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p><code>节点总数 &lt;= 10000</code></p>
<a id="more"></a>

<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>这题按照一般的套路还不行, 我一开始想用root == null作为终止的条件,但是碰见那种只有一个节点的树就失灵了</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     1</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   null</span><br><span class="line">  &#x2F; \</span><br><span class="line">null null     </span><br></pre></td></tr></table></figure>

<p>如果是root == null这一个终止条件, 那么这就有3条路, <code>1 -&gt; null,1 -&gt; 2 -&gt; leftNull, 1-&gt;2-&gt;RightNull </code></p>
<p>如果target = 1, 原来的树没有这样的路径, 但是这样会找出来一条路径<code>1-&gt;null</code></p>
<p>如果target = 3, 则会找出2条相同的路径来, <code>1-&gt;2</code>和<code>1-&gt;2</code></p>
<p>所以DFS终止条件是<code>root.left == null &amp;&amp; root.right == null</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> currSum = <span class="number">0</span>;</span><br><span class="line">        DFS(root, sum, ans, curr, currSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; curr, <span class="keyword">int</span> currSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            currSum += root.val;</span><br><span class="line">            <span class="keyword">if</span>(currSum == sum)&#123;</span><br><span class="line">                curr.add(root.val);</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            currSum += root.val;</span><br><span class="line">            curr.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                DFS(root.left, sum, ans, curr, currSum);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                DFS(root.right, sum, ans, curr, currSum);</span><br><span class="line">            currSum -= root.val;</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>京东数据开发实习生一面面经</title>
    <url>/2021/04/18/%E9%9D%A2%E7%BB%8F/%E4%BA%AC%E4%B8%9C%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<ol>
<li>自我介绍</li>
<li>介绍下计算广告的一些基本知识, (因为做的实习是关于计算广告的, 所以问了一些). 介绍下竞价广告的主要流程</li>
<li>讲一下数据仓库分层?</li>
<li>平常数据都会存放在哪里? hdfs上吗?</li>
<li>你在实习中都参与了哪些工作呢, 处理那些数据?</li>
<li>点击率和转化率的计算公式?</li>
<li>转换类型有哪些?</li>
<li>java 8种基本数据类型? 各占几个字节?</li>
<li>抽象类和接口区别?</li>
<li>抽象类和接口的作用有什么区别呢?</li>
<li>java可以多继承吗?</li>
<li>说一下java里的主要集合有哪些?</li>
<li>刚才你说到HashMap, 那你讲讲HashMap和Hashtable的区别吧</li>
<li>java创建线程的几种方式?</li>
<li>给你一张(学生id,考试成绩)的表和所有学生成绩的表, 求出所有学生的考试成绩. 没参加考试的用0代替</li>
</ol>
<a id="more"></a>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(学生id,考试成绩)          所有学生id</span><br><span class="line">0001, 100                0001</span><br><span class="line">0002, 100                0002</span><br><span class="line">0004, 90                 0003</span><br><span class="line">0005, 87                 0004</span><br><span class="line">                         0005</span><br><span class="line">返回这样的表</span><br><span class="line">0001, 100</span><br><span class="line">0002, 100</span><br><span class="line">0003, 0</span><br><span class="line">0004, 90</span><br><span class="line">0005, 87</span><br><span class="line"></span><br><span class="line">我的想法是先左连接出来一张临时表</span><br><span class="line">0001, 100</span><br><span class="line">0002, 100</span><br><span class="line">0003, null</span><br><span class="line">0004, 90</span><br><span class="line">0005, 87</span><br><span class="line">再遍历一遍把null转成0</span><br><span class="line">后来面试官说不需要这样, 一步操作就行. 这就涉及到我的知识盲区了.</span><br><span class="line">面完查了下资料才发现可以这样写</span><br><span class="line"><span class="keyword">SELECT</span> a.id, <span class="keyword">IFNULL</span>(b.score,<span class="number">0</span>) <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span> a.id=b.id;</span><br></pre></td></tr></table></figure>

<ol start="16">
<li>spark和hive挑一个简单讲下原理</li>
<li>平常学习的过程中碰到了哪些困难? 都是怎么解决的?</li>
</ol>
<p>整体来说面试比较简单, 感觉和快手, 美团啥的不是一个难度的. </p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>京东数据开发实习生二面面经</title>
    <url>/2021/04/21/%E9%9D%A2%E7%BB%8F/%E4%BA%AC%E4%B8%9C%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<ol>
<li>自我介绍</li>
<li>大数据开发的话喜欢是以平台为主还是以业务为主呢?</li>
<li>讲一下数据仓库分层? (又问到了这个问题, 我还是不会)</li>
<li>实习的过程中数据量有多大?</li>
<li>为什么中间数据要存到mysql中?</li>
<li>你做的这个报表分哪些维度?</li>
<li>底层的hive表是按照什么存储的呢?</li>
<li>只有10G的内存可用, 但是有200G的url数据, 怎么选出top10出现次数最多的url?</li>
<li>你简历上写的这些是学校里的课程吗? 还是自己学的?</li>
<li>自己学的过程中出现不明白的问题怎么解决的呢?</li>
</ol>
<hr>
<p>2021.05.09 更新</p>
<p>不知道为什么,竟然挂了, 可能是知道我有更好的offer了, 还是有更好的人选了? 感觉答的也可以啊</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>字节跳动大数据开发实习生一面凉经</title>
    <url>/2021/04/07/%E9%9D%A2%E7%BB%8F/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E9%9D%A2%E5%87%89%E7%BB%8F/</url>
    <content><![CDATA[<p>1  自我介绍</p>
<p>2  问实习能实习多久</p>
<p>3  mysql b+树和b树区别, 你刚才说了b+树的优势, b树就没有优势吗?</p>
<p>4  说说spark的架构和任务提交的流程.</p>
<p>5  TCP是怎样实现可靠性的? 除了超时重传还有哪些机制?</p>
<p>6  做个编程题吧</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一棵二叉搜索树（BST）、它的根结点 root 以及目标值 V，把树拆分两部分：其中一个子树中的结点的值不大于目标值V，另一个子树结点的值都大于V， 树中并不一定存在值为V的结点。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">拆分树的时候，树中的大部分结构要保留，如果原始树中p是c父结点，如果拆分后仍在同一个树中，p仍是c的父结点。</span><br></pre></td></tr></table></figure>

<p>写了好长时间没写出来, 又换了一个, 还是没做出来. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个链表的头节点 head，反复删去链表中总和值为 0 的连续节点组成的序列，直到不存在这样的序列为止。</span><br><span class="line"></span><br><span class="line">删除完毕后，请你返回最终结果链表的头节点。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line"> head &#x3D; [ 3, 4, 5, -5, 6]  输出： [3, 4, 6]</span><br><span class="line"></span><br><span class="line"> head &#x3D; [ 3, 4, 5, -5, -4] 输出 : [3]</span><br><span class="line"></span><br><span class="line"> head &#x3D; [ 1, 2, -3, 3, 1]  输出 : [3, 1]  ([1, 2, 1]也对）</span><br></pre></td></tr></table></figure>



<p>这次凉的很在情理之中, 两个编程题一个都没做出来. </p>
<p>字节的算法题水平是高, 我leetcode加上剑指一共刷了差不多300道题了, 其他公司的面试编程题基本上都是见过的, 唯独字节的这两个, 见都没见过, 再加上一紧张, 更加做不出来了. 还是要多练习多刷题</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>网易传媒大数据开发实习生二面面经</title>
    <url>/2020/12/14/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E6%98%93%E4%BC%A0%E5%AA%92%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="0"><a href="#0" class="headerlink" title="0."></a>0.</h2><p>先说这次凉的教训吧, </p>
<p><strong>简历上的东西一定要会, 不管是不是和面试的岗位相关!!!!!</strong></p>
<p><strong>简历上的东西一定要会, 不管是不是和面试的岗位相关!!!!!</strong></p>
<p><strong>简历上的东西一定要会, 不管是不是和面试的岗位相关!!!!!</strong></p>
<p>这次我面试的是大数据开发, 本来以为不会考机器学习算法, 结果大部分时间都在考算法…..</p>
<p>主要原因还是在我, 不应该在简历上写那些半懂不懂的东西, 我本来以为我在简历上的一个Python 神经网络的项目不会被问到, 结果整个面试过程中都在问. 问到了tensorflow <strong>(被问到这里的时候就已经有种不好的预感了)</strong>, 问到了LSTM和GRU模型, 我只会LSTM, 然后就讲了一下LSTM大概的结构, 然后又问我LSTM那几个参数是怎么算的. <strong>当时我都懵了, 心想大数据开发岗也要问这么深的吗</strong>, 因为这个项目是我2020.5月份做的, 所以肯定是记不太清具体的算法的. 后面问了个 所以就理所应当的凉掉了这次面试.</p>
<a id="more"></a>

<h2 id="面试描述"><a href="#面试描述" class="headerlink" title="面试描述"></a>面试描述</h2><p>首先还是自我介绍. </p>
<p>完了之后就让用Hadoop或Spark写一个wordcount. 我肯定是选spark, 两行就能写出来. </p>
<p>写出来之后又让用 Spark SQL 的Dataframe写, 这个就涉及到我知识的盲区了. 我当时认为面试官的意思是每一列都有很多个逗号隔开的单词, 但是SQL不应该是每一列表示的意义不一样吗, 应该是那种某一列表示的是单词, 其他列表示其他属性. 可能当时太紧张了, 没反应过来. 后来面完了才发现Spark SQL也有flatMap这个方法, 可以把多列不同的word统一成一列不同的word</p>
<p><strong>我给他说不会, 但是感觉用pandas能处理</strong>. 但是我说的用pandas处理不是用pandas里自带的处理, 而是只是用Dataframe储存这个文件, 然后2个for遍历一遍放到个哈希表里. </p>
<p>面试官又给我说, 让我用pandas来做吧, 我这时候都有打死自己的冲动了(让你之前信誓旦旦的说pandas能做!). 这时候我弱弱地问面试官能不能把数据挨个读取放到hashMap里面统计, 面试官说不行, 彻底浇灭了我最后一丝希望. 最后很尴尬, 面试官看我做不出来, 就换了个问题.</p>
<p>这个问题更要命, 问我聊不了解tensorflow. (<strong>如果说问我python的pandas我还能理解是因为我简历上写了才问的, 那问到tensorflow的时候我就觉得这个面试官应该是搞机器学习算法的, 彻底凉了</strong>) 我只能回答会用tensorflow构建基本的神经网络模型(这就是废话, 说白了就是只会调API, 底层狗屁不会)</p>
<p>然后又问的LSTM和GRU模型, 这个GRU我是真不会, 只知道是RNN的一种变形. LSTM会倒是会, 但那是6个月之前学的了. 所以我就说了下大概, 信息在网络中的传播方向, 记忆门和忘记门什么的. 本来以为说到这里就可以了, 没想到又继续让我讲算法的实现原理, 这个我就真的一点都不会了. 其实问到这里我就基本上知道自己肯定凉了.</p>
<p>问完这些关于神经网络的, 好像又问了一个topK问题. 这个面试当中很常见了, 每一个机器选出K个最大的, 然后集中到一台机器上再选择一遍即可.</p>
<p>最后问的算法题是旋转数组中的查找, 没有重复元素.</p>
<p>这个我是在leetcode上面做过的. 但是因为紧张和之前面试问的我心态快炸了, 导致发挥的也不是太好.</p>
<p>我用的是构造辅助函数的方法, 写了一个普通的二分查找函数, 当nums[begin] &lt; nums[end] 的时候就用普通的二分查找</p>
<p>后来面试官说不用普通的二分查找, 这个旋转数组也包含普通的情况</p>
<p>这时候我就有点慌, 分类讨论做的也不是很好, 并且把<strong>旋转数组中的查找</strong>和<strong>旋转数组中的最小值</strong>这两个题弄混了.</p>
<p>事实上, 在<strong>旋转数组中的查找</strong>里面, 需要分类讨论4次, 两次来判断mid 在左数组左半部分还是右半部分, 剩下两次判断target在mid的左边还是右边. 而在<strong>旋转数组最小值</strong>里面, 只需要分类讨论2次, 最小值在mid左还是最小值在mid右.</p>
<p>后来是根据面试官提醒才改对的. 整体来说算法题也表现得不怎么样.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次失败的主要原因就是简历上写的python数据分析的项目和神经网络不熟, 并且面试官非常懂机器学习. 之前准备的Hadoop, Spark, Kafka, Redis, MySQL都没有问, 反而大部分都在问神经网络算法, 使得自己非常被动.</p>
<p>还是那个教训, </p>
<p><strong>简历上的东西一定要会, 不管是不是和面试的岗位相关!!!!!</strong></p>
<p><strong>简历上的东西一定要会, 不管是不是和面试的岗位相关!!!!!</strong></p>
<p><strong>简历上的东西一定要会, 不管是不是和面试的岗位相关!!!!!</strong></p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>快手大数据开发实习生二面面经</title>
    <url>/2021/04/01/%E9%9D%A2%E7%BB%8F/%E5%BF%AB%E6%89%8B%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="面试描述"><a href="#面试描述" class="headerlink" title="面试描述"></a>面试描述</h2><ol>
<li><p>自我介绍</p>
</li>
<li><p>自我介绍完了之后什么都没问直接让写题. 大数相减：给定字符串表示的两个正整数，长度很长，求差值。 和面试官交流后得知字符串中只含0-9的字符, 并且没有前导0, 即没有”000102”这种情况.</p>
<p><code>String subtract(String a, String b)</code></p>
<p>结果一定要注意去除前导0, 比如<code>10000-9999</code>这样的, 要把前面的0去掉 我一开始就忘了, 在面试官提醒下才想起来</p>
</li>
</ol>
<a id="more"></a>

<ol start="3">
<li><p>写SQL.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sql：给定一个访问的hive表</span><br><span class="line">user_id, timestamp,... p_date     p_date是分区字段</span><br><span class="line">要求次日留存，结果给我user_id的集合</span><br><span class="line"><span class="comment">--- 留存是指的当天和昨天都访问了的用户, 实际上就是把今天用户的集合和昨天用户的集合取个交集就完事. 一开始还想着用窗口函数, 后来发现没这么麻烦.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> todayUser.user_id <span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> user_id, <span class="keyword">min</span>(p_date) <span class="keyword">from</span> hiveTable <span class="keyword">where</span> p_date = <span class="string">&quot;$&#123;today&#125;&quot;</span> </span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_id </span><br><span class="line">) <span class="keyword">as</span> todayUser <span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> user_id, <span class="keyword">min</span>(p_date) <span class="keyword">from</span> hiveTable <span class="keyword">where</span> p_date = <span class="string">&quot;$&#123;yesterday&#125;&quot;</span> </span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_id </span><br><span class="line">) <span class="keyword">as</span> yesterdayUser</span><br><span class="line"><span class="keyword">on</span> todayUser.user_id = yesterdayUser.user_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>讲一讲刚才的Hive SQL语句如果放到spark里面执行的过程是怎么样的? (<strong>注意, 从hive中取数的时候要根据p_date是分区字段来取, 而不是读取全部的hive数据再用filter()算子过滤</strong>)</p>
</li>
<li><p>Scala和Java比有什么不一样的地方?</p>
</li>
<li><p>介绍一下Scala的模式匹配</p>
</li>
<li><p>Spark惰性执行的优点有什么?</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">subtract</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || b == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(a) || <span class="string">&quot;&quot;</span>.equals(b))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.length() &gt; b.length())&#123;</span><br><span class="line">            ans = sub(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.length() &lt; b.length())&#123;</span><br><span class="line">            ans = sub(b,a);</span><br><span class="line">            isNegative = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.compareTo(b) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans = sub(a,b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.compareTo(b) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans = sub(b,a);</span><br><span class="line">                isNegative = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (isNegative) ? <span class="string">&quot;-&quot;</span> + ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">sub</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">        StringBuilder sba = <span class="keyword">new</span> StringBuilder(a).reverse();</span><br><span class="line">        StringBuilder sbb = <span class="keyword">new</span> StringBuilder(b).reverse();</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sba.length(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> ai = sba.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> bi = (i &lt; sbb.length()) ? sbb.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(ai &lt; bi + carry)&#123;</span><br><span class="line">                ai += <span class="number">10</span>;</span><br><span class="line">                ans.append(ai - bi - carry + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.append(ai - bi - carry + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        String ans1 = ans.reverse().toString();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans1.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans1.charAt(i) != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ans1.substring(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Scanner in = new Scanner(System.in);</span></span><br><span class="line">        <span class="comment">//int a = in.nextInt();</span></span><br><span class="line">        <span class="comment">//System.out.println(a);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>快手大数据开发实习生三面面经</title>
    <url>/2021/04/07/%E9%9D%A2%E7%BB%8F/%E5%BF%AB%E6%89%8B%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%89%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="面试描述"><a href="#面试描述" class="headerlink" title="面试描述"></a>面试描述</h2><ol>
<li><p>自我介绍. 自我介绍之前网络十分不好, 垃圾电脑. 劝大家面试前一定检查好网络状况. 否则很影响面试官心情.</p>
</li>
<li><p>自我介绍完了之后问<code>看你的专业是大数据分析, 为什么不去做模型做算法</code>?</p>
</li>
<li><p>说一下大数据的各个组件和功能吧</p>
</li>
<li><p>说一下mapreduce或spark分布式计算的原理</p>
</li>
<li><p>写个题吧, three sum, 不能重复, 升序排列. 这里一定要记住去掉重复的组合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; num[i] == num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &gt; i + <span class="number">1</span> &amp;&amp; num[left] == num[left - <span class="number">1</span>])&#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//面试的时候这个条件写错了, 怎么运行都不正确, 后来面试官急着开会, 让我改完发他邮箱, 才发现是这里的问题.</span></span><br><span class="line">应该为 <span class="keyword">while</span>(left &gt; i + <span class="number">1</span> &amp;&amp; left &lt; num.length - <span class="number">1</span> &amp;&amp; num[left] == num[left - <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(right &lt; num.length - <span class="number">1</span> &amp;&amp; num[right] == num[right + <span class="number">1</span>])&#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">应该为 <span class="keyword">while</span>(right &lt; num.length - <span class="number">1</span> &amp;&amp; right &gt; i + <span class="number">1</span> &amp;&amp; num[right] == num[right + <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; num[i] == num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> target = -num[i];</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = num.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">while</span>(left &gt; i + <span class="number">1</span> &amp;&amp; num[left] == num[left - <span class="number">1</span>])&#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(right &lt; num.length - <span class="number">1</span> &amp;&amp; num[right] == num[right + <span class="number">1</span>])&#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp = num[left] + num[right];</span><br><span class="line">                <span class="keyword">if</span>(tmp == target)&#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    curr.add(num[i]);</span><br><span class="line">                    curr.add(num[left]);</span><br><span class="line">                    curr.add(num[right]);</span><br><span class="line">                    System.out.println(curr);</span><br><span class="line">                    ans.add(curr);</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tmp &gt; target)&#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   总体上面试难度不大, 编程题也不难, 刚看到题的时候立马就想出来思路了. 但是在去重上耽误了太多的时间, 最后没有运行出来. 刚开始面试的时候网络也没调试好, 估计给面试官的体验也不太好, 希望能过吧. </p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>网易传媒大数据开发实习生一面面经</title>
    <url>/2020/12/11/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E6%98%93%E4%BC%A0%E5%AA%92%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="1-面试描述"><a href="#1-面试描述" class="headerlink" title="1. 面试描述"></a>1. 面试描述</h2><p><strong>这次是网易传媒大数据开发实习生的一面, 也是我人生中第一次面试, 很紧张, 自从接到面试通知之后就开始一直在准备.</strong></p>
<p>但是还是紧张. 巨紧张.</p>
<a id="more"></a>

<ol>
<li><p>首先还是自我介绍, 这里我就说了下我项目的一些实现,我简历上有两个项目,  第一个是Java + redis + mysql. 讲了下实现原理, 生产者消费者什么的, 然后第二个项目是关于Python数据分析的, 和这次面试关联不大, 所以我就一句话带过, 然后说了下项目里面的创新点, 就是对算法改进避免生成多个小文件, 而是生成大文件和索引文件.</p>
</li>
<li><p>自我介绍完了之后面试官顺便就问java多线程怎么实现的, 我回答的是线程池和阻塞队列, 然后强调了下是根据逻辑确定的线程池的那几个参数, 而不是用的默认的. </p>
</li>
<li><p>然后就开始问基础知识了, 先问的java里面的多态, 这个我就简单回答了一下. 父类引用指向子类类型, 执行过程中使用的子类的方法.因为实在不知道要怎么展开来说了</p>
</li>
<li><p>然后让讲一讲java里面常用的集合, 我是根据接口来讲的, 先讲到了分为2个接口Collection, Map, 然后再讲的Set, List, Queue这些.</p>
</li>
<li><p>下一个问题就是将Mapreduce流程. 这个我前几天才刚看过, 讲了很长时间. 从读取一个文件开始, 用InputFormat类分区分为InputSplit, 然后也讲到了RecordReader, 也讲了默认的是TextInputFormat. 下面就讲的是继承Mapper类重写map方法, 然后就讲shuffle, 这个shuffle向来是重点, 所以也没什么问题.分为map端的shuffle和reduce端的shuffle. <strong>然后我记得我好像忘了将reduce端shuffle之后处理逻辑了, 就是再次归并, 执行重写的reduce方法了. 可能是因为紧张忘了</strong>. 然后最后说到保存到文件用的类OutputFormat, 默认是TextOutputFormat保存为文本文件.  总体上感觉这个题答得还行</p>
</li>
<li><p>讲一下常用的spark算子. 这个感觉也没什么问题, 我是将算子分为transformation和action算子, 然后transformation算子又分为宽依赖和窄依赖算子. 三部分分别讲了下. </p>
</li>
<li><p>讲一下数据倾斜的解决方法. <strong>(我一听到数据倾斜的时候, 我心里就在想可能要gg了, 因为我之前知道大数据面试有数据倾斜这么个问题, 但是一直没有系统的准备过这个题.)</strong> 所以这道题完全就是自我发挥了. 我给了两种办法, 一种是重新分区, 换hash函数. 另外一种是从业务逻辑的角度, 增加几个特征, 使得很多key都相同的几率降低. </p>
</li>
<li><p>又问到了常用的排序算法, 我分为了两类. 交换排序和非交换排序. <strong>因为紧张我还给说错了(这里我听回放录音才听出来, 我把堆排序放到非交换排序里面了, 本来想说的是基数排序).</strong>  <strong>然后我又附加的说了外部排序. 当时的想法就是(前天刚复习的外部排序k路归并算法, 看胜者树败者树看了一晚上, 这里不说就亏了)</strong> </p>
</li>
<li><p>问了redis基本数据类型, 我说了8种, 5种基本的, 3种扩展的. </p>
</li>
<li><p>然后又问了熟不熟linux的操作, 问查看进程, 我回答的ps命令. 一般用的是ps -ef <strong>(其实ef具体代表什么我也不太清楚)</strong> 然后我讲了一下ps命令一般和grep命令通过管道连用, 查看指定的进程. 然后也回答了对于java程序, 还可以用jps. </p>
</li>
<li><p>算法题, 链表相加. <code>给出两个 非空 的链表用来表示两个非负的整数，并且它们的每个节点只能存储 一位 数字。输出这两个数相加的结果</code></p>
<p>本来这题真的不难, 在leetcode上我觉得难度连medium都不会达到. 但是最要命的是, <strong>面试官要让我用java自带的LinkedList&lt;&gt;来写这个函数.</strong> 这和之前在leetcode上的链表题完全不同!!! 只能用LinkedList就意味着没有next指针可以操作, 就只能用迭代器. 而我之前对迭代器并不熟悉. </p>
<p>然后想了一会, 想出来了, 然后又碰到了一个问题, 没法用指针, 就没法链表翻转, 当时就在赌, Collections里面有reverse这个方法. </p>
<p>其实是有的. 但我把函数用错了. Collections.reverse(a)是把a翻转返回void, 我当时以为返回一个翻转后的链表. 还好没运行.</p>
<p>面试的时候还想到了不反转链表, 因为LinkedList是双向链表, 可以从后向前遍历. 但是我忘了怎么返回最后一个元素的方法了.</p>
<p>等面试完, 才想到可以用listIterator来这样做. 但是已经没有办法了. </p>
</li>
</ol>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><p>个人觉得前面知识部分答的还可以, 就是数据倾斜没有回答好. </p>
<p><strong>需要改进的地方在算法题上, 因为之前都是在leetcode上刷题, 所以像LinkedList这种数据结构根本用不到, 这才导致了对没有指针的链表操作十分不熟悉, 导致了更加紧张, 写的时候丢三落四(例如这一次面试就忘了两个链表相加之后把最高位的0去掉, 也忘了用listIterator可以直接从后向前开始遍历, 但还好没忘首先判断链表是不是null, 要是这个忘了可能前面答的再好也没用了).</strong> </p>
<p>也提醒大家, 不要以为leetcode刷好就没事了. 常用的集合的API也一定要掌握起来.</p>
<p>贴上我漏洞百出的代码吧, 作为警醒希望下次不要犯这么低级的错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkedList&lt;Integer&gt; <span class="title">add</span><span class="params">(LinkedList&lt;Integer&gt; l1, LinkedList&lt;Integer&gt; l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; l1Reverse = Collections.reverse(l1);   <span class="comment">//Collections.reverse(a)是把a翻转返回void</span></span><br><span class="line">    LinkedList&lt;Integer&gt; l2Reverse = Collections.reverse(l2);   <span class="comment">//不是返回一个翻转后的新的链表</span></span><br><span class="line">    Iterator it1 = l1Reverse.iterator();           <span class="comment">// Iterator是泛型接口, 应该用Iterator&lt;Integer&gt;</span></span><br><span class="line">    Iterator it2 = l2Reverse.iterator();</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> remainder = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(it1.hasNext() || it2.hasNext())&#123;</span><br><span class="line">        <span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!it1.hasNext())&#123;</span><br><span class="line">            a1 = <span class="number">0</span>;</span><br><span class="line">            a2 = it2.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!it2.hasNext())&#123;</span><br><span class="line">            a1 = it1.next();</span><br><span class="line">            a2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a1 = it1.next();</span><br><span class="line">            a2 = it2.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = a1 + a2 + carry;</span><br><span class="line">        remainder = sum % <span class="number">10</span>;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        ans.add(remainder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">        ans.add(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.reverse(ans);       <span class="comment">//这里也忘了去除加法后的前导0了. 太紧张什么都忘了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>美团数据开发实习生一面面经</title>
    <url>/2021/04/09/%E9%9D%A2%E7%BB%8F/%E7%BE%8E%E5%9B%A2%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<ol>
<li>自我介绍</li>
<li>c++用的多吗? (后来才知道组里主要用c++开发的)</li>
<li>说说hive和mysql有什么区别? 应用场景有什么区别? hive和mysql在执行SQL的时候流程上有什么区别?</li>
<li>数据倾斜了解吗? 解释一下</li>
<li>hdfs上的有哪些压缩格式? 说一说他们的区别. (我只用过lzo压缩, 并且不知道原理)</li>
<li>hive会把所有的SQL都转化为mapreduce吗?  (这里感觉面试官觉得我hive掌握的一般, 就没接着问下去了)</li>
<li>说一下mysql 聚集索引和非聚集索引区别?</li>
<li>哪些情况下使用聚集索引效率高, 哪些情况下使用非聚集索引比较高?</li>
<li>讲一讲联合索引最左结合的规则吧</li>
<li>假如有一个联合索引(a, b), where条件里面写成<code>b = value_b and a = value_a</code>这样可以走联合索引吗? (之前没考虑过这个问题, 但是肯定能啊, 假如这点都做不到也太不智能了吧)</li>
<li>说说jdk1.7和jdk1.8里面的ConcurrentHashMap结构有什么区别?</li>
<li>说说ConcurrentHashMap里面的加锁类型有哪些?</li>
<li>讲一讲CAS的原理?</li>
<li>说一说使用线程池带来的优点? (线程复用, 方便管理)</li>
<li>你刚才说到了创建和销毁线程的开销很大, 那你来说说开销都花费在了什么地方? 这里我只回答了系统调用产生的开销和内存分配产生的开销.</li>
<li>你刚才说到了内存分配, 具体分配了哪些内存呢? (线程控制块, 栈内存)</li>
<li>你刚才说到了线程控制块, 这个数据结构存放在哪里呢? (我回答的是存储在进程的文本区里, 后面听录音才发现错了, 当时脑子真的抽风了, 明显应该是分配在OS的内核空间里的啊, 这个错误犯的太低级了!)</li>
<li>redis为什么采用单线程? (CPU不是瓶颈)</li>
<li>你刚才说到执行bgsave命令的时候redis不是单进程, 他创造出来的子进程也是用fork创建的吗? </li>
<li>说一下redis 分布式锁?  (set nx ex ,redlock)</li>
<li>讲讲c++多态实现原理?</li>
</ol>
<a id="more"></a>

<p>编程题, 链表之和.</p>
<p>很简单对吧, 我一开始也是这么想的. 但是最后没a出来. 😭</p>
<p>分三个操作, 前导0清除, 链表反转, 链表相加.</p>
<p>问题出在链表反转这里了. while判断条件退出的过于早了. 还是细节掌握的不行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node(<span class="keyword">int</span> val, Node next)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node()&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">0</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>(val,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node i = <span class="keyword">this</span>; i != <span class="keyword">null</span>; i = i.next)&#123;</span><br><span class="line">            ans += i.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverse</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Node dummyHead = <span class="keyword">new</span> Node(-<span class="number">1</span>, head);</span><br><span class="line">        Node p1 = dummyHead.next;</span><br><span class="line">        Node p2 = dummyHead.next.next;</span><br><span class="line">        <span class="keyword">while</span>(p2.next != <span class="keyword">null</span>)&#123;       <span class="comment">// 应该是 p2 != null</span></span><br><span class="line">            Node tmp = p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        Node newTail = dummyHead.next;</span><br><span class="line">        Node newHead = p2;            <span class="comment">// 应该是 Node newHead = p1</span></span><br><span class="line">        dummyHead.next = newHead;</span><br><span class="line">        newTail.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">removeLeadingZero</span><span class="params">(Node a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Node i = a; i != <span class="keyword">null</span>; i = i.next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i.val != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">add</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || b == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        a = removeLeadingZero(a);</span><br><span class="line">        b = removeLeadingZero(b);</span><br><span class="line">        Node reverse_a = reverse(a);</span><br><span class="line">        Node reverse_b = reverse(b);</span><br><span class="line">        Node ai = reverse_a;</span><br><span class="line">        Node bi = reverse_b;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        Node resultList = <span class="keyword">new</span> Node(-<span class="number">1</span>,<span class="keyword">null</span>);</span><br><span class="line">        Node resultListTail = resultList;</span><br><span class="line">        <span class="keyword">while</span>(ai != <span class="keyword">null</span> || bi != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> value_a = (ai == <span class="keyword">null</span>) ? <span class="number">0</span> : ai.val;</span><br><span class="line">            <span class="keyword">int</span> value_b = (bi == <span class="keyword">null</span>) ? <span class="number">0</span> : bi.val;</span><br><span class="line">            <span class="keyword">int</span> tmp = (value_a + value_b + carry);</span><br><span class="line">            <span class="keyword">int</span> result = tmp % <span class="number">10</span>;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            resultListTail.next = <span class="keyword">new</span> Node(result, <span class="keyword">null</span>);</span><br><span class="line">            resultListTail = resultListTail.next;</span><br><span class="line">            ai = (ai == <span class="keyword">null</span>) ? <span class="keyword">null</span> : ai.next;</span><br><span class="line">            bi = (bi == <span class="keyword">null</span>) ? <span class="keyword">null</span> : bi.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            resultListTail.next = <span class="keyword">new</span> Node(carry, <span class="keyword">null</span>);</span><br><span class="line">            resultListTail = resultListTail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> removeLeadingZero(reverse(resultList.next));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Node a = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        Node aa = <span class="keyword">new</span> Node(<span class="number">3</span>,a);</span><br><span class="line">        Node aaa = <span class="keyword">new</span> Node(<span class="number">2</span>,aa);</span><br><span class="line">        Node aaaa = <span class="keyword">new</span> Node(<span class="number">1</span>, aaa);</span><br><span class="line">        Node list_a = <span class="keyword">new</span> Node(<span class="number">0</span>,aaaa); <span class="comment">// 01234</span></span><br><span class="line">        </span><br><span class="line">        Node b = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        Node bb = <span class="keyword">new</span> Node(<span class="number">8</span>,b);</span><br><span class="line">        Node bbb = <span class="keyword">new</span> Node(<span class="number">7</span>,bb);</span><br><span class="line">        Node list_b = <span class="keyword">new</span> Node(<span class="number">0</span>,bbb);   <span class="comment">// 0789</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        System.out.println(reverse(removeLeadingZero(list_b)));</span><br><span class="line">        System.out.println(add(list_a, list_b));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>网易有道大数据开发实习生一面面经</title>
    <url>/2020/12/17/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E6%98%93%E6%9C%89%E9%81%93%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="1-面试描述"><a href="#1-面试描述" class="headerlink" title="1. 面试描述"></a>1. 面试描述</h2><p>这是我人生的第三次面试. 投的这两家网易的大数据开发实习岗都接到面试通知了, 但是没想到爱奇艺竟然在简历关挂了, 给我的理由是人已经招满了. 不知道是真的招满了还是简历关就被刷了.</p>
<a id="more"></a>

<p>首先面试还是自我介绍, 和前面的面试不同, 这个面试官问项目问的很细, 问了项目的功能, 架构, </p>
<p>还有就是相比较其他的现成的股票分析网站有什么优势.</p>
<p>然后问到了怎么解决mysql中数据量非常大之后的性能下降问题, 答案是建索引和分库分表**(这里幸亏前几天吃麻辣香锅的时候等位无聊看的mysql分表的知识了, 要不然就gg了)**</p>
<p>然后问到数据量这么大有没有考虑用HDFS, Hive来进行存储和查询, 回答肯定是没有的. 因为我自己就一台电脑, 用了也等于没用.</p>
<p>又反问到学校实验室没有提供资源来搭建集群? 回答就是需要导师的经费, 项目不是导师的, 没让买</p>
<p>最后问的是项目中碰到的困难 1. WSL装MySQL   2. http连接池   3. log4j </p>
<p>然后问到爬虫爬这么快会不会被限制, 我说明了robots协议里面确实没有限制, 然后又提到b站的爬虫是有限制的, 爬取次数快就会被封, 要使用ip池. </p>
<p>然后又被问到为什么不使用八爪鱼这样的现成的爬虫应用, 而是自己定义一个. 回答是可以八爪鱼的优点是可以爬取反爬虫机制比较高的网站, 我爬的这个不需要. 并且自己写爬虫根据自己的需求来自定义, 灵活度高, (其实八爪鱼我也没用过, )</p>
<p>接下来就说要问基础知识了, 第一个问的是数组和链表的区别, 和应用场景(我心想这也太基础了吧, 大一大二的学生都能答上来). 我的回答是数组用于一般的list, 因为数组可以随机访问, 比链表快, 并且数组经过ArrayList这样的动态扩容类修饰之后也解决了不能扩容的问题了. 并且扩容比LinkedList更快(因为ArrayList只有在满了的时候才会new新的数组, LinkedList每一次add都会new新的节点, 频繁的调用new与内核打交道非常耗费时间), 也提到了数组可以利用缓存达到遍历读取更快的效果.</p>
<p>应用场景就回答的大部分情况用ArrayList. (因为我觉得LiknedList在插入和删除方面的优势真的体现不出来, 你插入一个元素总得定位到一个位置吧, 定位的这个过程就O(n)了, 插入是O(1)有什么用? 删除的时候总得先找到要删除哪个元素吧, 这个过程也是O(n). ), 需要用到双端队列的时候采用LinkedList, 来实现Queue或Stack.</p>
<p>然后就又是经典的topK问题了, 1亿个数选前k个最大的. 我问的是这些数是不是存在同一台机器上的, 回答是存在同一台机器上, 然后又问内存能不能把这些数全读进来, 面试官让我两种情况都讨论一下, 那就很简单了, 不能全读到内存中用堆存储前k个最大的, 扫描一遍即可. 复杂度O(n*logk). 能读到内存中就用快速排序的思想, 复杂度O(n)</p>
<p>然后又问MySQL索引, 我就只说了InnoDB的索引, 聚簇索引和非聚簇索引. 然后说了下索引树叶子节点和MyISAM的区别, 非聚簇索引的回表查询, B树和B+树的区别…</p>
<p>然后让写了几个SQL, </p>
<p>第一个问题就是有个表, 列中是uid, date, level, 表示哪个用户在什么时间通过了哪一个关卡. 让求2020.11月每一个用户, 每天通过的关卡数量.  这个简单, 我感觉主要就是考察group by和聚合函数吧. 没什么难的. </p>
<p>但是尴尬的是, 面试官没说这个表的名字是什么, 我写的时候也忘了写<code>from</code>子句了. 还好面试官提醒我让我检查检查. </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uid date level</span></span><br><span class="line"><span class="comment"># abcd  date  5</span></span><br><span class="line"><span class="comment"># 2020.11 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> uid, <span class="string">`date`</span>, <span class="keyword">COUNT</span>(<span class="string">`level`</span>)</span><br><span class="line"><span class="keyword">from</span> table1</span><br><span class="line"><span class="keyword">where</span> <span class="string">`date`</span> &gt;= <span class="string">&quot;2020-11-01&quot;</span> <span class="keyword">and</span> <span class="string">`date`</span> &lt; <span class="string">&quot;2020-12-01&quot;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid, <span class="string">`date`</span>;</span><br></pre></td></tr></table></figure>

<p>第二个就是排序, 给出id和分数, 让输出排名. 这个题有窗口函数就很简单, 但是写完了之后, 面试官告诉我窗口函数里面的order by就已经对数据进行排序了, 外面就不用再order by一次了. 这个我是不知道的. </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uid score</span></span><br><span class="line"><span class="keyword">select</span> uid, score, <span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="string">`rank`</span></span><br><span class="line"><span class="keyword">from</span> table2</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p>下一个问题就是介绍三个窗口函数, <code>rank()    row_number()    dense_rank()</code>的区别了, 这个不难, 然后就说让我不用窗口函数实现排序. <strong>这个假如我之前没学过绝对写不出来, 所以这里要推荐一波SQL50题[<a href="https://www.jianshu.com/p/476b52ee4f1b">50道SQL练习题及答案与详细分析 - 简书 (jianshu.com)</a>], 学完这些基本的SQL都不用怕了. 当然里面也包括不使用窗口函数完成排序.</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> uid, t1.score, (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t1 <span class="keyword">as</span> tmpT1 <span class="keyword">where</span> t1.score &lt; tmpT1.score) + <span class="number">1</span> <span class="keyword">as</span> <span class="string">`rank`</span></span><br><span class="line"><span class="keyword">from</span> t1</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t1.score <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">      rank()  row_number()    dense_rank()</span><br><span class="line">100   1        1              1</span><br><span class="line">90    2        2              2</span><br><span class="line">90    2        3              2</span><br><span class="line">80    4        4              3</span><br></pre></td></tr></table></figure>



<p>然后最后问的是mapreduce流程, 这个在之前的面试中也问道过, 所以很轻易地答出来了, 答得也比较完整.</p>
<p>最后出人意料的是没问算法题. 可能SQL就已经算是算法题了? 但是这个难度和算法题不是一个难度的吧</p>
<h2 id="2-面试感想"><a href="#2-面试感想" class="headerlink" title="2. 面试感想"></a>2. 面试感想</h2><p>感觉这次的面试不太像我想要的岗位, 感觉更偏向数据仓库这方面, MySQL和SQL语法问的比较多, Java几乎没问, 项目问的时候也集中在MySQL这个点上(分表什么的). Java多线程没问, 集合没问. 算法题也没问. </p>
<p>我记得当时约面试的时候HR给我说大数据开发实习有2个方向, 一个是偏Java开发的, 一个是偏数据仓库的. 我还特意选择了偏Java的. 没想到问的还是这么偏数仓.</p>
<p>其实感觉数仓会比较无聊, 天天当curd boy, SQL boy. 所以应该会选择第一个我面试的大数据开发岗吧, 至少还能玩玩spark和flink</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>网易有道大数据开发实习生二面面经</title>
    <url>/2020/12/23/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E6%98%93%E6%9C%89%E9%81%93%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="面试介绍"><a href="#面试介绍" class="headerlink" title="面试介绍"></a>面试介绍</h2><p>应该是近期最后一场面试了. 面试官人很好, 就是约面试太慢了. 我12.09投的简历, 12.17才开始的一面, 12.22才开始的二面. 相比之下网易传媒就快很多, 12.09投的简历, 12.11一面, 12.14二面. 以至于我答应下来了offer这边的面试还没开始.</p>
<h2 id="面试内容"><a href="#面试内容" class="headerlink" title="面试内容"></a>面试内容</h2><p>首先还是按套路出牌, 自我介绍. 介绍完了之后面试官问大数据开发有很多领域, 对哪些感兴趣, 我回答的是偏业务的开发, 而不是数据仓库的开发和运维.</p>
<ul>
<li>问的第一个就是如何用mapreduce实现下面的问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假如有很大的数据, 比如4TB, 数据中每一行有多个列. 现在要求出对于指定的第i列, 求出所有行的第i列的数据之和</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>我一开始的解答就是把每一行的第i列的元素作为value, 给定一个常数1作为key, 进行reduce操作. 并且使用combiner. 我的理解是使用combiner就可以避免map端生成过多的key. 因为key只有1个, 所以在各个阶段进行combine之后传递给reducer的key就变得很少了. 因为在溢写的时候和归并排序的时候都会进行combiner. </p>
<p>面试官仍然问了把所有的数据集中在一个节点上会不会造成数据倾斜的问题, 我觉得除非是因为map任务太多, 要不然应该不会数据倾斜的. 不然根据默认的配置, 溢写文件大于3个就会在归并的时候再次进行combine操作. 所以每个map端最多生成3个文件传递给reducer.</p>
<p>然后还说了下spark中的解决方法就是用累加器.</p>
<ul>
<li>第二个问题, 对垃圾回收的理解.</li>
</ul>
<p>我当时听到垃圾回收这四个字, 心里就凉了. 因为我jvm还没学. (确实是我太不应该了, 既然给面试官说以后选java方向, 但是连jvm都不会也太说不过去了, 等这学期期末忙完就开始学jvm). 然后就说了些大概的, 不系统的知识吧, 因为之前学C++的时候学过智能指针, 知道引用计数的实现方式和优缺点. 所以就说了些引用计数, 对象头, 弱引用什么的. 可能说的有些地方也不太对. </p>
<ul>
<li>然后就又到了写SQL的时候了, 给定一个表log, 里面记录了用户id, 用户触发某个事件的id, 及触发这个事件的时间.</li>
</ul>
<p>要统计每一天中新用户的数量. (新用户就是指uid第一次出现, 之前的记录中uid没有出现过的用户)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  timestamp uid  eventid</span></span><br><span class="line"><span class="comment"># log</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> timeToDate(<span class="string">`date1`</span>) <span class="keyword">as</span> <span class="string">`date`</span>, <span class="keyword">count</span>(*) - <span class="keyword">count</span>(date2) <span class="keyword">as</span> newUserCount <span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> t1.<span class="string">`timestamp`</span> <span class="keyword">as</span> <span class="string">`date1`</span>, </span><br><span class="line">t2.<span class="string">`timestamp`</span> <span class="keyword">as</span> <span class="string">`date2`</span>, </span><br><span class="line">t1.uid <span class="keyword">as</span> <span class="string">`uid`</span> <span class="keyword">from</span> <span class="keyword">log</span> <span class="keyword">as</span> t1 <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">log</span> <span class="keyword">as</span> t2 <span class="keyword">on</span> t1.uid = t2.uid <span class="keyword">and</span> t1.<span class="string">`timestamp`</span> &gt; t2.<span class="string">`timestamp`</span>) <span class="keyword">as</span> tmpTable</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="string">`date`</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我的想法是左连接*<em>(其实这题我知道用窗口函数更简单, 但我忘了选择某个列的前一个记录对应的窗口函数名是什么了, 所以没敢说)**, 连接的条件就是左表的id等于右表的id, 并且左表的时间大于右表的时间. 这样, 如果左表中的某一列是该id第一个记录的话, 那么不存在某一条右表记录, 使得左表的时间大于右表的时间. 即右表的部分为NULL. 我们按天来统计NULL的个数就能发现当天新用户的数量了. 也解释了下count(</em>)是会统计NULL的行的数量, 而count(date2)不会, 所以相减就可以得到NULL行的个数了</p>
<p>然后面试官说这样的逻辑对, 但是有没有什么问题. 那肯定是性能有问题, 我说了一下连接操作, count操作, group by操作都需要遍历.非常耗时间. (然后还有的问题就说连接产生的临时表会非常大, 因为左表的一行可能被右表连接了好几次, 这点我面试的时候没意识到, 面完才想到). </p>
<p>又问解决的方法, 我给出了两种, 第一种就是再添一列, 记录相同id的上一行记录. 如果没有上一行记录, 就说明当前是一个新用户. 类似于链表指针. 第二种方法就是用窗口函数. 我也只是知道窗口函数能做这个问题, 至于怎么写就不会了, 也幸亏面试官没让我写.</p>
<p>然后接下来就没问什么专业性的问题了, 就是聊天了, 面试官介绍了大数据开发的几个方向吧, 然后问问我喜欢什么, 我也问了面试官组里主要是负责有道的什么部分. 感觉不太是我想要去的岗位. 而且已经接受了另外的offer了, 最后在微信上就婉拒了. 不得不说有道的面试都是这样的吗? 要面试官提前联系面试者, hr什么都不管?</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>美团数据开发实习生二面面经</title>
    <url>/2021/04/13/%E9%9D%A2%E7%BB%8F/%E7%BE%8E%E5%9B%A2%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>没自我介绍, 感觉这个面试官不太和蔼的样子, 非常严肃, 上来就直接问</p>
<p>volatile关键字讲一下</p>
<p>threadlocal讲一下,  里面的hashmap对应的key应该是线程对象而不是线程的id</p>
<p>说一下垃圾回收算法(标记算法和引用计数算法)</p>
<p>说一下引用计数算法, 这里一开始没明白面试官的意思, 后来才知道问的是三色标记算法.</p>
<p>说一下CMS收集器的四个过程.</p>
<p>说一下JVM锁膨胀的过程? 无锁, 偏向锁, 轻量级锁, 重量级锁</p>
<p>说一下java里面的四种引用, 分别有什么作用? 我只知道弱引用在WeakHashMap里有点用. </p>
<p>问了个jvm的题</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面这段代码，编译为字节码时，操作数栈的深度是多少，局部变量表中有几个变量</span><br><span class="line"></span><br><span class="line">public class CalcCirc &#123;</span><br><span class="line">public int doCalc() &#123;</span><br><span class="line">int a&#x3D;10;</span><br><span class="line"> int b&#x3D;20;</span><br><span class="line"> int c&#x3D;2;</span><br><span class="line"> return (a+b)*c;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">操作数栈深度很显然是2. 先算a+b, 然后再乘c. 假如是a+b*c那深度就是3了</span><br><span class="line"></span><br><span class="line">局部变量表应该是有4个变量的, 一定不能忘了非静态方法有this指针!!</span><br></pre></td></tr></table></figure>



<p>说一下进程之间的通信方式?</p>
<p>说一下linux中管道的原理, 可以双向吗?</p>
<p>了解linux的IO吗? 说一下(这里我主要说的是epoll)</p>
<p>linux共享内存怎么解决多进程同时写的问题?</p>
<p>编程题, 之前做过, 直接a出来了</p>
<p>最后竟然面试完了直接就完了, 也没问我有什么问题. 估计是凉了吧. 但是我感觉我答的还不错啊, 除了java4种引用不会之外其他的地方都差不多答上来了. 希望能过. 求 offer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">删除有序链表中重复出现的元素</span><br><span class="line">给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。</span><br><span class="line">例如：</span><br><span class="line">给出的链表为<span class="number">1</span>→<span class="number">2</span>→<span class="number">3</span>→<span class="number">3</span>→<span class="number">4</span>→<span class="number">4</span>→<span class="number">5</span>, 返回<span class="number">1</span>→<span class="number">2</span>→<span class="number">5.</span></span><br><span class="line">给出的链表为<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">2</span>→<span class="number">3</span>, 返回<span class="number">2</span>→<span class="number">3.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode begin_prev = dummyHead;</span><br><span class="line">        ListNode begin = begin_prev.next;</span><br><span class="line">        ListNode end = begin;</span><br><span class="line">        <span class="keyword">while</span>(begin != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(end != <span class="keyword">null</span> &amp;&amp; end.val == begin.val)&#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(begin.next == end)&#123;</span><br><span class="line">                begin_prev = begin;</span><br><span class="line">                begin = end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                begin_prev.next = end;</span><br><span class="line">                begin = end;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯运营开发实习生二面面经</title>
    <url>/2021/04/06/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AF%E8%BF%90%E8%90%A5%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<ol>
<li><p>自我介绍</p>
</li>
<li><p>简单问了下项目, 因为面试官也不是搞后端的, 没太深入的问.</p>
</li>
<li><p>问了下MySQL有哪些引擎, innodb和myisam有什么区别</p>
</li>
<li><p>熟悉linux吗? 实习里shell中一般用linux哪些命令</p>
</li>
<li><p>怎么查看服务器的负载情况? <code>top</code>, top命令的前3行包含什么信息?</p>
</li>
<li><p>怎么查找一个名为a.txt的文件在哪个位置? <code>find / -name &quot;a.txt&quot;</code></p>
</li>
<li><p>浏览器中输入<code>www.qq.com</code>会发生什么, 流程说一下</p>
</li>
<li><p>http返回值502错误码代表什么意思</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">然后又介绍了对方的组. 面试半小时就结束了, 出奇的快.</span><br><span class="line">总体感觉就是面试官会的我不会, 我擅长的面试官不擅长. java没问, 大数据没问, 编程题也没问.</span><br><span class="line">希望能过吧.</span><br><span class="line">本来以为运营开发是和数据开发一样的工作, 现在看起来很像运维开发.</span><br><span class="line">但是很想和进去体验一下啊, 容器化,微服务,k8s,听起来就很cool的样子😈😈.</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>美团数据开发实习生二面面经</title>
    <url>/2021/04/19/%E9%9D%A2%E7%BB%8F/%E7%BE%8E%E5%9B%A2%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%89%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>自我介绍? 项目和实习?</p>
<p>为什么要做这个项目, 动机是什么?</p>
<p>本科和硕士学过什么课程呢?</p>
<p>讲讲实习主要做了哪些工作, 负责什么?</p>
<p>你实习写的这个监控是高可用的吗? (就一台服务器哪来的高可用, 垃圾netease) </p>
<p>实习的时候有mentor吗, mentor主要负责什么?</p>
<p>学过编译原理吗? 讲一下源代码到可执行文件的一些过程?</p>
<p>讲一下编译原理里面的优化? (本地相关优化, 本地无关优化)</p>
<p>学过汇编语言吗? 讲一下函数调用的时候栈帧是怎么变化的? (这我之前看过, 看懂过, 但是很难, 而且很快就忘了)</p>
<p>函数参数压栈的时候是从左到右还是从右到左? (应该是从右到左, 我答错了呜呜呜)</p>
<a id="more"></a>

<p>面试官说换个话题吧, 问问操作系统(可能是之前答的太烂了, 问不下去了)</p>
<p>说说内存虚拟化, 内存分页? (上来就说错了, 内存页大小默认4k, 我记成16k了)</p>
<p>一个进程有4G空间, 这些空间都能随便用吗?</p>
<p>malloc新申请的内存会存放在页表中吗?</p>
<p>说说mysql几种事务隔离级别?</p>
<p>讲一下什么是幻读, MySQL中预防幻读的机制是什么?</p>
<p>讲一下mysql里面myisam和innodb的区别?</p>
<p>mysql中为什么myisam引擎要用b树?   (这我真不知道, 后来才知道myisam也是用b+树作为索引的. 还是大意了, 光注重innodb了, myisam最基本的知识都不会了)</p>
<p>总结一下, 还是基础知识不牢固, 好多之前学的没有经过复习都忘了. 函数压栈, 内存页大小, myisam引擎等. 还是要不断复习不断学习.</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯运营开发实习生一面面经</title>
    <url>/2021/04/03/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AF%E8%BF%90%E8%90%A5%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<ol>
<li>自我介绍</li>
<li>查找进程id <code>ps -ef | grep &quot;process_name&quot;</code></li>
<li>刚才的ps命令里参数<code>-e</code>和<code>-f</code>是什么意思</li>
<li>ps 命令里大写的 <code>-E</code>参数和<code>-e</code>有什么区别</li>
<li>查看端口号的命令?</li>
<li><code>netstat</code>命令用过吗? 做什么的. (用过, 但干什么的忘了)</li>
<li><code>lsof</code>命令?（我听都没听说过）</li>
<li>查看cpu,内存的命令? (top, free)</li>
<li>查看磁盘使用情况的命令?(<code>df</code>, 我一开始回答的<code>du</code>, 后来问du和df的区别的时候才指出我说反了) </li>
<li><code>du</code>和<code>df</code>区别?</li>
</ol>
<a id="more"></a>

<ol start="11">
<li><code>top</code>命令如何查看具体某一核的cpu使用情况? ( 不会 )</li>
<li>平常用哪些命令抓包? 我回答的是(<code>curl</code>和<code>nc</code>命令, 面试官说不是, 但还是让我解释这两个命令的区别)</li>
<li>抓包工具会吗? (tcpdump) (我只会用chrome浏览器inspect抓包, 面试官说这样的话tcp报文抓不到. 这不废话吗当然抓不到了, 我又不是网络工程师抓tcp包干啥)</li>
<li>面试官问git用过吗? 我回答用过, 写一个git语句吧, <code>把feature分支合并到master分支</code>. 不会. 平常实习的时候只用add commit push merge. (<strong>垃圾网易</strong>, 实习生连合并分支的权限都没有, 只能自己创建个分支自己玩)</li>
<li>git rebase 了解吗? (不了解)</li>
<li>git 查看commit id用什么命令(git log)</li>
<li>进程和线程区别?</li>
<li>讲一下上下文切换?</li>
<li>数据库用的多吗? 非关系型数据库用过吗?</li>
<li>讲一下mysql事务机制</li>
<li>写两个sql, 贼简单, 和之前的面试问的sql都不是同一级别的. select * from table order by column1; select column2 from table group by column2;  刚学sql的都会</li>
<li>http常用状态码？</li>
<li>301, 302有什么区别, 403代表什么意思, 502的<code>bad gateway</code>能解释下吗.  (都不会)</li>
<li>http报文格式说一下</li>
<li>http请求体中<code>content-type</code>和<code>data-format</code>两个参数什么意思    (也不会)</li>
<li>https 和 http有什么区别</li>
<li><code>curl -vvv https://qq.com</code> 这个过程中讲一下, 要建立几次TCP连接?</li>
<li>最后面试官问了个非常简单的面试问题, 估计是觉得问难的我也答不上来了吧. 说一下TCP三次握手四次挥手</li>
</ol>
<p>编程题是LFU的设计, 之前在leetcode上面做过LRU的, 这个比LRU复杂一点, 想了一会, 感觉就是LRU里面的链表节点再加上一个cnt变量表示访问的次数, 并且是降序排序的. 每一次就剔除掉链表最后一个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LFU缓存结构设计</span><br><span class="line">一个缓存结构需要实现如下功能。</span><br><span class="line">set(key, value)：将记录(key, value)插入该结构</span><br><span class="line">get(key)：返回key对应的value值</span><br><span class="line">但是缓存结构中最多放K条记录，如果新的第K+<span class="number">1</span>条记录要加入，就需要根据策略删掉一条记录，然后才能把新记录加入。这个策略为：在缓存结构的K条记录中，哪一个key从进入缓存结构的时刻开始，被调用set或者get的次数最少，就删掉这个key的记录；</span><br><span class="line">如果调用次数最少的key有多个，上次调用发生最早的key被删除</span><br><span class="line">    这就是LFU缓存替换算法。实现这个结构，K作为参数给出</span><br><span class="line">[要求]</span><br><span class="line">set和get方法的时间复杂度为O(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LFU</span> </span>&#123;</span><br><span class="line">    LFU(<span class="keyword">int</span> K)&#123;</span><br><span class="line">        maxSize = K;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">    Map&lt;Integer, ListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    ListNode listHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode listTail = listHead;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            ListNode node = map.get(key);</span><br><span class="line">            node.cnt++;</span><br><span class="line">            ListNode currNode = node;</span><br><span class="line">            ListNode prevNode = node.prev;</span><br><span class="line">            <span class="keyword">while</span>(prevNode != <span class="keyword">null</span> &amp;&amp; currNode.cnt &gt; prevNode.cnt)&#123;</span><br><span class="line">                <span class="comment">//swap curr and prev</span></span><br><span class="line">                swap(prevNode,currNode);</span><br><span class="line">                prevNode = currNode.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> currNode.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            ListNode node = map.get(key);</span><br><span class="line">            node.cnt++;</span><br><span class="line">            node.value = value;</span><br><span class="line">            ListNode currNode = node;</span><br><span class="line">            ListNode prevNode = node.prev;</span><br><span class="line">            <span class="keyword">while</span>(prevNode != <span class="keyword">null</span> &amp;&amp; currNode.cnt &gt; prevNode.cnt)&#123;</span><br><span class="line">                <span class="comment">//swap curr and prev</span></span><br><span class="line">                swap(prevNode,currNode);</span><br><span class="line">                prevNode = currNode.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> currNode.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(size == maxSize)&#123;</span><br><span class="line">                ListNode leastNode = listTail;</span><br><span class="line">                <span class="comment">//remove leastNode</span></span><br><span class="line">                map.remove(listTail.key);</span><br><span class="line">                listTail = leastNode.prev;</span><br><span class="line">                listTail.next = <span class="keyword">null</span>;</span><br><span class="line">                leastNode.prev = <span class="keyword">null</span>;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode newNode = <span class="keyword">new</span> ListNode(key,value);</span><br><span class="line">            map.set(key,newNode);</span><br><span class="line">            listTail.next = newNode;</span><br><span class="line">            newNode.prev = listTail;</span><br><span class="line">            listTail = newNode;</span><br><span class="line">            ++size;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ListNode, n1, ListNode n2)</span></span>&#123;</span><br><span class="line">        ListNode n1_prev = n1.prev;</span><br><span class="line">        ListNode n2_next = n2.next;</span><br><span class="line">        n1_prev.next = n2;</span><br><span class="line">        n2_next.prev = n1;</span><br><span class="line">        n2.next = n1;</span><br><span class="line">        n2.prev = n1_prev;</span><br><span class="line">        n1.next = n2_next;</span><br><span class="line">        n1.prev = n2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> cnt;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> ListNode next;</span><br><span class="line">        <span class="keyword">public</span> ListNode prev;</span><br><span class="line">        ListNode(<span class="keyword">int</span> value, <span class="keyword">int</span> key)&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode()&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯运营开发实习生三面面经</title>
    <url>/2021/04/11/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AF%E8%BF%90%E8%90%A5%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%89%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<ol>
<li><p>自我介绍</p>
</li>
<li><p>平常开发过程中使用什么语言?</p>
</li>
<li><p>为什么选择java作为自己的开发语言?</p>
</li>
<li><p>说说java和c++的区别?</p>
</li>
<li><p>你刚才提到了c++的智能指针, 说一说智能指针的作用?</p>
</li>
<li><p>平常都使用什么数据库呢?</p>
</li>
<li><p>为什么使用MySQL?</p>
</li>
<li><p>你刚才说到Maria DB是仿照的MySQL? 那么这样做会产生产权问题吗?</p>
</li>
<li><p>Maria DB和MySQL有什么不一样的地方呢?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">面试也是半小时就结束了,很快</span><br><span class="line">希望能过吧.</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E9%9D%A2%E7%BB%8F/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>首先面试官竟然先自我介绍起来了, 介绍了组内的业务和技术栈</p>
<p>随后问了些实习的问题</p>
<p>给你一整年的关键词的数据, 关键词可以被视作字符串, 一天大概50亿条. 存储在100台机器上, 求top100频率最高的字符串</p>
<p>(我的思路是每台机器先map成关键词到频率的字符串, 然后相同的关键词shuffle到同一台机器上, 再reduce. 最后每台机器上取top100, 汇总到一台机器上是1w个最后再取整体的top100)</p>
<p>面试官问, 假如有一些关键词要被视为同一个关键词呢? 比如”北京鲜花”和”鲜花北京”或”土豆”和”马铃薯”这样的算一个关键词, 这样该怎么计算呢?</p>
<p>你刚才讲的1w个里面取前top100, 那该怎么做呢? (优先队列)</p>
<p>那如果存在并列的情况呢? 比如  1,2,….,99, 100, 100, 100, 101 的top100就是<code>[1,2,....,99, 100, 100, 100]</code>这102个元素.(我一开始答得是排序, 但是很慢, 后来想出来了, 还是用优先队列, top100是100, 那么我记录下这个100, 再把数组中所有的100添加到top里面)</p>
<p>java一个进程不同线程的栈是共享的吗, 栈里面存储哪些数据?</p>
<p>编程题, </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15分钟自己实现优先队列的push和pop方法并且实现n个里面选前k个最大</span><br><span class="line">我感觉就是在为难我, 还说阿里的笔试我做的不好, 美名其曰考察我的代码能力， 我感觉就是人招满了, 找个借口拒绝我</span><br><span class="line">写的一般吧, 代码里还是有些问题的</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span></span>&#123;</span><br><span class="line">      Pair[] values = <span class="keyword">new</span> Pair[n];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Pair pair)</span></span>&#123;</span><br><span class="line">        values[++size] = pair;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        Pair parent = values[i/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(i / <span class="number">2</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(values[i].second &lt; parent.second)&#123;</span><br><span class="line">                Pair tmp = values[i/<span class="number">2</span>];</span><br><span class="line">                value[i/<span class="number">2</span>] = value[i];</span><br><span class="line">                value[i] = tmp;</span><br><span class="line">                i = i / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function">Pair <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Pair ret = values[<span class="number">1</span>];</span><br><span class="line">        values[<span class="number">1</span>] = values[size];</span><br><span class="line">        <span class="comment">//values[size] = null 这里忘记清空了</span></span><br><span class="line">        --size;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i * <span class="number">2</span> &lt;= size)&#123;</span><br><span class="line">            Pair left = values[i * <span class="number">2</span>];</span><br><span class="line">            Pair right = values[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(values[i].second &gt; left.second)&#123;</span><br><span class="line">                    Pair tmp = values[i];</span><br><span class="line">                    values[i] = left;</span><br><span class="line">                    values[i * <span class="number">2</span>] = tmp;</span><br><span class="line">                    <span class="comment">// i = i * 2  这里忘记更新i了</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(values[i].second &gt; Math.min(left.second, right.second))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(left.second &gt; right.second)&#123;</span><br><span class="line">                        Pair tmp = values[i];</span><br><span class="line">                        values[i] = right;</span><br><span class="line">                        values[i * <span class="number">2</span> + <span class="number">1</span>] = tmp;</span><br><span class="line">                        <span class="comment">// i = i * 2 + 1  这里忘记更新i了</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        Pair tmp = values[i];</span><br><span class="line">                        values[i] = left;</span><br><span class="line">                        values[i * <span class="number">2</span>] = tmp;</span><br><span class="line">                        <span class="comment">// i = i * 2  这里忘记更新i了</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Pair&gt; <span class="title">topK</span><span class="params">(List&lt;Pair&gt; pairs, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  Heap heap = makeHeap();</span><br><span class="line">  <span class="keyword">for</span>(Pair pair : pairs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap.size &lt; k)&#123;</span><br><span class="line">      heap.push(pair);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      Pair top = heap.top();</span><br><span class="line">      <span class="keyword">if</span>(top.second &lt; pair.second)&#123;</span><br><span class="line">        heap.pop();</span><br><span class="line">        heap.push(pair);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Pair&gt;(heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E9%9D%A2%E7%BB%8F/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>首先还是自我介绍, 介绍了项目和实习</p>
<p>你们这个实习数据量多大? 只负责的离线计算吗? 有没有做实时计算?</p>
<p>说一下HashMap和Hashtable区别?</p>
<p>介绍下java里优先队列的实现?</p>
<p>说一下使用线程池的好处?</p>
<p>在你的项目里怎么确定的线程池的参数?</p>
<p>你的项目里提到爬虫, 爬取的过程中怎么避免爬取重复的URL的问题呢? 用集合来存储</p>
<p>如果是定时爬取的话, 怎样设置集合中URL的过期时间呢? </p>
<p>了解redis删除过期的key的原理吗? 不了解, 蒙了一个不知道对不对</p>
<p>降价通知功能中每个股票对应的list是遍历一遍来扫描的吗? </p>
<p>为什么订阅后只发布一次通知, 如果用户想自定义发送通知的次数和步长, 和过期时间, 你应该怎么设计? (这个太难了, <strong>不得不说阿里的面试官水平是真的高, 几分钟的交流就已经了解我做的项目的原理了, 并且发现了不足的地方</strong>)</p>
<p>jvm有了解吗? 讲讲类加载的机制吧</p>
<p>说一下java进程的几个状态?</p>
<p>说一下java多线程的关键字?</p>
<p>说一下synchronized原理?</p>
<p>写个题吧</p>
<a id="more"></a>

<p>这个题是真的简单, 感觉和three sum一样, 甚至还更简单一些</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">有序数组n,输入k,找出满足两个数相加=k的所有序列对</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; sumK(<span class="keyword">int</span>[] n, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="keyword">null</span> || n.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt; <span class="number">0</span> &amp;&amp; left &lt; n.length &amp;&amp; n[left] == n[left-<span class="number">1</span>])&#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right &gt;= <span class="number">0</span> &amp;&amp; right &lt; n.length - <span class="number">1</span> &amp;&amp; n[right] == n[right+<span class="number">1</span>])&#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = n[left] + n[right];</span><br><span class="line">        <span class="keyword">if</span>(tmp == k)&#123;</span><br><span class="line">            ans.add(Arrays.toList(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;n[left], n[right]&#125;));</span><br><span class="line">            <span class="comment">//这里应该是 ans.add(new ArrayList&lt;Integer&gt;(Arrays.asList(n[left], n[right])));</span></span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tmp &gt; k)&#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>n数码问题的A*算法(java实现)</title>
    <url>/2020/10/04/ML/AStarAlgorithm/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文用AStar算法实现了关于8数码问题(也可以是n数码问题,  n = i^2 - 1, i = 2,3,…). 关于8数码问题和AStar算法的描述参见网络.  这里仅给出java 实现.</p>
<a id="more"></a>

<h2 id="h函数的定义"><a href="#h函数的定义" class="headerlink" title="h函数的定义"></a>h函数的定义</h2><blockquote>
<p><strong>当前</strong> 状态的 n*n 矩阵与 <strong>目标</strong> 状态的 n*n 矩阵中不同数字的个数即为<code>h</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distanceTo</span><span class="params">(Grid to)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(to.grid.length != <span class="keyword">this</span>.grid.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;ArraySize not Match!&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.grid.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.grid[i] != to.grid[i])</span><br><span class="line">                ++dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本类型Grid的定义"><a href="#基本类型Grid的定义" class="headerlink" title="基本类型Grid的定义"></a>基本类型Grid的定义</h2><p>Grid类中储存了矩阵的元素信息, 并且实现了判断两个矩阵的曼哈顿距离的distanceTo()方法和向四周移动元素0的方法expands(), 重写了equals, hashCode, toString方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> AIHomework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 定义储存二维数组的基本类型Grid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Haiyang Yu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Grid</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] grid;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Grid</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;grid is NULL!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : grid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ints.length != grid.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">&quot;grid must be a square array!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        N = grid.length;</span><br><span class="line">        <span class="keyword">int</span> size = grid.length * grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">this</span>.grid = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] i : grid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j : i)</span><br><span class="line">                <span class="keyword">this</span>.grid[k++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Grid</span><span class="params">(<span class="keyword">int</span>[] grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = grid.length;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>) Math.sqrt(len) * (<span class="keyword">int</span>) Math.sqrt(len) != len)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">&quot;grid must be a square array!&quot;</span>);</span><br><span class="line">        N = (<span class="keyword">int</span>) Math.sqrt(len);</span><br><span class="line">        <span class="keyword">this</span>.grid = Arrays.copyOf(grid,grid.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Grid</span><span class="params">(Grid other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grid = Arrays.copyOf(other.grid, other.grid.length);</span><br><span class="line">        <span class="keyword">this</span>.N = other.N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distanceTo</span><span class="params">(Grid to)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(to.grid.length != <span class="keyword">this</span>.grid.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;ArraySize not Match!&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.grid.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.grid[i] != to.grid[i])</span><br><span class="line">                ++dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find0</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;grid.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;0 not found!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Grid&gt; <span class="title">expands</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> loc0 = find0();</span><br><span class="line">        List&lt;Grid&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(loc0 &gt;= N)  <span class="comment">//move up</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmparr = Arrays.copyOf(grid, grid.length);</span><br><span class="line">            <span class="keyword">int</span> tmp = tmparr[loc0];</span><br><span class="line">            tmparr[loc0] = tmparr[loc0 - N];</span><br><span class="line">            tmparr[loc0 - N] = tmp;</span><br><span class="line">            ans.add(<span class="keyword">new</span> Grid(tmparr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loc0 &lt; grid.length - N) <span class="comment">// move down</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmparr = Arrays.copyOf(grid, grid.length);</span><br><span class="line">            <span class="keyword">int</span> tmp = tmparr[loc0];</span><br><span class="line">            tmparr[loc0] = tmparr[loc0 + N];</span><br><span class="line">            tmparr[loc0 + N] = tmp;</span><br><span class="line">            ans.add(<span class="keyword">new</span> Grid(tmparr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loc0 % N != <span class="number">0</span>) <span class="comment">//move left</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmparr = Arrays.copyOf(grid, grid.length);</span><br><span class="line">            <span class="keyword">int</span> tmp = tmparr[loc0];</span><br><span class="line">            tmparr[loc0] = tmparr[loc0 - <span class="number">1</span>];</span><br><span class="line">            tmparr[loc0 - <span class="number">1</span>] = tmp;</span><br><span class="line">            ans.add(<span class="keyword">new</span> Grid(tmparr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loc0 % N != N-<span class="number">1</span>) <span class="comment">//move right</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmparr = Arrays.copyOf(grid, grid.length);</span><br><span class="line">            <span class="keyword">int</span> tmp = tmparr[loc0];</span><br><span class="line">            tmparr[loc0] = tmparr[loc0 + <span class="number">1</span>];</span><br><span class="line">            tmparr[loc0 + <span class="number">1</span>] = tmp;</span><br><span class="line">            ans.add(<span class="keyword">new</span> Grid(tmparr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(other <span class="keyword">instanceof</span> Grid)</span><br><span class="line">        &#123;</span><br><span class="line">            Grid o = (Grid) other;</span><br><span class="line">            <span class="keyword">if</span>(o.grid.length != <span class="keyword">this</span>.grid.length)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.grid.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(o.grid[i] != <span class="keyword">this</span>.grid[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> base = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : grid)</span><br><span class="line">        &#123;</span><br><span class="line">            a += i;</span><br><span class="line">            a *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : <span class="keyword">this</span>.grid)</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max)</span><br><span class="line">                max = i;</span><br><span class="line">        <span class="keyword">int</span> subsize = (<span class="keyword">int</span>) Math.sqrt(grid.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % subsize == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line">                s.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(max &gt; <span class="number">9</span> &amp;&amp; grid[i] &lt; <span class="number">10</span>)</span><br><span class="line">                s.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            s.append(grid[i]);</span><br><span class="line">            s.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        Grid ga = <span class="keyword">new</span> Grid(a);</span><br><span class="line">        <span class="keyword">int</span>[][] b = &#123;&#123;<span class="number">2</span>,<span class="number">8</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        Grid gb = <span class="keyword">new</span> Grid(b);</span><br><span class="line">        <span class="keyword">for</span>(Grid g : ga.expands())</span><br><span class="line">            System.out.println(g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态节点类型State的定义"><a href="#状态节点类型State的定义" class="headerlink" title="状态节点类型State的定义"></a>状态节点类型State的定义</h2><p>State是节点类, 描述某个节点含有的grid, 最终状态的目标grid, 以及节点是从哪个父节点移动得来的.</p>
<p>同时, 计算了H, G, F的值. 并且可以通过调用aStar方法来执行A*算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> AIHomework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 节点类, 描述某个节点含有的grid, 最终的目标grid, 以及节点是从哪个父节点移动得来的.</span></span><br><span class="line"><span class="comment"> * 同时, 计算了H, G, F的值. 并且可以通过调用aStar方法来执行A*算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Haiyang Yu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Grid</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Grid curr;</span><br><span class="line">    <span class="keyword">public</span> Grid finalState;</span><br><span class="line">    <span class="keyword">public</span> State prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> H;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> G;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> F;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIteration;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(Grid currState, Grid finalState, State prev, <span class="keyword">int</span> maxIteration)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxIteration = maxIteration;</span><br><span class="line">        <span class="keyword">this</span>.curr = currState;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        <span class="keyword">this</span>.finalState = finalState;</span><br><span class="line">        H = currState.distanceTo(finalState);</span><br><span class="line">        <span class="keyword">if</span>(prev == <span class="keyword">null</span>)</span><br><span class="line">            G = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            G = prev.G + <span class="number">1</span>;</span><br><span class="line">        F = G + H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(Grid currState, Grid finalState, State prev)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(currState, finalState, prev, <span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(Grid currState, Grid finalState)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(currState,finalState, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;State&gt; <span class="title">expands</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;State&gt; states = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Grid grid : curr.expands())</span><br><span class="line">        &#123;</span><br><span class="line">            states.add(<span class="keyword">new</span> State(grid, finalState, <span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(other <span class="keyword">instanceof</span> State)</span><br><span class="line">        &#123;</span><br><span class="line">            State o = (State) other;</span><br><span class="line">            <span class="keyword">return</span> o.curr.equals(<span class="keyword">this</span>.curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curr.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curr.toString() + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;F: &quot;</span> + F + <span class="string">&quot; H: &quot;</span> + H + <span class="string">&quot; G: &quot;</span> + G;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 算法参考于https://www.cnblogs.com/roadwide/p/12890295.html</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aStar</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;State&gt; open = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;State&gt; closed = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        open.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">int</span> iteration = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!open.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            ++iteration;</span><br><span class="line">            <span class="keyword">if</span>(iteration == maxIteration)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Iteration times reached &quot;</span> + maxIteration + <span class="string">&quot;. This state maybe doesn&#x27;t have a solution!&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(iteration % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.println(<span class="string">&quot;Iteration times: &quot;</span> + iteration);</span><br><span class="line">            open.sort((State a, State b) -&gt; &#123;<span class="keyword">return</span> a.F - b.F;&#125;);</span><br><span class="line">            State minFState = open.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(minFState.H == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                minFState.tracePrint();</span><br><span class="line">                System.out.println(<span class="string">&quot;Process finished with &quot;</span> + iteration + <span class="string">&quot; times iteration.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            open.remove(<span class="number">0</span>);</span><br><span class="line">            closed.add(minFState);</span><br><span class="line"></span><br><span class="line">            List&lt;State&gt; expandStates = minFState.expands();</span><br><span class="line">            <span class="keyword">for</span>(State state : expandStates)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">boolean</span> doesClosedContainState = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(State closedState : closed)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(closedState.equals(state)) &#123;</span><br><span class="line">                        doesClosedContainState = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(state.G &lt; closedState.G) &#123;</span><br><span class="line">                            closedState = state;</span><br><span class="line">                            open.add(state);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> doesOpenContainState = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(State openState : open) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(openState.equals(state))&#123;</span><br><span class="line">                        doesOpenContainState = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(state.G &lt; openState.G)</span><br><span class="line">                        &#123;</span><br><span class="line">                            openState = state;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!doesOpenContainState &amp;&amp; !doesClosedContainState)</span><br><span class="line">                    open.add(state);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tracePrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;State&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        State state = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span>(state != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.add(state);</span><br><span class="line">            state = state.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ans);</span><br><span class="line">        <span class="keyword">for</span>(State i : ans)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        Grid ga = <span class="keyword">new</span> Grid(a);</span><br><span class="line">        <span class="keyword">int</span>[][] b = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">4</span>,<span class="number">0</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        Grid gb = <span class="keyword">new</span> Grid(b);</span><br><span class="line">        State state = <span class="keyword">new</span> State(gb,ga);</span><br><span class="line">        state.aStar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造测试样例的辅助类"><a href="#构造测试样例的辅助类" class="headerlink" title="构造测试样例的辅助类"></a>构造测试样例的辅助类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> AIHomework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 由于n数码问题不是一定有解的. 当二维数组的size升高时, 随机生成一个 0 - 15的矩阵或者随机生成一个 0 - 24的矩阵很可能导致问题无解,</span></span><br><span class="line"><span class="comment"> * 这里的无解定义为A*算法迭代次数多于65536次. 参考State类中的aStar()方法.</span></span><br><span class="line"><span class="comment"> * 所以特意编写此类, 通过最终矩阵随机转移n次元素0, 保证生成的矩阵到最终矩阵是可以通过有限次转移得到, 即n数码问题问题有解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Haiyang Yu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GridGenerationFromFinalGrid</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Grid <span class="title">getNewGrid</span><span class="params">(Grid finalGrid, <span class="keyword">int</span> moveTimes, <span class="keyword">long</span> seed)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Grid ans = <span class="keyword">new</span> Grid(finalGrid);</span><br><span class="line">        Random r = <span class="keyword">new</span> Random(seed);</span><br><span class="line">        <span class="keyword">while</span>(moveTimes &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Grid&gt; grids = ans.expands();</span><br><span class="line">            <span class="keyword">int</span> i = r.nextInt(grids.size());</span><br><span class="line">            ans = grids.get(i);</span><br><span class="line">            --moveTimes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Grid <span class="title">getNewGrid</span><span class="params">(Grid finalGrid, <span class="keyword">int</span> moveTimes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNewGrid(finalGrid, moveTimes, <span class="number">2020103732L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Grid <span class="title">getNewGrid</span><span class="params">(Grid finalGrid)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNewGrid(finalGrid, <span class="number">47</span>, <span class="number">2020103732L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] finalArray3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        Grid finalGrid = <span class="keyword">new</span> Grid(finalArray3);</span><br><span class="line">        <span class="keyword">int</span>[] a = GridGenerationFromFinalGrid.getNewGrid(finalGrid).grid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : a)</span><br><span class="line">            System.out.print(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="调用A-算法的主函数类"><a href="#调用A-算法的主函数类" class="headerlink" title="调用A*算法的主函数类"></a>调用A*算法的主函数类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> AIHomework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AStarMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] array1 =  &#123;&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] array2 =  &#123;&#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">11</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] array3 =  &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">19</span>,<span class="number">14</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">0</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">18</span>,<span class="number">15</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">16</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] finalArray1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] finalArray2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] finalArray3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        State state1 = <span class="keyword">new</span> State(<span class="keyword">new</span> Grid(array1), <span class="keyword">new</span> Grid(finalArray1));</span><br><span class="line">        state1.aStar();</span><br><span class="line">        State state2 = <span class="keyword">new</span> State(<span class="keyword">new</span> Grid(array2), <span class="keyword">new</span> Grid(finalArray2));</span><br><span class="line">        state2.aStar();</span><br><span class="line">        State state3 = <span class="keyword">new</span> State(<span class="keyword">new</span> Grid(array3), <span class="keyword">new</span> Grid(finalArray3));</span><br><span class="line">        state3.aStar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="示例1-3-3"><a href="#示例1-3-3" class="headerlink" title="示例1 (3*3)"></a>示例1 (3*3)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;5,3,6&#125;,                       1 2 3</span><br><span class="line">&#123;1,8,4&#125;,          &#x3D;&gt;            4 5 6</span><br><span class="line">&#123;7,2,0&#125;&#125;;                       7 8 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------</span><br><span class="line">5 3 6 </span><br><span class="line">1 8 4 </span><br><span class="line">7 2 0 </span><br><span class="line">F: 7 H: 7 G: 0</span><br><span class="line">-------------</span><br><span class="line">5 3 6 </span><br><span class="line">1 8 4 </span><br><span class="line">7 0 2 </span><br><span class="line">F: 9 H: 8 G: 1</span><br><span class="line">-------------</span><br><span class="line">5 3 6 </span><br><span class="line">1 0 4 </span><br><span class="line">7 8 2 </span><br><span class="line">F: 9 H: 7 G: 2</span><br><span class="line">-------------</span><br><span class="line">5 3 6 </span><br><span class="line">1 4 0 </span><br><span class="line">7 8 2 </span><br><span class="line">F: 10 H: 7 G: 3</span><br><span class="line">-------------</span><br><span class="line">5 3 0 </span><br><span class="line">1 4 6 </span><br><span class="line">7 8 2 </span><br><span class="line">F: 10 H: 6 G: 4</span><br><span class="line">-------------</span><br><span class="line">5 0 3 </span><br><span class="line">1 4 6 </span><br><span class="line">7 8 2 </span><br><span class="line">F: 10 H: 5 G: 5</span><br><span class="line">-------------</span><br><span class="line">0 5 3 </span><br><span class="line">1 4 6 </span><br><span class="line">7 8 2 </span><br><span class="line">F: 11 H: 5 G: 6</span><br><span class="line">-------------</span><br><span class="line">1 5 3 </span><br><span class="line">0 4 6 </span><br><span class="line">7 8 2 </span><br><span class="line">F: 11 H: 4 G: 7</span><br><span class="line">-------------</span><br><span class="line">1 5 3 </span><br><span class="line">4 0 6 </span><br><span class="line">7 8 2 </span><br><span class="line">F: 11 H: 3 G: 8</span><br><span class="line">-------------</span><br><span class="line">1 0 3 </span><br><span class="line">4 5 6 </span><br><span class="line">7 8 2 </span><br><span class="line">F: 11 H: 2 G: 9</span><br><span class="line">-------------</span><br><span class="line">1 3 0 </span><br><span class="line">4 5 6 </span><br><span class="line">7 8 2 </span><br><span class="line">F: 13 H: 3 G: 10</span><br><span class="line">-------------</span><br><span class="line">1 3 6 </span><br><span class="line">4 5 0 </span><br><span class="line">7 8 2 </span><br><span class="line">F: 15 H: 4 G: 11</span><br><span class="line">-------------</span><br><span class="line">1 3 6 </span><br><span class="line">4 5 2 </span><br><span class="line">7 8 0 </span><br><span class="line">F: 15 H: 3 G: 12</span><br><span class="line">-------------</span><br><span class="line">1 3 6 </span><br><span class="line">4 5 2 </span><br><span class="line">7 0 8 </span><br><span class="line">F: 18 H: 5 G: 13</span><br><span class="line">-------------</span><br><span class="line">1 3 6 </span><br><span class="line">4 0 2 </span><br><span class="line">7 5 8 </span><br><span class="line">F: 20 H: 6 G: 14</span><br><span class="line">-------------</span><br><span class="line">1 3 6 </span><br><span class="line">4 2 0 </span><br><span class="line">7 5 8 </span><br><span class="line">F: 21 H: 6 G: 15</span><br><span class="line">-------------</span><br><span class="line">1 3 0 </span><br><span class="line">4 2 6 </span><br><span class="line">7 5 8 </span><br><span class="line">F: 21 H: 5 G: 16</span><br><span class="line">-------------</span><br><span class="line">1 0 3 </span><br><span class="line">4 2 6 </span><br><span class="line">7 5 8 </span><br><span class="line">F: 21 H: 4 G: 17</span><br><span class="line">-------------</span><br><span class="line">1 2 3 </span><br><span class="line">4 0 6 </span><br><span class="line">7 5 8 </span><br><span class="line">F: 21 H: 3 G: 18</span><br><span class="line">-------------</span><br><span class="line">1 2 3 </span><br><span class="line">4 5 6 </span><br><span class="line">7 0 8 </span><br><span class="line">F: 21 H: 2 G: 19</span><br><span class="line">-------------</span><br><span class="line">1 2 3 </span><br><span class="line">4 5 6 </span><br><span class="line">7 8 0 </span><br><span class="line">F: 20 H: 0 G: 20</span><br><span class="line">Process finished with 3721 times iteration.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="示例2-4-4"><a href="#示例2-4-4" class="headerlink" title="示例2 (4*4)"></a>示例2 (4*4)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;0,6,2,3&#125;,                                      1  2  3  4</span><br><span class="line">&#123;1,7,12,11&#125;,                          &#x3D;&gt;         5  6  7  8</span><br><span class="line">&#123;5,9,10,4&#125;,                                      9 10 11 12</span><br><span class="line">&#123;13,14,8,15&#125;&#125;;                                  13 14 15  0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------</span><br><span class="line"> 0  6  2  3 </span><br><span class="line"> 1  7 12 11 </span><br><span class="line"> 5  9 10  4 </span><br><span class="line">13 14  8 15 </span><br><span class="line">F: 14 H: 14 G: 0</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 0  7 12 11 </span><br><span class="line"> 5  9 10  4 </span><br><span class="line">13 14  8 15 </span><br><span class="line">F: 14 H: 13 G: 1</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7 12 11 </span><br><span class="line"> 0  9 10  4 </span><br><span class="line">13 14  8 15 </span><br><span class="line">F: 14 H: 12 G: 2</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7 12 11 </span><br><span class="line"> 9  0 10  4 </span><br><span class="line">13 14  8 15 </span><br><span class="line">F: 14 H: 11 G: 3</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7 12 11 </span><br><span class="line"> 9 10  0  4 </span><br><span class="line">13 14  8 15 </span><br><span class="line">F: 14 H: 10 G: 4</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7  0 11 </span><br><span class="line"> 9 10 12  4 </span><br><span class="line">13 14  8 15 </span><br><span class="line">F: 15 H: 10 G: 5</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7 11  0 </span><br><span class="line"> 9 10 12  4 </span><br><span class="line">13 14  8 15 </span><br><span class="line">F: 16 H: 10 G: 6</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7 11  4 </span><br><span class="line"> 9 10 12  0 </span><br><span class="line">13 14  8 15 </span><br><span class="line">F: 17 H: 10 G: 7</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7 11  4 </span><br><span class="line"> 9 10  0 12 </span><br><span class="line">13 14  8 15 </span><br><span class="line">F: 17 H: 9 G: 8</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7 11  4 </span><br><span class="line"> 9 10  8 12 </span><br><span class="line">13 14  0 15 </span><br><span class="line">F: 18 H: 9 G: 9</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7 11  4 </span><br><span class="line"> 9 10  8 12 </span><br><span class="line">13 14 15  0 </span><br><span class="line">F: 17 H: 7 G: 10</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7 11  4 </span><br><span class="line"> 9 10  8  0 </span><br><span class="line">13 14 15 12 </span><br><span class="line">F: 20 H: 9 G: 11</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7 11  4 </span><br><span class="line"> 9 10  0  8 </span><br><span class="line">13 14 15 12 </span><br><span class="line">F: 21 H: 9 G: 12</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  7  0  4 </span><br><span class="line"> 9 10 11  8 </span><br><span class="line">13 14 15 12 </span><br><span class="line">F: 21 H: 8 G: 13</span><br><span class="line">-------------</span><br><span class="line"> 1  6  2  3 </span><br><span class="line"> 5  0  7  4 </span><br><span class="line"> 9 10 11  8 </span><br><span class="line">13 14 15 12 </span><br><span class="line">F: 21 H: 7 G: 14</span><br><span class="line">-------------</span><br><span class="line"> 1  0  2  3 </span><br><span class="line"> 5  6  7  4 </span><br><span class="line"> 9 10 11  8 </span><br><span class="line">13 14 15 12 </span><br><span class="line">F: 21 H: 6 G: 15</span><br><span class="line">-------------</span><br><span class="line"> 1  2  0  3 </span><br><span class="line"> 5  6  7  4 </span><br><span class="line"> 9 10 11  8 </span><br><span class="line">13 14 15 12 </span><br><span class="line">F: 21 H: 5 G: 16</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  0 </span><br><span class="line"> 5  6  7  4 </span><br><span class="line"> 9 10 11  8 </span><br><span class="line">13 14 15 12 </span><br><span class="line">F: 21 H: 4 G: 17</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  4 </span><br><span class="line"> 5  6  7  0 </span><br><span class="line"> 9 10 11  8 </span><br><span class="line">13 14 15 12 </span><br><span class="line">F: 21 H: 3 G: 18</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  4 </span><br><span class="line"> 5  6  7  8 </span><br><span class="line"> 9 10 11  0 </span><br><span class="line">13 14 15 12 </span><br><span class="line">F: 21 H: 2 G: 19</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  4 </span><br><span class="line"> 5  6  7  8 </span><br><span class="line"> 9 10 11 12 </span><br><span class="line">13 14 15  0 </span><br><span class="line">F: 20 H: 0 G: 20</span><br><span class="line">Process finished with 2217 times iteration.</span><br></pre></td></tr></table></figure>

<h2 id="示例3-5-5"><a href="#示例3-5-5" class="headerlink" title="示例3 (5*5)"></a>示例3 (5*5)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;1,2,3,5,9&#125;,                                 1  2  3  4  5</span><br><span class="line">&#123;6,7,8,4,10&#125;,                                 6  7  8  9 10</span><br><span class="line">&#123;11,12,13,19,14&#125;,                   &#x3D;&gt;       11 12 13 14 15</span><br><span class="line">&#123;0,17,21,18,15&#125;,                             16 17 18 19 20</span><br><span class="line">&#123;16,22,23,24,20&#125;&#125;;                           21 22 23 24  0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line"> 0 17 21 18 15 </span><br><span class="line">16 22 23 24 20 </span><br><span class="line">F: 11 H: 11 G: 0</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line">17  0 21 18 15 </span><br><span class="line">16 22 23 24 20 </span><br><span class="line">F: 13 H: 12 G: 1</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line">17 21  0 18 15 </span><br><span class="line">16 22 23 24 20 </span><br><span class="line">F: 14 H: 12 G: 2</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line">17 21 23 18 15 </span><br><span class="line">16 22  0 24 20 </span><br><span class="line">F: 16 H: 13 G: 3</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line">17 21 23 18 15 </span><br><span class="line">16  0 22 24 20 </span><br><span class="line">F: 18 H: 14 G: 4</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line">17  0 23 18 15 </span><br><span class="line">16 21 22 24 20 </span><br><span class="line">F: 19 H: 14 G: 5</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line"> 0 17 23 18 15 </span><br><span class="line">16 21 22 24 20 </span><br><span class="line">F: 19 H: 13 G: 6</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line">16 17 23 18 15 </span><br><span class="line"> 0 21 22 24 20 </span><br><span class="line">F: 19 H: 12 G: 7</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line">16 17 23 18 15 </span><br><span class="line">21  0 22 24 20 </span><br><span class="line">F: 19 H: 11 G: 8</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line">16 17 23 18 15 </span><br><span class="line">21 22  0 24 20 </span><br><span class="line">F: 19 H: 10 G: 9</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line">16 17  0 18 15 </span><br><span class="line">21 22 23 24 20 </span><br><span class="line">F: 19 H: 9 G: 10</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 19 14 </span><br><span class="line">16 17 18  0 15 </span><br><span class="line">21 22 23 24 20 </span><br><span class="line">F: 19 H: 8 G: 11</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13  0 14 </span><br><span class="line">16 17 18 19 15 </span><br><span class="line">21 22 23 24 20 </span><br><span class="line">F: 19 H: 7 G: 12</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4 10 </span><br><span class="line">11 12 13 14  0 </span><br><span class="line">16 17 18 19 15 </span><br><span class="line">21 22 23 24 20 </span><br><span class="line">F: 19 H: 6 G: 13</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  9 </span><br><span class="line"> 6  7  8  4  0 </span><br><span class="line">11 12 13 14 10 </span><br><span class="line">16 17 18 19 15 </span><br><span class="line">21 22 23 24 20 </span><br><span class="line">F: 21 H: 7 G: 14</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  5  0 </span><br><span class="line"> 6  7  8  4  9 </span><br><span class="line">11 12 13 14 10 </span><br><span class="line">16 17 18 19 15 </span><br><span class="line">21 22 23 24 20 </span><br><span class="line">F: 22 H: 7 G: 15</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  0  5 </span><br><span class="line"> 6  7  8  4  9 </span><br><span class="line">11 12 13 14 10 </span><br><span class="line">16 17 18 19 15 </span><br><span class="line">21 22 23 24 20 </span><br><span class="line">F: 22 H: 6 G: 16</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  4  5 </span><br><span class="line"> 6  7  8  0  9 </span><br><span class="line">11 12 13 14 10 </span><br><span class="line">16 17 18 19 15 </span><br><span class="line">21 22 23 24 20 </span><br><span class="line">F: 22 H: 5 G: 17</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  4  5 </span><br><span class="line"> 6  7  8  9  0 </span><br><span class="line">11 12 13 14 10 </span><br><span class="line">16 17 18 19 15 </span><br><span class="line">21 22 23 24 20 </span><br><span class="line">F: 22 H: 4 G: 18</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  4  5 </span><br><span class="line"> 6  7  8  9 10 </span><br><span class="line">11 12 13 14  0 </span><br><span class="line">16 17 18 19 15 </span><br><span class="line">21 22 23 24 20 </span><br><span class="line">F: 22 H: 3 G: 19</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  4  5 </span><br><span class="line"> 6  7  8  9 10 </span><br><span class="line">11 12 13 14 15 </span><br><span class="line">16 17 18 19  0 </span><br><span class="line">21 22 23 24 20 </span><br><span class="line">F: 22 H: 2 G: 20</span><br><span class="line">-------------</span><br><span class="line"> 1  2  3  4  5 </span><br><span class="line"> 6  7  8  9 10 </span><br><span class="line">11 12 13 14 15 </span><br><span class="line">16 17 18 19 20 </span><br><span class="line">21 22 23 24  0 </span><br><span class="line">F: 21 H: 0 G: 21</span><br><span class="line">Process finished with 2567 times iteration.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.Hashtable阅读笔记</title>
    <url>/2020/12/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java.util.Hashtable%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Hashtable阅读笔记"><a href="#Hashtable阅读笔记" class="headerlink" title="Hashtable阅读笔记"></a>Hashtable阅读笔记</h2><p>这是我读的第2个源码, mark一下吧.</p>
<p>建议如果阅读代码中的笔记, 将下面的代码块拷贝到vs code或idea上. 因为在markdown的代码块中宽度有限制, 会影响观看效果.</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 1994, 2017, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> sun.misc.SharedSecrets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class implements a hash table, which maps keys to values. Any           //不允许null的key或value</span></span><br><span class="line"><span class="comment"> * non-&lt;code&gt;null&lt;/code&gt; object can be used as a key or as a value. &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To successfully store and retrieve objects from a hashtable, the</span></span><br><span class="line"><span class="comment"> * objects used as keys must implement the &lt;code&gt;hashCode&lt;/code&gt;               //对象必须实现hashCode()方法. (但是感觉这是废话吧... 继承Object类的都有hashCode方法啊)</span></span><br><span class="line"><span class="comment"> * method and the &lt;code&gt;equals&lt;/code&gt; method. &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An instance of &lt;code&gt;Hashtable&lt;/code&gt; has two parameters that affect its    //这两个参数initial capacity和loadFactor和HashMap中的相同</span></span><br><span class="line"><span class="comment"> * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;capacity&lt;/i&gt; is the number of &lt;i&gt;buckets&lt;/i&gt; in the hash table, and the</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;initial capacity&lt;/i&gt; is simply the capacity at the time the hash table</span></span><br><span class="line"><span class="comment"> * is created.  Note that the hash table is &lt;i&gt;open&lt;/i&gt;: in the case of a &quot;hash   // 这里的hash table is open是指用拉链法解决hash冲突. closed hash指用开放定址法解决冲突</span></span><br><span class="line"><span class="comment"> * collision&quot;, a single bucket stores multiple entries, which must be searched    //一个桶装多个entry</span></span><br><span class="line"><span class="comment"> * sequentially.  The &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash</span></span><br><span class="line"><span class="comment"> * table is allowed to get before its capacity is automatically increased.</span></span><br><span class="line"><span class="comment"> * The initial capacity and load factor parameters are merely hints to</span></span><br><span class="line"><span class="comment"> * the implementation.  The exact details as to when and whether the rehash</span></span><br><span class="line"><span class="comment"> * method is invoked are implementation-dependent.&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Generally, the default load factor (.75) offers a good tradeoff between   // 默认的loadFactor和HashMap相同是0.75</span></span><br><span class="line"><span class="comment"> * time and space costs.  Higher values decrease the space overhead but</span></span><br><span class="line"><span class="comment"> * increase the time cost to look up an entry (which is reflected in most</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Hashtable&lt;/tt&gt; operations, including &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The initial capacity controls a tradeoff between wasted space and the</span></span><br><span class="line"><span class="comment"> * need for &lt;code&gt;rehash&lt;/code&gt; operations, which are time-consuming.</span></span><br><span class="line"><span class="comment"> * No &lt;code&gt;rehash&lt;/code&gt; operations will &lt;i&gt;ever&lt;/i&gt; occur if the initial     //和HashMap一样只会扩容不会缩容</span></span><br><span class="line"><span class="comment"> * capacity is greater than the maximum number of entries the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Hashtable&lt;/tt&gt; will contain divided by its load factor.  However,</span></span><br><span class="line"><span class="comment"> * setting the initial capacity too high can waste space.&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If many entries are to be made into a &lt;code&gt;Hashtable&lt;/code&gt;,</span></span><br><span class="line"><span class="comment"> * creating it with a sufficiently large capacity may allow the</span></span><br><span class="line"><span class="comment"> * entries to be inserted more efficiently than letting it perform</span></span><br><span class="line"><span class="comment"> * automatic rehashing as needed to grow the table. &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This example creates a hashtable of numbers. It uses the names of</span></span><br><span class="line"><span class="comment"> * the numbers as keys:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;   &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *   Hashtable&lt;String, Integer&gt; numbers</span></span><br><span class="line"><span class="comment"> *     = new Hashtable&lt;String, Integer&gt;();</span></span><br><span class="line"><span class="comment"> *   numbers.put(&quot;one&quot;, 1);</span></span><br><span class="line"><span class="comment"> *   numbers.put(&quot;two&quot;, 2);</span></span><br><span class="line"><span class="comment"> *   numbers.put(&quot;three&quot;, 3);&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;To retrieve a number, use the following code:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;   &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *   Integer n = numbers.get(&quot;two&quot;);</span></span><br><span class="line"><span class="comment"> *   if (n != null) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(&quot;two = &quot; + n);</span></span><br><span class="line"><span class="comment"> *   &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The iterators returned by the &lt;tt&gt;iterator&lt;/tt&gt; method of the collections  //Hashtable对象本身没有iterator方法, 因为Map接口没有这个方法</span></span><br><span class="line"><span class="comment"> * returned by all of this class&#x27;s &quot;collection view methods&quot; are                 //要想遍历所有的键, 值, entry, 就要通过keySet(), values(), entrySet()返回相应的Collection对象才能调用iterator()方法</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;fail-fast&lt;/em&gt;: if the Hashtable is structurally modified at any time     // 注意, keySet(), values(), entrySet()返回的这些集合也是经过Collections.synchronizedSet()包装过的, 是线程安全的</span></span><br><span class="line"><span class="comment"> * after the iterator is created, in any way except through the iterator&#x27;s own</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a &#123;<span class="doctag">@link</span>                      // 但是虽然这些集合是线程安全的, 遍历的时候仍然要加锁. 防止出现ConcurrentModificationException.</span></span><br><span class="line"><span class="comment"> * ConcurrentModificationException&#125;.  Thus, in the face of concurrent            // 这里解释一下, 这些集合本身是线程安全的是指这些线程的一个操作保证原子性, 并不保证整个遍历过程中的原子性</span></span><br><span class="line"><span class="comment"> * modification, the iterator fails quickly and cleanly, rather than risking     // 例如:  Hashtable&lt;String, AtomicInteger&gt; hashtable = new Hashtable&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * arbitrary, non-deterministic behavior at an undetermined time in the future.  //        hashtable.put(&quot;1&quot;,new AtomicInteger(1));    </span></span><br><span class="line"><span class="comment"> * The Enumerations returned by Hashtable&#x27;s keys and elements methods are        //        hashtable.put(&quot;2&quot;,new AtomicInteger(2));</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;not&lt;/em&gt; fail-fast.                                                       //        Iterator&lt;Map.Entry&lt;String, AtomicInteger&gt;&gt; iterator = hashtable.entrySet().iterator();</span></span><br><span class="line"><span class="comment"> *                                                                               //        while(iterator.hasNext())&#123;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed       //            iterator.next().getValue().incrementAndGet();</span></span><br><span class="line"><span class="comment"> * as it is, generally speaking, impossible to make any hard guarantees in the   //        &#125;</span></span><br><span class="line"><span class="comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators      //  这段程序跑在多线程环境下就会出问题. 因为即使是线程安全的集合页只能保证getValue()这个操作是原子性的</span></span><br><span class="line"><span class="comment"> * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.        //  但是没法保证整个while是原子性的. 所以可能会出现遍历了1个元素后另外一个线程改变了entrySet, 使得里面的modCount和原来不相等</span></span><br><span class="line"><span class="comment"> * Therefore, it would be wrong to write a program that depended on this         //  所以要在while外面加一个大锁才行. 增强for循环也会出错, 因为本质上增强for就是用的迭代器</span></span><br><span class="line"><span class="comment"> * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators         //  但是也有例外, CopyOnWriteList或CopyOnWriteSet这样的就没事, 多线程遍历也不会报错.</span></span><br><span class="line"><span class="comment"> * should be used only to detect bugs.&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As of the Java 2 platform v1.2, this class was retrofitted to              // retrofitted 意思是 重新改造, 翻新</span></span><br><span class="line"><span class="comment"> * implement the &#123;<span class="doctag">@link</span> Map&#125; interface, making it a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.  Unlike the new collection</span></span><br><span class="line"><span class="comment"> * implementations, &#123;<span class="doctag">@code</span> Hashtable&#125; is synchronized.  If a                    // Hashtable是线程安全的, 并且不建议被使用</span></span><br><span class="line"><span class="comment"> * thread-safe implementation is not needed, it is recommended to use</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> HashMap&#125; in place of &#123;<span class="doctag">@code</span> Hashtable&#125;.  If a thread-safe</span></span><br><span class="line"><span class="comment"> * highly-concurrent implementation is desired, then it is recommended</span></span><br><span class="line"><span class="comment"> * to use &#123;<span class="doctag">@link</span> java.util.concurrent.ConcurrentHashMap&#125; in place of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Hashtable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Arthur van Hoff</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Neal Gafter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#hashCode()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Hashtable#rehash()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     HashMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     TreeMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;                                        //父类是<span class="title">Dictionary</span> 而不是<span class="title">AbstractMap</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The hash table data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;                         <span class="comment">//同HashMap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The total number of entries in the hash table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;                                 <span class="comment">//同HashMap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table is rehashed when its size exceeds this threshold.  (The</span></span><br><span class="line"><span class="comment">     * value of this field is (int)(capacity * loadFactor).)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;                                         <span class="comment">//含义同HashMap. 但是注意, 这里的threshold在new的时候背初始化为capacity * loadFactor</span></span><br><span class="line">                                                                   <span class="comment">//而在HashMap中, threshold一开始先储存table的大小(大于等于initialCapacity的第一个2的整数次幂), 如果构造器中不传入initialCapacity, threthold就为0</span></span><br><span class="line">    <span class="comment">/**                                                            //table一开始不会初始化, 而是开始put第一个元素的时候初始化, 长度就是threshold的值(threshold如果是0就为默认的16). </span></span><br><span class="line"><span class="comment">     * The load factor for the hashtable.                          //之后threshold才被赋值为capacity * loadFactor, 并行使相应的功能.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;                                      <span class="comment">//同HashMap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this Hashtable has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of entries in</span></span><br><span class="line"><span class="comment">     * the Hashtable or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the Hashtable fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1421746759512286392L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty hashtable with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and the specified load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hashtable.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      loadFactor        the load factor of the hashtable.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  IllegalArgumentException  if the initial capacity is less</span></span><br><span class="line"><span class="comment">     *             than zero, or if the load factor is nonpositive.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;                  <span class="comment">//和HashMap不同, Hashtable一上来就初始化数组, 并且传入的初始容量是多少, 数组长度就是多少. </span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)                                               <span class="comment">// 但是有个例外, 传入的初始容量为0时数组为1.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">            initialCapacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty hashtable with the specified initial capacity</span></span><br><span class="line"><span class="comment">     * and default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>     initialCapacity   the initial capacity of the hashtable.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span> IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment">     *              than zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;                           <span class="comment">//默认的loadfactor和HashMap相同</span></span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty hashtable with a default initial capacity (11)</span></span><br><span class="line"><span class="comment">     * and load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;                                            <span class="comment">//默认的初始容量为 11, 和HashMap的16 不同!</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new hashtable with the same mappings as the given</span></span><br><span class="line"><span class="comment">     * Map.  The hashtable is created with an initial capacity sufficient to     // 为了保证有充足的容量就设置为2 * t.size(). </span></span><br><span class="line"><span class="comment">     * hold the mappings in the given Map and a default load factor (0.75).      // 其实我觉得只要不超过 (4/3) * t.size()就可以保证插入的过程中不触发扩容. </span></span><br><span class="line"><span class="comment">     *                                                                           // 这里可能是认为new完的hashtable可能还要插入元素, 所以就预留出一些位置.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the map whose mappings are to be placed in this map.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">        putAll(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of keys in this hashtable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the number of keys in this hashtable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;                                          <span class="comment">//因为count不是volatile的, 为了保证可见性, 必须要加锁</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests if this hashtable maps no keys to values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this hashtable maps no keys to values;</span></span><br><span class="line"><span class="comment">     *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;                               <span class="comment">//加锁原因同size()方法</span></span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an enumeration of the keys in this hashtable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  an enumeration of the keys in this hashtable.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     Enumeration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #elements()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #keySet()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;                          <span class="comment">//Enumeration接口相当于一个迭代器, 有hasMoreElements()和nextElement()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.&lt;K&gt;getEnumeration(KEYS);                             <span class="comment">//现在这个接口已经被Iterator接口替代</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an enumeration of the values in this hashtable.</span></span><br><span class="line"><span class="comment">     * Use the Enumeration methods on the returned object to fetch the elements</span></span><br><span class="line"><span class="comment">     * sequentially.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  an enumeration of the values in this hashtable.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.util.Enumeration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #keys()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #values()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.&lt;V&gt;getEnumeration(VALUES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests if some key maps into the specified value in this hashtable.</span></span><br><span class="line"><span class="comment">     * This operation is more expensive than the &#123;<span class="doctag">@link</span> #containsKey</span></span><br><span class="line"><span class="comment">     * containsKey&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this method is identical in functionality to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #containsValue containsValue&#125;, (which is part of the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Map&#125; interface in the collections framework).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      value   a value to search for</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>     &lt;code&gt;true&lt;/code&gt; if and only if some key maps to the</span></span><br><span class="line"><span class="comment">     *             &lt;code&gt;value&lt;/code&gt; argument in this hashtable as</span></span><br><span class="line"><span class="comment">     *             determined by the &lt;tt&gt;equals&lt;/tt&gt; method;</span></span><br><span class="line"><span class="comment">     *             &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  NullPointerException  if the value is &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;                <span class="comment">//返回Hashtable是否包含某个值value. 因为要遍历整个hashtable所以效率比containsKey()方法低</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.value.equals(value)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if this hashtable maps one or more keys to this value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this method is identical in functionality to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #contains contains&#125; (which predates the &#123;<span class="doctag">@link</span> Map&#125; interface).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value whose presence in this hashtable is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     *         specified value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException  if the value is &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;             <span class="comment">//Map接口的方法containsValue()</span></span><br><span class="line">        <span class="keyword">return</span> contains(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests if the specified object is a key in this hashtable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   key   possible key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if and only if the specified object</span></span><br><span class="line"><span class="comment">     *          is a key in this hashtable, as determined by the</span></span><br><span class="line"><span class="comment">     *          &lt;tt&gt;equals&lt;/tt&gt; method; &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  NullPointerException  if the key is &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #contains(Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//查看key是否在hashtable中只需要O(1), 而查看value需要O(n)</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key.equals(k))&#125;,</span></span><br><span class="line"><span class="comment">     * then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise it returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key whose associated value is to be returned</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value to which the specified key is mapped, or</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;       <span class="comment">//没有红黑树的hashtable就是比HashMap好理解.*^_^*</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;           <span class="comment">//直接用hashcode()方法得到的值当作hash值, 去掉最高位的符号位</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;           <span class="comment">//注意这里table的大小由于不是2的整数次幂, 只能用 % 来计算, 不能用位运算</span></span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (V)e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * The maximum size of array to allocate.                   //最大的table的size. 因为有些虚拟机在数组前面保留一些头部信息, 所以如果申请Integer.MAX_VALUE这样的大小会造成OOM</span></span><br><span class="line"><span class="comment">     * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">     * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">     * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity of and internally reorganizes this</span></span><br><span class="line"><span class="comment">     * hashtable, in order to accommodate and access its entries more</span></span><br><span class="line"><span class="comment">     * efficiently.  This method is called automatically when the</span></span><br><span class="line"><span class="comment">     * number of keys in the hashtable exceeds this hashtable&#x27;s capacity</span></span><br><span class="line"><span class="comment">     * and load factor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;                       <span class="comment">//这里重点来了, hashtable的扩容. 每次扩容都是 n -&gt; 2 * n + 1, 和HashMap不同</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">        Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;     <span class="comment">//扩容为 n -&gt; 2 * n + 1</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;     <span class="comment">//如果新的数组大小大于MAX_ARRAY_SIZE, 就设置为MAX_ARRAY_SIZE. 这里和HashMap的oldCapacity大于等于2 ^ 30就不进行扩容是一样的道理</span></span><br><span class="line">            <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">                <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        table = newMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;                              <span class="comment">//把旧的table中的entry转移到新的table中</span></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = old;</span><br><span class="line">                old = old.next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">                e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">                newMap[index] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;        <span class="comment">//这里和HashMap又有不同了</span></span><br><span class="line">        modCount++;                                                     <span class="comment">//Hashtable是先判断count是不是大于等于threshold, 是的话就resize. 最后再添加entry</span></span><br><span class="line">                                                                        <span class="comment">//HashMap是先添加entry, 再判断count是不是大于threshold, 是的话就resize</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">            rehash();</span><br><span class="line"></span><br><span class="line">            tab = table;</span><br><span class="line">            hash = key.hashCode();</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates the new entry.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];                          <span class="comment">//头插法, 而HashMap采用的是尾插法</span></span><br><span class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);                   <span class="comment">//这一行就是把新建的节点Entry节点放在头部, 剩下的一串节点e接在新建节点后面</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maps the specified &lt;code&gt;key&lt;/code&gt; to the specified</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;value&lt;/code&gt; in this hashtable. Neither the key nor the</span></span><br><span class="line"><span class="comment">     * value can be &lt;code&gt;null&lt;/code&gt;. &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method</span></span><br><span class="line"><span class="comment">     * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      key     the hashtable key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      value   the value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>     the previous value of the specified key in this hashtable,</span></span><br><span class="line"><span class="comment">     *             or &lt;code&gt;null&lt;/code&gt; if it did not have one</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  NullPointerException  if the key or value is</span></span><br><span class="line"><span class="comment">     *               &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     Object#equals(Object)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #get(Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;                              <span class="comment">//再一次说明了无论是key还是value都不能为null</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;            <span class="comment">//检查hashtable中是否有这个key, 有就修改, 没有就添加</span></span><br><span class="line">            <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                V old = entry.value;</span><br><span class="line">                entry.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the key (and its corresponding value) from this</span></span><br><span class="line"><span class="comment">     * hashtable. This method does nothing if the key is not in the hashtable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   key   the key that needs to be removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the value to which the key had been mapped in this hashtable,</span></span><br><span class="line"><span class="comment">     *          or &lt;code&gt;null&lt;/code&gt; if the key did not have a mapping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  NullPointerException  if the key is &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev.next = e.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies all of the mappings from the specified map to this hashtable.</span></span><br><span class="line"><span class="comment">     * These mappings will replace any mappings that this hashtable had for any</span></span><br><span class="line"><span class="comment">     * of the keys currently in the specified map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t mappings to be stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clears this hashtable so that it contains no keys.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = tab.length; --index &gt;= <span class="number">0</span>; )</span><br><span class="line">            tab[index] = <span class="keyword">null</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a shallow copy of this hashtable. All the structure of the</span></span><br><span class="line"><span class="comment">     * hashtable itself is copied, but the keys and values are not cloned.</span></span><br><span class="line"><span class="comment">     * This is a relatively expensive operation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a clone of the hashtable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Hashtable&lt;?,?&gt; t = (Hashtable&lt;?,?&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">            t.table = <span class="keyword">new</span> Entry&lt;?,?&gt;[table.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = table.length ; i-- &gt; <span class="number">0</span> ; ) &#123;</span><br><span class="line">                t.table[i] = (table[i] != <span class="keyword">null</span>)</span><br><span class="line">                    ? (Entry&lt;?,?&gt;) table[i].clone() : <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t.keySet = <span class="keyword">null</span>;</span><br><span class="line">            t.entrySet = <span class="keyword">null</span>;</span><br><span class="line">            t.values = <span class="keyword">null</span>;</span><br><span class="line">            t.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string representation of this &lt;tt&gt;Hashtable&lt;/tt&gt; object</span></span><br><span class="line"><span class="comment">     * in the form of a set of entries, enclosed in braces and separated</span></span><br><span class="line"><span class="comment">     * by the ASCII characters &quot;&lt;tt&gt;,&amp;nbsp;&lt;/tt&gt;&quot; (comma and space). Each</span></span><br><span class="line"><span class="comment">     * entry is rendered as the key, an equals sign &lt;tt&gt;=&lt;/tt&gt;, and the</span></span><br><span class="line"><span class="comment">     * associated element, where the &lt;tt&gt;toString&lt;/tt&gt; method is used to</span></span><br><span class="line"><span class="comment">     * convert the key and element to strings.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a string representation of this hashtable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (max == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            Map.Entry&lt;K,V&gt; e = it.next();</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            sb.append(key   == <span class="keyword">this</span> ? <span class="string">&quot;(this Map)&quot;</span> : key.toString());</span><br><span class="line">            sb.append(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            sb.append(value == <span class="keyword">this</span> ? <span class="string">&quot;(this Map)&quot;</span> : value.toString());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == max)</span><br><span class="line">                <span class="keyword">return</span> sb.append(<span class="string">&#x27;&#125;&#x27;</span>).toString();</span><br><span class="line">            sb.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Enumeration&lt;T&gt; <span class="title">getEnumeration</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;     <span class="comment">//new Enumerator&lt;&gt;(type, false)这里表示返回type类型的Enumerator迭代器. 如果第二个参数是true的话返回Iterator迭代器</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;                                     <span class="comment">//第一个参数代表迭代的是什么, type = KEYS代表迭代的是key迭代器, VALUES代表是values迭代器, ENTRIES代表entry迭代器</span></span><br><span class="line">            <span class="keyword">return</span> Collections.emptyEnumeration();            <span class="comment">//所以keySet()用的是key迭代器, values()用的是values迭代器, entrySet()用的是entry迭代器</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">false</span>);        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">getIterator</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyIterator();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Views</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Each of these fields are initialized to contain an instance of the</span></span><br><span class="line"><span class="comment">     * appropriate view the first time this view is requested.  The views are</span></span><br><span class="line"><span class="comment">     * stateless, so there&#x27;s no reason to create more than one of each.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt; keySet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the keys contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of</span></span><br><span class="line"><span class="comment">     * the iteration are undefined.  The set supports element removal,</span></span><br><span class="line"><span class="comment">     * which removes the corresponding mapping from the map, via the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keySet == <span class="keyword">null</span>)</span><br><span class="line">            keySet = Collections.synchronizedSet(<span class="keyword">new</span> KeySet(), <span class="keyword">this</span>);  <span class="comment">// 返回的keySet要经过Collections.synchronizedSet()包装, 下面的valueCollection和entrySet同理</span></span><br><span class="line">        <span class="keyword">return</span> keySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;          <span class="comment">//内部类, 有外围类的引用, 所以可以直接操作hashtable的元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getIterator(KEYS);           <span class="comment">//KEYS代表key迭代器, 下面的valueCollection和entrySet同理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.remove(o) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Hashtable.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the mappings contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</span></span><br><span class="line"><span class="comment">     * iterator) the results of the iteration are undefined.  The set</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        <span class="keyword">if</span> (entrySet==<span class="keyword">null</span>)</span><br><span class="line">            entrySet = Collections.synchronizedSet(<span class="keyword">new</span> EntrySet(), <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> entrySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> getIterator(ENTRIES);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Map.Entry&lt;K,V&gt; o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.add(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;      <span class="comment">//注意这里不是Hashtable的contains()方法, 而是检查entrySet中有没有一个给定的 Map.Entry&lt;?,?&gt;对象</span></span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            Object key = entry.getKey();</span><br><span class="line">            Entry&lt;?,?&gt;[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">            <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                <span class="keyword">if</span> (e.hash==hash &amp;&amp; e.equals(entry))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;          <span class="comment">//通过entrySet的方法移除某个Map.Entry&lt;?,?&gt;对象, 原来的hashtable中也会移除这个对象</span></span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = entry.getKey();</span><br><span class="line">            Entry&lt;?,?&gt;[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">            <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">            <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>; prev = e, e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash==hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">                    modCount++;                                <span class="comment">//内部类操作外围类对象的modCount实例域.</span></span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>)</span><br><span class="line">                        prev.next = e.next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        tab[index] = e.next;</span><br><span class="line"></span><br><span class="line">                    count--;</span><br><span class="line">                    e.value = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Hashtable.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Collection&#125; view of the values contained in this map.</span></span><br><span class="line"><span class="comment">     * The collection is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the collection, and vice-versa.  If the map is</span></span><br><span class="line"><span class="comment">     * modified while an iteration over the collection is in progress</span></span><br><span class="line"><span class="comment">     * (except through the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation),</span></span><br><span class="line"><span class="comment">     * the results of the iteration are undefined.  The collection</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not</span></span><br><span class="line"><span class="comment">     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (values==<span class="keyword">null</span>)</span><br><span class="line">            values = Collections.synchronizedCollection(<span class="keyword">new</span> ValueCollection(),</span><br><span class="line">                                                        <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueCollection</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getIterator(VALUES);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> containsValue(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Hashtable.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Comparison and hashing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares the specified Object with this Map for equality,</span></span><br><span class="line"><span class="comment">     * as per the definition in the Map interface.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  o object to be compared for equality with this hashtable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the specified Object is equal to this Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Map#equals(Object)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;         <span class="comment">//检查两个map是不是相等, 当且仅当两个map的size相等, 并且当前map的每个映射都能在map o中找到</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;?,?&gt; t = (Map&lt;?,?&gt;) o;</span><br><span class="line">        <span class="keyword">if</span> (t.size() != size())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                Map.Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;                                    <span class="comment">//我个人认为这个if不会进入. 因为hashtable不允许key或value为null</span></span><br><span class="line">                    <span class="keyword">if</span> (!(t.get(key)==<span class="keyword">null</span> &amp;&amp; t.containsKey(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!value.equals(t.get(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException unused)   &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the hash code value for this Map as per the definition in the</span></span><br><span class="line"><span class="comment">     * Map interface.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Map#hashCode()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This code detects the recursion caused by computing the hash code</span></span><br><span class="line"><span class="comment">         * of a self-referential hash table and prevents the stack overflow</span></span><br><span class="line"><span class="comment">         * that would otherwise result.  This allows certain 1.1-era</span></span><br><span class="line"><span class="comment">         * applets with self-referential hash tables to work.  This code</span></span><br><span class="line"><span class="comment">         * abuses the loadFactor field to do double-duty as a hashCode</span></span><br><span class="line"><span class="comment">         * in progress flag, so as not to worsen the space performance.</span></span><br><span class="line"><span class="comment">         * A negative load factor indicates that hash code computation is</span></span><br><span class="line"><span class="comment">         * in progress.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span> || loadFactor &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> h;  <span class="comment">// Returns zero</span></span><br><span class="line"></span><br><span class="line">        loadFactor = -loadFactor;  <span class="comment">// Mark hashCode computation in progress</span></span><br><span class="line">        Entry&lt;?,?&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; entry : tab) &#123;</span><br><span class="line">            <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                h += entry.hashCode();</span><br><span class="line">                entry = entry.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        loadFactor = -loadFactor;  <span class="comment">// Mark hashCode computation complete</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">        V result = get(key);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == result) ? defaultValue : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);     <span class="comment">// explicit check required in case</span></span><br><span class="line">                                            <span class="comment">// table is empty.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Entry&lt;?, ?&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : tab) &#123;</span><br><span class="line">            <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                action.accept((K)entry.key, (V)entry.value);</span><br><span class="line">                entry = entry.next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(function);     <span class="comment">// explicit check required in case</span></span><br><span class="line">                                              <span class="comment">// table is empty.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Entry&lt;K, V&gt;[] tab = (Entry&lt;K, V&gt;[])table;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : tab) &#123;</span><br><span class="line">            <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry.value = Objects.requireNonNull(</span><br><span class="line">                    function.apply(entry.key, entry.value));</span><br><span class="line">                entry = entry.next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span> (; entry != <span class="keyword">null</span>; entry = entry.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                V old = entry.value;</span><br><span class="line">                <span class="keyword">if</span> (old == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    entry.value = value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(value);</span><br><span class="line"></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>; prev = e, e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key) &amp;&amp; e.value.equals(value)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev.next = e.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(oldValue);</span><br><span class="line">        Objects.requireNonNull(newValue);</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span> (; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.value.equals(oldValue)) &#123;</span><br><span class="line">                    e.value = newValue;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(value);</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span> (; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(mappingFunction);</span><br><span class="line"></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span> (; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="comment">// Hashtable not accept null value</span></span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V newValue = mappingFunction.apply(key);</span><br><span class="line">        <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            addEntry(hash, key, newValue, index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">computeIfPresent</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(remappingFunction);</span><br><span class="line"></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>; prev = e, e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                V newValue = remappingFunction.apply(key, e.value);</span><br><span class="line">                <span class="keyword">if</span> (newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    modCount++;</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prev.next = e.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tab[index] = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    e.value = newValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> newValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(remappingFunction);</span><br><span class="line"></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>; prev = e, e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; Objects.equals(e.key, key)) &#123;</span><br><span class="line">                V newValue = remappingFunction.apply(key, e.value);</span><br><span class="line">                <span class="keyword">if</span> (newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    modCount++;</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prev.next = e.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tab[index] = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    e.value = newValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> newValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V newValue = remappingFunction.apply(key, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            addEntry(hash, key, newValue, index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">merge</span><span class="params">(K key, V value, BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(remappingFunction);</span><br><span class="line"></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>; prev = e, e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                V newValue = remappingFunction.apply(e.value, value);</span><br><span class="line">                <span class="keyword">if</span> (newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    modCount++;</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prev.next = e.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tab[index] = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    e.value = newValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> newValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            addEntry(hash, key, value, index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Save the state of the Hashtable to a stream (i.e., serialize it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> The &lt;i&gt;capacity&lt;/i&gt; of the Hashtable (the length of the</span></span><br><span class="line"><span class="comment">     *             bucket array) is emitted (int), followed by the</span></span><br><span class="line"><span class="comment">     *             &lt;i&gt;size&lt;/i&gt; of the Hashtable (the number of key-value</span></span><br><span class="line"><span class="comment">     *             mappings), followed by the key (Object) and value (Object)</span></span><br><span class="line"><span class="comment">     *             for each key-value mapping represented by the Hashtable</span></span><br><span class="line"><span class="comment">     *             The key-value mappings are emitted in no particular order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//之前一直好奇writeObject和readObject方法是怎么回事, 是private的并且没有public方法调用他们. 如果写这两个方法是为了ObjectInputStream或ObjectOutputStream使用, 那也不对啊.</span></span><br><span class="line"><span class="comment">//这两个流使用序列化的时候是ObjectInputStream类中的方法 ObjectInputStream in = new ObjectInputStream(); in.readObject();</span></span><br><span class="line"><span class="comment">// 而不是HashMap类中的方法HashMap map = new HashMap(); map.readObject(in);</span></span><br><span class="line"><span class="comment">//后来上网查了资料 https://zhuanlan.zhihu.com/p/84533476 才发现ObjectInputStream类中的readObject方法也是通过反射看看被写入的类中有没有实现.</span></span><br><span class="line"><span class="comment">//实际上在ObjectOutputStream中进行序列化操作的时候，会判断被序列化的对象是否自己重写了writeObject方法，如果重写了，就会调用被序列化对象自己的writeObject方法，如果没有重写，才会调用默认的序列化方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Entry&lt;Object, Object&gt; entryStack = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Write out the threshold and loadFactor</span></span><br><span class="line">            s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write out the length and count of elements</span></span><br><span class="line">            s.writeInt(table.length);</span><br><span class="line">            s.writeInt(count);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Stack copies of the entries in the table</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; table.length; index++) &#123;        <span class="comment">//先把所有的Entry变成链表, 然后再write</span></span><br><span class="line">                Entry&lt;?,?&gt; entry = table[index];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    entryStack =</span><br><span class="line">                        <span class="keyword">new</span> Entry&lt;&gt;(<span class="number">0</span>, entry.key, entry.value, entryStack);</span><br><span class="line">                    entry = entry.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out the key/value objects from the stacked entries</span></span><br><span class="line">        <span class="keyword">while</span> (entryStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.writeObject(entryStack.key);</span><br><span class="line">            s.writeObject(entryStack.value);</span><br><span class="line">            entryStack = entryStack.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitute the Hashtable from a stream (i.e., deserialize it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold and loadFactor</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate loadFactor (ignore threshold - it will be re-computed)</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(<span class="string">&quot;Illegal Load: &quot;</span> + loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the original length of the array and number of elements</span></span><br><span class="line">        <span class="keyword">int</span> origlength = s.readInt();</span><br><span class="line">        <span class="keyword">int</span> elements = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate # of elements</span></span><br><span class="line">        <span class="keyword">if</span> (elements &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(<span class="string">&quot;Illegal # of Elements: &quot;</span> + elements);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clamp original length to be more than elements / loadFactor</span></span><br><span class="line">        <span class="comment">// (this is the invariant enforced with auto-growth)</span></span><br><span class="line">        origlength = Math.max(origlength, (<span class="keyword">int</span>)(elements / loadFactor) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute new length with a bit of room 5% + 3 to grow but</span></span><br><span class="line">        <span class="comment">// no larger than the clamped original length.  Make the length</span></span><br><span class="line">        <span class="comment">// odd if it&#x27;s large enough, this helps distribute the entries.</span></span><br><span class="line">        <span class="comment">// Guard against the length ending up zero, that&#x27;s not valid.</span></span><br><span class="line">        <span class="keyword">int</span> length = (<span class="keyword">int</span>)((elements + elements / <span class="number">20</span>) / loadFactor) + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; elements &amp;&amp; (length &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            length--;</span><br><span class="line">        length = Math.min(length, origlength);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">            length = origlength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span></span><br><span class="line">        <span class="comment">// what we&#x27;re actually creating.</span></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, length);</span><br><span class="line">        table = <span class="keyword">new</span> Entry&lt;?,?&gt;[length];</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(length * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the number of elements and then all the key/value objects</span></span><br><span class="line">        <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                K key = (K)s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                V value = (V)s.readObject();</span><br><span class="line">            <span class="comment">// sync is eliminated for performance</span></span><br><span class="line">            reconstitutionPut(table, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The put method used by readObject. This is provided because put</span></span><br><span class="line"><span class="comment">     * is overridable and should not be called in readObject since the</span></span><br><span class="line"><span class="comment">     * subclass will not yet be initialized.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This differs from the regular put method in several ways. No</span></span><br><span class="line"><span class="comment">     * checking for rehashing is necessary since the number of elements</span></span><br><span class="line"><span class="comment">     * initially in the table is known. The modCount is not incremented and</span></span><br><span class="line"><span class="comment">     * there&#x27;s no synchronization because we are creating a new instance.</span></span><br><span class="line"><span class="comment">     * Also, no return value is needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> StreamCorruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        <span class="comment">// This should not happen in deserialized version.</span></span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Creates the new entry.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hashtable bucket collision list entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;            <span class="comment">//每个节点的实现类Entry, 和HashMap中的Node类差不多</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key =  key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value,</span><br><span class="line">                                  (next==<span class="keyword">null</span> ? <span class="keyword">null</span> : (Entry&lt;K,V&gt;) next.clone()));       <span class="comment">//递归地调用clone()</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map.Entry Ops                            //下面就是Hashtable.Entry类一些简单的方法了</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">            V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (key==<span class="keyword">null</span> ? e.getKey()==<span class="keyword">null</span> : key.equals(e.getKey())) &amp;&amp;</span><br><span class="line">               (value==<span class="keyword">null</span> ? e.getValue()==<span class="keyword">null</span> : value.equals(e.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hash ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key.toString()+<span class="string">&quot;=&quot;</span>+value.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Types of Enumerations/Iterations</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEYS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUES = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTRIES = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A hashtable enumerator class.  This class implements both the</span></span><br><span class="line"><span class="comment">     * Enumeration and Iterator interfaces, but individual instances</span></span><br><span class="line"><span class="comment">     * can be created with the Iterator methods disabled.  This is necessary</span></span><br><span class="line"><span class="comment">     * to avoid unintentionally increasing the capabilities granted a user</span></span><br><span class="line"><span class="comment">     * by passing an Enumeration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">T</span>&gt;, <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;    <span class="comment">//迭代器类, 遍历keySet(), values(), entrySet()就相当于通过Enumerator遍历hashtable</span></span><br><span class="line">        Entry&lt;?,?&gt;[] table = Hashtable.<span class="keyword">this</span>.table;</span><br><span class="line">        <span class="keyword">int</span> index = table.length;                                          <span class="comment">//index储存了当前所在的桶, 如果当前的桶遍历完了, 就该开始遍历第index-1个桶了. 从最后一个桶开始遍历. 这里和HashMap不一样, hashmap是从第一个桶开始遍历</span></span><br><span class="line">        Entry&lt;?,?&gt; entry;                                                 <span class="comment">//entry储存了即将要遍历的元素, next()或nextElement()会返回entry的, 同时entry变为链表的下一个元素</span></span><br><span class="line">        Entry&lt;?,?&gt; lastReturned;                                          <span class="comment">//如果entry是null, entry就要变为前面一个桶中的第一个元素了</span></span><br><span class="line">        <span class="keyword">int</span> type;                                                         <span class="comment">//lastReturned记录了上一次的next()返回的值, remove()方法就是删除lastReturned.</span></span><br><span class="line">                                                                          <span class="comment">// type是标识keySet(), values(), entrySet()中的哪一个用的</span></span><br><span class="line">        <span class="comment">/**                                                               </span></span><br><span class="line"><span class="comment">         * Indicates whether this Enumerator is serving as an Iterator</span></span><br><span class="line"><span class="comment">         * or an Enumeration.  (true -&gt; Iterator).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> iterator;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * Hashtable should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> expectedModCount = modCount;           <span class="comment">//如果在遍历过程中, 出现了迭代器外面的改变结构, 就会引发异常</span></span><br><span class="line"></span><br><span class="line">        Enumerator(<span class="keyword">int</span> type, <span class="keyword">boolean</span> iterator) &#123;</span><br><span class="line">            <span class="keyword">this</span>.type = type;</span><br><span class="line">            <span class="keyword">this</span>.iterator = iterator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;             <span class="comment">//检查是否还有下一个元素</span></span><br><span class="line">            Entry&lt;?,?&gt; e = entry;                        <span class="comment">//entry是下一次调用next()方法要返回的值. 如果entry为空, 就要换一个桶</span></span><br><span class="line">            <span class="keyword">int</span> i = index;</span><br><span class="line">            Entry&lt;?,?&gt;[] t = table;</span><br><span class="line">            <span class="comment">/* Use locals for faster loop iteration */</span></span><br><span class="line">            <span class="keyword">while</span> (e == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;                <span class="comment">//如果entry为null, 说明这一个bucket遍历完了, 需要找前面一个bucket</span></span><br><span class="line">                e = t[--i];                             <span class="comment">//这里是从后向前遍历的. 第0个桶最后遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">            entry = e;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">return</span> e != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">nextElement</span><span class="params">()</span> </span>&#123;                              <span class="comment">// 和 hasMoreElements()方法差不多, 只不过需要在返回前更新一下entry, entry = e.next;</span></span><br><span class="line">            Entry&lt;?,?&gt; et = entry;                            <span class="comment">// 保证entry始终指向即将要遍历的元素</span></span><br><span class="line">            <span class="keyword">int</span> i = index;</span><br><span class="line">            Entry&lt;?,?&gt;[] t = table;</span><br><span class="line">            <span class="comment">/* Use locals for faster loop iteration */</span></span><br><span class="line">            <span class="keyword">while</span> (et == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                et = t[--i];</span><br><span class="line">            &#125;</span><br><span class="line">            entry = et;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">if</span> (et != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;?,?&gt; e = lastReturned = entry;</span><br><span class="line">                entry = e.next;</span><br><span class="line">                <span class="keyword">return</span> type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); <span class="comment">//根据参数type判断是key迭代器还是value迭代器还是entry迭代器</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;Hashtable Enumerator&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterator methods</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hasMoreElements();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">return</span> nextElement();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;              <span class="comment">//删除 lastReturned</span></span><br><span class="line">            <span class="keyword">if</span> (!iterator)                 <span class="comment">//Enumeration不支持删除</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Hashtable Enumerator&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span>(Hashtable.<span class="keyword">this</span>) &#123;      <span class="comment">//外围类.this 表示内部类指向外围类的指针对应的对象, 即锁住hashtable这个对象</span></span><br><span class="line">                Entry&lt;?,?&gt;[] tab = Hashtable.<span class="keyword">this</span>.table;</span><br><span class="line">                <span class="keyword">int</span> index = (lastReturned.hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">                <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>; prev = e, e = e.next) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e == lastReturned) &#123;</span><br><span class="line">                        modCount++;</span><br><span class="line">                        expectedModCount++;</span><br><span class="line">                        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">                            tab[index] = e.next;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            prev.next = e.next;</span><br><span class="line">                        count--;</span><br><span class="line">                        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.ArrayList阅读笔记</title>
    <url>/2020/12/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java.util.ArrayList%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="ArrayList阅读笔记"><a href="#ArrayList阅读笔记" class="headerlink" title="ArrayList阅读笔记"></a>ArrayList阅读笔记</h2><p>这是我阅读的第3个源码类, mark一下吧.</p>
<p>建议如果阅读代码中的笔记, 将下面的代码块拷贝到vs code或idea上. 因为在markdown的代码块中宽度有限制, 会影响观看效果.</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"><span class="keyword">import</span> sun.misc.SharedSecrets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resizable-array implementation of the &lt;tt&gt;List&lt;/tt&gt; interface.  Implements</span></span><br><span class="line"><span class="comment"> * all optional list operations, and permits all elements, including           //允许存储null</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;null&lt;/tt&gt;.  In addition to implementing the &lt;tt&gt;List&lt;/tt&gt; interface,</span></span><br><span class="line"><span class="comment"> * this class provides methods to manipulate the size of the array that is    // 提供方法可以改变内部数组的大小</span></span><br><span class="line"><span class="comment"> * used internally to store the list.  (This class is roughly equivalent to</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Vector&lt;/tt&gt;, except that it is unsynchronized.)                        // 不是线程安全的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &lt;tt&gt;size&lt;/tt&gt;, &lt;tt&gt;isEmpty&lt;/tt&gt;, &lt;tt&gt;get&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;iterator&lt;/tt&gt;, and &lt;tt&gt;listIterator&lt;/tt&gt; operations run in constant</span></span><br><span class="line"><span class="comment"> * time.  The &lt;tt&gt;add&lt;/tt&gt; operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;,         //add方法可以摊销为O(1)时间, </span></span><br><span class="line"><span class="comment"> * that is, adding n elements requires O(n) time.  All of the other operations</span></span><br><span class="line"><span class="comment"> * run in linear time (roughly speaking).  The constant factor is low compared      // 复杂度前面的常数要比LinkedList小. 这里有疑问, 两者相同的方法有的是O(1), 有的是O(n). 怎么比较呢? </span></span><br><span class="line"><span class="comment"> * to that for the &lt;tt&gt;LinkedList&lt;/tt&gt; implementation.                              // 个人推测这是方法都为O(1)时候的比较, 比如add和remove</span></span><br><span class="line"><span class="comment"> *                                                                                  // https://issues.apache.org/jira/browse/HIVE-18343 在HIVE的网站上也说移除了LinkedList. </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Each &lt;tt&gt;ArrayList&lt;/tt&gt; instance has a &lt;i&gt;capacity&lt;/i&gt;.  The capacity is      // 并标粗了&quot;The constant factor is low compared to that for the LinkedList implementation.&quot;这一句话</span></span><br><span class="line"><span class="comment"> * the size of the array used to store the elements in the list.  It is always      // 在我自己的测试中, LinkedList add() 100万次数据花费了0.15秒, 而ArrayList add() 100万次数据花费了0.07秒</span></span><br><span class="line"><span class="comment"> * at least as large as the list size.  As elements are added to an ArrayList,      // 数据量大的时候就更明显了, LinkedList add() 1亿次数据花费了20秒, 而ArrayList add() 1亿次数据只花费了5秒</span></span><br><span class="line"><span class="comment"> * its capacity grows automatically.  The details of the growth policy are not      // 个人推测是链表加入数据的时候要不断地执行 new. 需要频繁申请内存, 导致的效率低</span></span><br><span class="line"><span class="comment"> * specified beyond the fact that adding an element has constant amortized</span></span><br><span class="line"><span class="comment"> * time cost.                                                         //capacity变量为内部数组的长度, size变量是实际存储元素的个数, 并且 capacity &gt;= size</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An application can increase the capacity of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance    //可以外部的通过ensureCapacity增大capacity, 避免多次自动扩容, 降低扩容次数</span></span><br><span class="line"><span class="comment"> * before adding a large number of elements using the &lt;tt&gt;ensureCapacity&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * operation.  This may reduce the amount of incremental reallocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;           //又是老问题了, 并发修改问题, 还是加锁</span></span><br><span class="line"><span class="comment"> * If multiple threads access an &lt;tt&gt;ArrayList&lt;/tt&gt; instance concurrently,</span></span><br><span class="line"><span class="comment"> * and at least one of the threads modifies the list structurally, it</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;must&lt;/i&gt; be synchronized externally.  (A structural modification is</span></span><br><span class="line"><span class="comment"> * any operation that adds or deletes one or more elements, or explicitly</span></span><br><span class="line"><span class="comment"> * resizes the backing array; merely setting the value of an element is not</span></span><br><span class="line"><span class="comment"> * a structural modification.)  This is typically accomplished by</span></span><br><span class="line"><span class="comment"> * synchronizing on some object that naturally encapsulates the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If no such object exists, the list should be &quot;wrapped&quot; using the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Collections#synchronizedList Collections.synchronizedList&#125;</span></span><br><span class="line"><span class="comment"> * method.  This is best done at creation time, to prevent accidental</span></span><br><span class="line"><span class="comment"> * unsynchronized access to the list:&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *   List list = Collections.synchronizedList(new ArrayList(...));&lt;/pre&gt;          //通过Collections包装为线程安全集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;a name=&quot;fail-fast&quot;&gt;</span></span><br><span class="line"><span class="comment"> * The iterators returned by this class&#x27;s &#123;<span class="doctag">@link</span> #iterator() iterator&#125; and       //和其他的Collection不一样, List提供了更多的迭代器功能listIterator. 可以指定开始迭代的位置</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #listIterator(int) listIterator&#125; methods are &lt;em&gt;fail-fast&lt;/em&gt;:&lt;/a&gt;   //并且可以反向迭代, 也可以添加元素. </span></span><br><span class="line"><span class="comment"> * if the list is structurally modified at any time after the iterator is        //但是迭代器使用起来感觉还是不如C++STL的迭代器好用. 指针风格的迭代器就是比流风格的迭代器好用.</span></span><br><span class="line"><span class="comment"> * created, in any way except through the iterator&#x27;s own</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ListIterator#remove() remove&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ListIterator#add(Object) add&#125; methods, the iterator will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of</span></span><br><span class="line"><span class="comment"> * concurrent modification, the iterator fails quickly and cleanly, rather</span></span><br><span class="line"><span class="comment"> * than risking arbitrary, non-deterministic behavior at an undetermined</span></span><br><span class="line"><span class="comment"> * time in the future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span></span><br><span class="line"><span class="comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span></span><br><span class="line"><span class="comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span></span><br><span class="line"><span class="comment"> * throw &#123;<span class="doctag">@code</span> ConcurrentModificationException&#125; on a best-effort basis.</span></span><br><span class="line"><span class="comment"> * Therefore, it would be wrong to write a program that depended on this</span></span><br><span class="line"><span class="comment"> * exception for its correctness:  &lt;i&gt;the fail-fast behavior of iterators</span></span><br><span class="line"><span class="comment"> * should be used only to detect bugs.&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Neal Gafter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     List</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     LinkedList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;             <span class="comment">//默认容量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;        <span class="comment">// 静态数组, 如果使用 new ArrayList(0)创建数组, 创建的时候就会令elementData = EMPTY_ELEMENTDATA</span></span><br><span class="line">                                                                 <span class="comment">//等到真正添加第一个元素的时候再创建个容量不为0的数组</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;   <span class="comment">//静态数组, 如果使用 new ArrayList()创建数组, 创建的时候就会令elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">                                                                            <span class="comment">// 为什么要与EMPTY_ELEMENTDATA区分的原因是第一个添加元素时候要重新申请空间. </span></span><br><span class="line">    <span class="comment">/**                                                                     //如果是空参构造器, 就new一个DEFAULT_CAPACITY大小的数组. 反之</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access  // 不是私有的, 方便内部类访问. 但是感觉即使是私有的内部类也能访问的到啊. 这里存疑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">     *         is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];                   <span class="comment">//如果指定容量并且容量不为0, 直接在构造器中创建. 不延迟创建</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;                                   <span class="comment">//如果指定容量为0, 就先用EMPTY_ELEMENTDATA代替. 真正加入元素的时候再创建</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;             <span class="comment">//如果没有指定容量, 就先用DEFAULTCAPACITY_EMPTY_ELEMENTDATA代替. 真正加入元素的时候再创建</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection&#x27;s</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;                      <span class="comment">//ArrayList(Collection&lt;? extends E&gt; c)底层也用了Arrays.copyOf方法</span></span><br><span class="line">        elementData = c.toArray();                                     <span class="comment">//Arrays.copyOf方法底层用了System.arraycopy方法</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)   // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)                        // 简单的说, 就是, 按照标准, 每个集合c的c.toArray()方法应该和c.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>])返回类型相同, 都为Object[]</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);  // 但是, Arrays.asList(T ... a)方法生成的集合的toArray()方法并不是返回Object[]. 而是T[].</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                                                 <span class="comment">// Object[] list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).toArray(); System.out.println(list.getClass() == Object[].class); 返回false</span></span><br><span class="line">            <span class="comment">// replace with empty array.                                         // Object[] list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).toArray(); System.out.println(list.getClass() == String[].class); 返回true</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;                                <span class="comment">// 即如果使用了 List&lt;?&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)); 会使得elementData持有String[]的数据类型. 虽然引用类型还是Object[].</span></span><br><span class="line">        &#125;                                                                        <span class="comment">// 即相当于Object[] elementData = new String[]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;; 这在之后的处理过程中可能会出现问题</span></span><br><span class="line">    &#125;                                                                            <span class="comment">// 这个问题仅在jdk8或之前的版本中存在, 亲测jdk8有这个问题而jdk11没有 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the</span></span><br><span class="line"><span class="comment">     * list&#x27;s current size.  An application can use this operation to minimize</span></span><br><span class="line"><span class="comment">     * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance.</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;                       <span class="comment">//将为了扩容申请的多余的空间释放掉</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if</span></span><br><span class="line"><span class="comment">     * necessary, to ensure that it can hold at least the number of elements</span></span><br><span class="line"><span class="comment">     * specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span>                                                                      <span class="comment">// 这个方法是提供外部调用的. ArrayList内部没有使用过这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;                            <span class="comment">//确保底层数组中可以容纳至少minCapacity个元素</span></span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)   <span class="comment">//如果底层数组等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">            <span class="comment">// any size if not default element table                         //说明用了空参构造器new的这个ArrayList. 并且还没有添加元素. 此时将minExpand置为DEFAULT_CAPACITY, 否则就是0</span></span><br><span class="line">            ? <span class="number">0</span>                                                              <span class="comment">// 然后minExpand和minCapacity比较, 如果minCapacity大, 数组就要增长到至少minCapacity. 调用ensureExplicitCapacity方法看看实际长度是不是满足要求, 如果不满足要求, 调用grow扩容</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It&#x27;s already     // 如果minCapacity &lt;= minExpand, 这种情况只可能发生在用了空参构造器new的这个ArrayList. 并且还没有添加元素的情况下</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.                               // 就不用计算该扩容到多大了, 直接初始化为DEFAULT_CAPACITY即可</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)     <span class="comment">//不知道为什么这里要写成 a - b &gt; 0的形式, 感觉 a &gt; b 这样写更好吧</span></span><br><span class="line">            grow(minCapacity);                        <span class="comment">//个人推测这里是将两者看成无符号整型来做判断的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">     * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">     * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">     * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;      <span class="comment">//和Hashtable一样, 因为有一些头部字段所以最大为INT_MAX - 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;                                                  <span class="comment">//这个grow才是真正的扩容方法. 前面的那几个都是在计算该扩容到多大</span></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);          <span class="comment">// 以1.5倍扩容</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)                           <span class="comment">// 先试一试扩容到1.5倍, 如果扩容1.5倍还是满足不了要求, 就不每次都乘1.5直到满足要求了</span></span><br><span class="line">            newCapacity = minCapacity;                               <span class="comment">// 而是直接取新的容量为minCapacity. 即minCapacity = 20, 初始容量为10. ensureExplicitCapacity中发现minCapacity &gt; 10, 决定调用grow()扩容</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)                        <span class="comment">// grow()先是计算了当前容量乘1.5, 为15, 发现15仍然比20小, 这时候就不再次乘1.5和20比较了, 而是直接扩容到20</span></span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);                 <span class="comment">//这里的newCapacity是有可能比MAX_ARRAY_SIZE大的, 介于INT_MAX - 8到 INT_MAX之间</span></span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:   // 所以MAX_ARRAY_SIZE不一定是arraylist的最大长度, 最大能达到的长度为INT_MAX</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow                  // 考虑了溢出, 例如 2147483647 + 1 = -2147483648</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of elements in this list.           //下面的这几个方法比较简单, 就不一一解释了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of elements in this list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element.</span></span><br><span class="line"><span class="comment">     * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains</span></span><br><span class="line"><span class="comment">     * at least one element &lt;tt&gt;e&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element whose presence in this list is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the index of the first occurrence of the specified element</span></span><br><span class="line"><span class="comment">     * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment">     * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the index of the last occurrence of the specified element</span></span><br><span class="line"><span class="comment">     * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment">     * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance.  (The</span></span><br><span class="line"><span class="comment">     * elements themselves are not copied.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();        <span class="comment">//这里的父类的clone方法其实是Object的clone方法. 因为它的父类AbstractList, AbstractCollection都没有重写clone方法</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);     <span class="comment">// 而Object的clone方法是个native方法, 具体做了些什么我也不知道. </span></span><br><span class="line">            v.modCount = <span class="number">0</span>;                                       <span class="comment">// 这里我就简单理解为 new了一个ArrayList&lt;?&gt;对象v, 再给v的数组复制过去</span></span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array containing all of the elements in this list</span></span><br><span class="line"><span class="comment">     * in proper sequence (from first to last element).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are</span></span><br><span class="line"><span class="comment">     * maintained by this list.  (In other words, this method must allocate</span></span><br><span class="line"><span class="comment">     * a new array).  The caller is thus free to modify the returned array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method acts as bridge between array-based and collection-based</span></span><br><span class="line"><span class="comment">     * APIs.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array containing all of the elements in this list in</span></span><br><span class="line"><span class="comment">     *         proper sequence</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);          <span class="comment">//返回的是Object[], 不能被强制转换为T[]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array containing all of the elements in this list in proper</span></span><br><span class="line"><span class="comment">     * sequence (from first to last element); the runtime type of the returned</span></span><br><span class="line"><span class="comment">     * array is that of the specified array.  If the list fits in the</span></span><br><span class="line"><span class="comment">     * specified array, it is returned therein.  Otherwise, a new array is</span></span><br><span class="line"><span class="comment">     * allocated with the runtime type of the specified array and the size of</span></span><br><span class="line"><span class="comment">     * this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the list fits in the specified array with room to spare</span></span><br><span class="line"><span class="comment">     * (i.e., the array has more elements than the list), the element in</span></span><br><span class="line"><span class="comment">     * the array immediately following the end of the collection is set to</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;null&lt;/tt&gt;.  (This is useful in determining the length of the</span></span><br><span class="line"><span class="comment">     * list &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain</span></span><br><span class="line"><span class="comment">     * any null elements.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a the array into which the elements of the list are to</span></span><br><span class="line"><span class="comment">     *          be stored, if it is big enough; otherwise, a new array of the</span></span><br><span class="line"><span class="comment">     *          same runtime type is allocated for this purpose.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array containing the elements of the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ArrayStoreException if the runtime type of the specified array</span></span><br><span class="line"><span class="comment">     *         is not a supertype of the runtime type of every element in</span></span><br><span class="line"><span class="comment">     *         this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified array is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;                       <span class="comment">//以null作为结束的标准, 很贴心的设计嘛 (*^_^*)</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  index index of the element to return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);               <span class="comment">// get方法有范围检查</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the element at the specified position in this list with</span></span><br><span class="line"><span class="comment">     * the specified element.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;     <span class="comment">// set方法有范围检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**                                                                   //这里有必要理一下add扩容思路.</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.             // 1. 如果是使用无参构造器构造的, 并且这是第一次添加元素</span></span><br><span class="line"><span class="comment">     *                                                                    // 2. 那么ensureCapacityInternal方法会调用calculateCapacity方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list                       // 3. 在calculateCapacity中, elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA成立, 并且第一次add不会使得size + 1超过10</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)     // 4. 所以选取默认的10作为ensureExplicitCapacity方法的参数, 也即grow方法的参数</span></span><br><span class="line"><span class="comment">     */</span>                                                                   <span class="comment">// 5. grow方法中, oldcapacity为0, 所以乘1.5倍仍然小于10, 所以直接创建一个10的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;                                             <span class="comment">// 6. 如果不是第一次添加元素, 或者不是使用无参构造器构造的, 这时候elementData肯定不等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!       // 7. 所以ensureCapacityInternal(size+1)就等价于ensureExplicitCapacity(size+1)</span></span><br><span class="line">        elementData[size++] = e;                                          <span class="comment">// 8. 如果size + 1小于等于现有的数组长度, 就不grow了. 反之, 还是要调用grow函数扩容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;                  <span class="comment">//插入的时候n个元素有n+1个插入点(0到n). </span></span><br><span class="line">        rangeCheckForAdd(index);                             <span class="comment">//0代表在第0个元素前插入(push_front), size代表在第size-1个元素后插入(push_back)</span></span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,     <span class="comment">//移动后面位置的元素</span></span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment">     * indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;                              <span class="comment">//同样, 和HashMap一样, add会触发扩容, 但是remove不会缩容. 但是array list可以手动调用trimToSize来实现缩容的目的</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment">     * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment">     * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment">     * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment">     * changed as a result of the call).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;                  <span class="comment">//之前想过一个有趣的问题, 如果是一个Integer List, 那么list.remove(1)是移除第1个元素呢, 还是移除值为1的元素呢?</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;                               <span class="comment">//经测试, list.remove(1)是移除第1个元素, list.remove(new Integer(1))是移除值为1的第一个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment">     * be empty after this call returns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment">     * this list, in the order that they are returned by the</span></span><br><span class="line"><span class="comment">     * specified collection&#x27;s Iterator.  The behavior of this operation is</span></span><br><span class="line"><span class="comment">     * undefined if the specified collection is modified while the operation</span></span><br><span class="line"><span class="comment">     * is in progress.  (This implies that the behavior of this call is</span></span><br><span class="line"><span class="comment">     * undefined if the specified collection is this list, and this</span></span><br><span class="line"><span class="comment">     * list is nonempty.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount       //不是一次次的add和一次次的扩容了, 而是直接扩容到对应大小. 效率更高</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment">     * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment">     * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment">     * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment">     * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment">     * specified collection&#x27;s iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which to insert the first element from the</span></span><br><span class="line"><span class="comment">     *              specified collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes from this list all of the elements whose index is between</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> fromIndex&#125;, inclusive, and &#123;<span class="doctag">@code</span> toIndex&#125;, exclusive.</span></span><br><span class="line"><span class="comment">     * Shifts any succeeding elements to the left (reduces their index).</span></span><br><span class="line"><span class="comment">     * This call shortens the list by &#123;<span class="doctag">@code</span> (toIndex - fromIndex)&#125; elements.</span></span><br><span class="line"><span class="comment">     * (If &#123;<span class="doctag">@code</span> toIndex==fromIndex&#125;, this operation has no effect.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException if &#123;<span class="doctag">@code</span> fromIndex&#125; or</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> toIndex&#125; is out of range</span></span><br><span class="line"><span class="comment">     *         (&#123;<span class="doctag">@code</span> fromIndex &lt; 0 ||</span></span><br><span class="line"><span class="comment">     *          fromIndex &gt;= size() ||</span></span><br><span class="line"><span class="comment">     *          toIndex &gt; size() ||</span></span><br><span class="line"><span class="comment">     *          toIndex &lt; fromIndex&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks if the given index is in range.  If not, throws an appropriate</span></span><br><span class="line"><span class="comment">     * runtime exception.  This method does *not* check if the index is</span></span><br><span class="line"><span class="comment">     * negative: It is always used immediately prior to an array access,</span></span><br><span class="line"><span class="comment">     * which throws an ArrayIndexOutOfBoundsException if index is negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A version of rangeCheck used by add and addAll.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an IndexOutOfBoundsException detail message.</span></span><br><span class="line"><span class="comment">     * Of the many possible refactorings of the error handling code,</span></span><br><span class="line"><span class="comment">     * this &quot;outlining&quot; performs best with both server and client VMs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes from this list all of its elements that are contained in the</span></span><br><span class="line"><span class="comment">     * specified collection.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c collection containing elements to be removed from this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of an element of this list</span></span><br><span class="line"><span class="comment">     *         is incompatible with the specified collection</span></span><br><span class="line"><span class="comment">     * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if this list contains a null element and the</span></span><br><span class="line"><span class="comment">     *         specified collection does not permit null elements</span></span><br><span class="line"><span class="comment">     * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),</span></span><br><span class="line"><span class="comment">     *         or if the specified collection is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Collection#contains(Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retains only the elements in this list that are contained in the</span></span><br><span class="line"><span class="comment">     * specified collection.  In other words, removes from this list all</span></span><br><span class="line"><span class="comment">     * of its elements that are not contained in the specified collection.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c collection containing elements to be retained in this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of an element of this list</span></span><br><span class="line"><span class="comment">     *         is incompatible with the specified collection</span></span><br><span class="line"><span class="comment">     * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if this list contains a null element and the</span></span><br><span class="line"><span class="comment">     *         specified collection does not permit null elements</span></span><br><span class="line"><span class="comment">     * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),</span></span><br><span class="line"><span class="comment">     *         or if the specified collection is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Collection#contains(Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;        <span class="comment">//批处理, complement为true时为只保留c中含有的元素, 删除其他元素</span></span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;                        <span class="comment">// complement为false时删除掉所有c中包含的元素</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; r &lt; size; r++)                                            <span class="comment">//双指针法删除不符合条件的元素</span></span><br><span class="line">                <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">            <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">            <span class="keyword">if</span> (r != size) &#123;                      <span class="comment">//r不等于size的时候就说明前面的for中引发了异常, 把r后面的元素都复制到w后面. 即r后面的元素不进行过滤删除操作了</span></span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                                 elementData, w,</span><br><span class="line">                                 size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (w != size) &#123;                       <span class="comment">//w为elementData经过过滤后剩余元素的个数, 去除w后面的元素</span></span><br><span class="line">                <span class="comment">// clear to let GC do its work</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">                modCount += size - w;</span><br><span class="line">                size = w;</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span></span><br><span class="line"><span class="comment">     * is, serialize it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment">     *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span></span><br><span class="line"><span class="comment">     * deserialize it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();                <span class="comment">//读入全部的非transient变量, 其中包含了size</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">            ensureCapacityInternal(size);           <span class="comment">//构造size对应的数组</span></span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();          <span class="comment">//一次读取每一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a list iterator over the elements in this list (in proper    //list特有的迭代器ListIterator. 可以从指定的位置开始, 可以前后双向遍历</span></span><br><span class="line"><span class="comment">     * sequence), starting at the specified position in the list.           //指定的位置有n+1个. 因为迭代器总算在两个元素中间. 即n个元素有n+1个起始位置</span></span><br><span class="line"><span class="comment">     * The specified index indicates the first element that would be        // 所以index 可以为0到size中的任意一个值. 0代表从头开始, size代表从尾开始</span></span><br><span class="line"><span class="comment">     * returned by an initial call to &#123;<span class="doctag">@link</span> ListIterator#next next&#125;.</span></span><br><span class="line"><span class="comment">     * An initial call to &#123;<span class="doctag">@link</span> ListIterator#previous previous&#125; would</span></span><br><span class="line"><span class="comment">     * return the element with the specified index minus one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a list iterator over the elements in this list (in proper</span></span><br><span class="line"><span class="comment">     * sequence).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #listIterator(int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an iterator over the elements in this list in proper sequence.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an iterator over the elements in this list in proper sequence</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;                 <span class="comment">//普通迭代器</span></span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An optimized version of AbstractList.ListItr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;     <span class="comment">//list特有的迭代器, 可以用这个迭代器进行set和add操作</span></span><br><span class="line">        ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            cursor = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a view of the portion of this list between the specified           //指定区间返回视图, 前闭后开区间 [begin, end)</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> fromIndex&#125;, inclusive, and &#123;<span class="doctag">@code</span> toIndex&#125;, exclusive.  (If</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> fromIndex&#125; and &#123;<span class="doctag">@code</span> toIndex&#125; are equal, the returned list is</span></span><br><span class="line"><span class="comment">     * empty.)  The returned list is backed by this list, so non-structural        //sublist中非结构化的改变会影响原来的list, 反之也是这样的</span></span><br><span class="line"><span class="comment">     * changes in the returned list are reflected in this list, and vice-versa.</span></span><br><span class="line"><span class="comment">     * The returned list supports all of the optional list operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method eliminates the need for explicit range operations (of        //这个方法的目的是减少不必要的范围操作. 例如想对某个区间内的元素排序, 就可以用这个</span></span><br><span class="line"><span class="comment">     * the sort that commonly exist for arrays).  Any operation that expects      </span></span><br><span class="line"><span class="comment">     * a list can be used as a range operation by passing a subList view</span></span><br><span class="line"><span class="comment">     * instead of a whole list.  For example, the following idiom</span></span><br><span class="line"><span class="comment">     * removes a range of elements from a list:</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *      list.subList(from, to).clear();</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * Similar idioms may be constructed for &#123;<span class="doctag">@link</span> #indexOf(Object)&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #lastIndexOf(Object)&#125;, and all of the algorithms in the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Collections&#125; class can be applied to a subList.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The semantics of the list returned by this method become undefined if</span></span><br><span class="line"><span class="comment">     * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in         //没有经过sublist的结构性的改变的操作是未定义的.</span></span><br><span class="line"><span class="comment">     * any way other than via the returned list.  (Structural modifications are      // 比如构造一个sublist后, 原来的list结构改变了. 这时是十分危险的</span></span><br><span class="line"><span class="comment">     * those that change the size of this list, or otherwise perturb it in such      // List sublist = list.subList(0, 10);</span></span><br><span class="line"><span class="comment">     * a fashion that iterations in progress may yield incorrect results.)           // list.removeAll(c); 这时的sublist具体是什么结构是未定义的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">subListRangeCheck</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;fromIndex = &quot;</span> + fromIndex);</span><br><span class="line">        <span class="keyword">if</span> (toIndex &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;toIndex = &quot;</span> + toIndex);</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;fromIndex(&quot;</span> + fromIndex +</span><br><span class="line">                                               <span class="string">&quot;) &gt; toIndex(&quot;</span> + toIndex + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentOffset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">        SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">                <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            E oldValue = ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">return</span> ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">            rangeCheckForAdd(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            parent.add(parentOffset + index, e);</span><br><span class="line">            <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">            <span class="keyword">this</span>.size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            E result = parent.remove(parentOffset + index);</span><br><span class="line">            <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">            <span class="keyword">this</span>.size--;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            parent.removeRange(parentOffset + fromIndex,</span><br><span class="line">                               parentOffset + toIndex);</span><br><span class="line">            <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">            <span class="keyword">this</span>.size -= toIndex - fromIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> addAll(<span class="keyword">this</span>.size, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">            rangeCheckForAdd(index);</span><br><span class="line">            <span class="keyword">int</span> cSize = c.size();</span><br><span class="line">            <span class="keyword">if</span> (cSize==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            checkForComodification();</span><br><span class="line">            parent.addAll(parentOffset + index, c);</span><br><span class="line">            <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">            <span class="keyword">this</span>.size += cSize;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> listIterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            rangeCheckForAdd(index);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="keyword">this</span>.offset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ListIterator&lt;E&gt;() &#123;               <span class="comment">//匿名内部类</span></span><br><span class="line">                <span class="keyword">int</span> cursor = index;</span><br><span class="line">                <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> cursor != SubList.<span class="keyword">this</span>.size;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    checkForComodification();</span><br><span class="line">                    <span class="keyword">int</span> i = cursor;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= SubList.<span class="keyword">this</span>.size)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                    <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    cursor = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    checkForComodification();</span><br><span class="line">                    <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                    <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    cursor = i;</span><br><span class="line">                    <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">                    Objects.requireNonNull(consumer);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> size = SubList.<span class="keyword">this</span>.size;</span><br><span class="line">                    <span class="keyword">int</span> i = cursor;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                    <span class="keyword">if</span> (offset + i &gt;= elementData.length) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                        consumer.accept((E) elementData[offset + (i++)]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">                    lastRet = cursor = i;</span><br><span class="line">                    checkForComodification();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> cursor;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                    checkForComodification();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        SubList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                        cursor = lastRet;</span><br><span class="line">                        lastRet = -<span class="number">1</span>;</span><br><span class="line">                        expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                    checkForComodification();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ArrayList.<span class="keyword">this</span>.set(offset + lastRet, e);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                    checkForComodification();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> i = cursor;</span><br><span class="line">                        SubList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">                        cursor = i + <span class="number">1</span>;</span><br><span class="line">                        lastRet = -<span class="number">1</span>;</span><br><span class="line">                        expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (expectedModCount != ArrayList.<span class="keyword">this</span>.modCount)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">            subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, offset, fromIndex, toIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+<span class="keyword">this</span>.size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.modCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayListSpliterator&lt;E&gt;(ArrayList.<span class="keyword">this</span>, offset,</span><br><span class="line">                                               offset + <span class="keyword">this</span>.size, <span class="keyword">this</span>.modCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">final</span> E[] elementData = (E[]) <span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            action.accept(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;</span></span><br><span class="line"><span class="comment">     * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;<span class="doctag">@link</span> Spliterator&#125; over the elements in this</span></span><br><span class="line"><span class="comment">     * list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The &#123;<span class="doctag">@code</span> Spliterator&#125; reports &#123;<span class="doctag">@link</span> Spliterator#SIZED&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Spliterator#SUBSIZED&#125;, and &#123;<span class="doctag">@link</span> Spliterator#ORDERED&#125;.</span></span><br><span class="line"><span class="comment">     * Overriding implementations should document the reporting of additional</span></span><br><span class="line"><span class="comment">     * characteristic values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Spliterator&#125; over the elements in this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;                <span class="comment">//Spliterator是在java 8引入的一个接口，它通常和stream一起使用，用来遍历和分割序列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayListSpliterator&lt;&gt;(<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>); <span class="comment">//只要用到stream的地方都需要Spliterator，比如List，Collection，IO channel等等。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Index-based split-by-two, lazily initialized Spliterator */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If ArrayLists were immutable, or structurally immutable (no</span></span><br><span class="line"><span class="comment">         * adds, removes, etc), we could implement their spliterators</span></span><br><span class="line"><span class="comment">         * with Arrays.spliterator. Instead we detect as much</span></span><br><span class="line"><span class="comment">         * interference during traversal as practical without</span></span><br><span class="line"><span class="comment">         * sacrificing much performance. We rely primarily on</span></span><br><span class="line"><span class="comment">         * modCounts. These are not guaranteed to detect concurrency</span></span><br><span class="line"><span class="comment">         * violations, and are sometimes overly conservative about</span></span><br><span class="line"><span class="comment">         * within-thread interference, but detect enough problems to</span></span><br><span class="line"><span class="comment">         * be worthwhile in practice. To carry this out, we (1) lazily</span></span><br><span class="line"><span class="comment">         * initialize fence and expectedModCount until the latest</span></span><br><span class="line"><span class="comment">         * point that we need to commit to the state we are checking</span></span><br><span class="line"><span class="comment">         * against; thus improving precision.  (This doesn&#x27;t apply to</span></span><br><span class="line"><span class="comment">         * SubLists, that create spliterators with current non-lazy</span></span><br><span class="line"><span class="comment">         * values).  (2) We perform only a single</span></span><br><span class="line"><span class="comment">         * ConcurrentModificationException check at the end of forEach</span></span><br><span class="line"><span class="comment">         * (the most performance-sensitive method). When using forEach</span></span><br><span class="line"><span class="comment">         * (as opposed to iterators), we can normally only detect</span></span><br><span class="line"><span class="comment">         * interference after actions, not before. Further</span></span><br><span class="line"><span class="comment">         * CME-triggering checks apply to all other possible</span></span><br><span class="line"><span class="comment">         * violations of assumptions for example null or too-small</span></span><br><span class="line"><span class="comment">         * elementData array given its size(), that could only have</span></span><br><span class="line"><span class="comment">         * occurred due to interference.  This allows the inner loop</span></span><br><span class="line"><span class="comment">         * of forEach to run without any further checks, and</span></span><br><span class="line"><span class="comment">         * simplifies lambda-resolution. While this does entail a</span></span><br><span class="line"><span class="comment">         * number of checks, note that in the common case of</span></span><br><span class="line"><span class="comment">         * list.stream().forEach(a), no checks or other computation</span></span><br><span class="line"><span class="comment">         * occur anywhere other than inside forEach itself.  The other</span></span><br><span class="line"><span class="comment">         * less-often-used methods cannot take advantage of most of</span></span><br><span class="line"><span class="comment">         * these streamlinings.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;E&gt; list;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index; <span class="comment">// current index, modified on advance/split</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fence; <span class="comment">// -1 until used; then one past last index</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount; <span class="comment">// initialized when fence set</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Create new spliterator covering the given  range */</span></span><br><span class="line">        ArrayListSpliterator(ArrayList&lt;E&gt; list, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence,</span><br><span class="line">                             <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">this</span>.list = list; <span class="comment">// OK if null unless traversed</span></span><br><span class="line">            <span class="keyword">this</span>.index = origin;</span><br><span class="line">            <span class="keyword">this</span>.fence = fence;</span><br><span class="line">            <span class="keyword">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFence</span><span class="params">()</span> </span>&#123; <span class="comment">// initialize fence to size on first use</span></span><br><span class="line">            <span class="keyword">int</span> hi; <span class="comment">// (a specialized variant appears in method forEach)</span></span><br><span class="line">            ArrayList&lt;E&gt; lst;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((lst = list) == <span class="keyword">null</span>)</span><br><span class="line">                    hi = fence = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    expectedModCount = lst.modCount;</span><br><span class="line">                    hi = fence = lst.size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ArrayListSpliterator&lt;E&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid) ? <span class="keyword">null</span> : <span class="comment">// divide range in half unless too small</span></span><br><span class="line">                <span class="keyword">new</span> ArrayListSpliterator&lt;E&gt;(list, lo, index = mid,</span><br><span class="line">                                            expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), i = index;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; hi) &#123;</span><br><span class="line">                index = i + <span class="number">1</span>;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E)list.elementData[i];</span><br><span class="line">                action.accept(e);</span><br><span class="line">                <span class="keyword">if</span> (list.modCount != expectedModCount)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc; <span class="comment">// hoist accesses and checks from loop</span></span><br><span class="line">            ArrayList&lt;E&gt; lst; Object[] a;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> ((lst = list) != <span class="keyword">null</span> &amp;&amp; (a = lst.elementData) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    mc = lst.modCount;</span><br><span class="line">                    hi = lst.size;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    mc = expectedModCount;</span><br><span class="line">                <span class="keyword">if</span> ((i = index) &gt;= <span class="number">0</span> &amp;&amp; (index = hi) &lt;= a.length) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (; i &lt; hi; ++i) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) a[i];</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (lst.modCount == mc)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">long</span>) (getFence() - index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line">        <span class="comment">// figure out which elements are to be removed</span></span><br><span class="line">        <span class="comment">// any exception thrown from the filter predicate at this stage</span></span><br><span class="line">        <span class="comment">// will leave the collection unmodified</span></span><br><span class="line">        <span class="keyword">int</span> removeCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> BitSet removeSet = <span class="keyword">new</span> BitSet(size);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="keyword">final</span> E element = (E) elementData[i];</span><br><span class="line">            <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">                removeSet.set(i);</span><br><span class="line">                removeCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// shift surviving elements left over the spaces left by removed elements</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> anyToRemove = removeCount &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> newSize = size - removeCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">                i = removeSet.nextClearBit(i);</span><br><span class="line">                elementData[j] = elementData[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">                elementData[k] = <span class="keyword">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.size = newSize;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            modCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> anyToRemove;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.HashMap阅读笔记</title>
    <url>/2020/11/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java.util.HashMap%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="HashMap阅读笔记"><a href="#HashMap阅读笔记" class="headerlink" title="HashMap阅读笔记"></a>HashMap阅读笔记</h2><p>这是我读的第1个源码, mark一下吧. </p>
<p>强烈推荐 <a href="https://blog.csdn.net/anlian523/article/details/103649200">JDK8 HashMap源码行级解析 红黑树操作 史上最全最详细图解_anlian523的博客-CSDN博客</a>. 关于红黑树的部分讲解的很好.</p>
<p>建议如果阅读代码中的笔记, 将下面的代码块拷贝到vs code或idea上. 因为在markdown的代码块中宽度有限制, 会影响观看效果.</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InvalidObjectException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> sun.misc.SharedSecrets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This</span></span><br><span class="line"><span class="comment"> * implementation provides all of the optional map operations, and permits</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;       这里说明了允许key和value为 null, 并且是unsynchronized的</span></span><br><span class="line"><span class="comment"> * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is         而Hashtable不允许null, 并且是synchronized的</span></span><br><span class="line"><span class="comment"> * unsynchronized and permits nulls.)  This class makes no guarantees as to</span></span><br><span class="line"><span class="comment"> * the order of the map; in particular, it does not guarantee that the order    不保证顺序永远一样. 这一点很容易理解, 一扩容就要重新计算hash % len, 根据这个值来确定顺序</span></span><br><span class="line"><span class="comment"> * will remain constant over time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation provides constant-time performance for the basic</span></span><br><span class="line"><span class="comment"> * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function</span></span><br><span class="line"><span class="comment"> * disperses the elements properly among the buckets.  Iteration over             bucket为数组中的每个元素</span></span><br><span class="line"><span class="comment"> * collection views requires time proportional to the &quot;capacity&quot; of the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number</span></span><br><span class="line"><span class="comment"> * of key-value mappings).  Thus, it&#x27;s very important not to set the initial</span></span><br><span class="line"><span class="comment"> * capacity too high (or the load factor too low) if iteration performance is</span></span><br><span class="line"><span class="comment"> * important.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its</span></span><br><span class="line"><span class="comment"> * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial      capacity是bucket的数量而不是(key, value)的数量</span></span><br><span class="line"><span class="comment"> * capacity is simply the capacity at the time the hash table is created.  The      hashmap中的键值对(key, value)被称为entry</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to</span></span><br><span class="line"><span class="comment"> * get before its capacity is automatically increased.  When the number of</span></span><br><span class="line"><span class="comment"> * entries in the hash table exceeds the product of the load factor and the        当entry的数量大于 loadFactor * currentCapacity就扩容到2的下一个次方</span></span><br><span class="line"><span class="comment"> * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data</span></span><br><span class="line"><span class="comment"> * structures are rebuilt) so that the hash table has approximately twice the</span></span><br><span class="line"><span class="comment"> * number of buckets.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As a general rule, the default load factor (.75) offers a good              loadFactor为0.75是空间占用和查找效率的tradeoff</span></span><br><span class="line"><span class="comment"> * tradeoff between time and space costs.  Higher values decrease the</span></span><br><span class="line"><span class="comment"> * space overhead but increase the lookup cost (reflected in most of</span></span><br><span class="line"><span class="comment"> * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number of entries in</span></span><br><span class="line"><span class="comment"> * the map and its load factor should be taken into account when</span></span><br><span class="line"><span class="comment"> * setting its initial capacity, so as to minimize the number of                    初始size大于entry数量除以loadfactor的时候也不会缩小hashmap大小 </span></span><br><span class="line"><span class="comment"> * rehash operations.  If the initial capacity is greater than the                    这里表示哈希表只会扩容不会缩小</span></span><br><span class="line"><span class="comment"> * maximum number of entries divided by the load factor, no rehash</span></span><br><span class="line"><span class="comment"> * operations will ever occur.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * instance, creating it with a sufficiently large capacity will allow               </span></span><br><span class="line"><span class="comment"> * the mappings to be stored more efficiently than letting it perform</span></span><br><span class="line"><span class="comment"> * automatic rehashing as needed to grow the table.  Note that using</span></span><br><span class="line"><span class="comment"> * many keys with the same &#123;<span class="doctag">@code</span> hashCode()&#125; is a sure way to slow</span></span><br><span class="line"><span class="comment"> * down performance of any hash table. To ameliorate impact, when keys             ameliorate == make it perform better</span></span><br><span class="line"><span class="comment"> * are &#123;<span class="doctag">@link</span> Comparable&#125;, this class may use comparison order among               当很多key的hashcode都相等的时候, 如果key实现了Comparable接口, </span></span><br><span class="line"><span class="comment"> * keys to help break ties.                                                        就根据这些key的大小关系来改善性能. (事实上就是用大小关系构造红黑树)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;         hashmap线程不安全</span></span><br><span class="line"><span class="comment"> * If multiple threads access a hash map concurrently, and at least one of        如果多个线程并发访问, 并且至少一个改变hashmap的结构， 就要加锁</span></span><br><span class="line"><span class="comment"> * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be</span></span><br><span class="line"><span class="comment"> * synchronized externally.  (A structural modification is any operation</span></span><br><span class="line"><span class="comment"> * that adds or deletes one or more mappings; merely changing the value</span></span><br><span class="line"><span class="comment"> * associated with a key that an instance already contains is not a</span></span><br><span class="line"><span class="comment"> * structural modification.)  This is typically accomplished by</span></span><br><span class="line"><span class="comment"> * synchronizing on some object that naturally encapsulates the map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If no such object exists, the map should be &quot;wrapped&quot; using the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Collections#synchronizedMap Collections.synchronizedMap&#125;</span></span><br><span class="line"><span class="comment"> * method.  This is best done at creation time, to prevent accidental            要直接在参数中生成, 而不是保留内部集合的引用,防止意外的获得非同步引用. </span></span><br><span class="line"><span class="comment"> * unsynchronized access to the map:&lt;pre&gt;                                        错误示例:</span></span><br><span class="line"><span class="comment"> *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;                HashMap&lt;?, ?&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment"> *                                                                               Map p = Collections.synchronizedMap(map); 意外的使用非同步引用map是危险的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The iterators returned by all of this class&#x27;s &quot;collection view methods&quot;</span></span><br><span class="line"><span class="comment"> * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after     创建迭代器后</span></span><br><span class="line"><span class="comment"> * the iterator is created, in any way except through the iterator&#x27;s own           任何修改都会引发异常, 除了迭代器自己的remove方法</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span></span><br><span class="line"><span class="comment"> * modification, the iterator fails quickly and cleanly, rather than risking</span></span><br><span class="line"><span class="comment"> * arbitrary, non-deterministic behavior at an undetermined time in the</span></span><br><span class="line"><span class="comment"> * future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed       但是不能依赖快速失败的特点来编写程序. 这样的正确性不能保证</span></span><br><span class="line"><span class="comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span></span><br><span class="line"><span class="comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span></span><br><span class="line"><span class="comment"> * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.</span></span><br><span class="line"><span class="comment"> * Therefore, it would be wrong to write a program that depended on this</span></span><br><span class="line"><span class="comment"> * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators</span></span><br><span class="line"><span class="comment"> * should be used only to detect bugs.&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Arthur van Hoff</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Neal Gafter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#hashCode()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     TreeMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Hashtable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Implementation notes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This map usually acts as a binned (bucketed) hash table, but    这里的bin推测是每个bucket中的各个entry</span></span><br><span class="line"><span class="comment">     * when bins get too large, they are transformed into bins of</span></span><br><span class="line"><span class="comment">     * TreeNodes, each structured similarly to those in</span></span><br><span class="line"><span class="comment">     * java.util.TreeMap. Most methods try to use normal bins, but     大多数方法都是认为bin是普通的节点, 直接对节点进行操作</span></span><br><span class="line"><span class="comment">     * relay to TreeNode methods when applicable (simply by checking   如果发现是tree bin的节点, 就去调用操作tree bin的函数</span></span><br><span class="line"><span class="comment">     * instanceof a node).  Bins of TreeNodes may be traversed and</span></span><br><span class="line"><span class="comment">     * used like any others, but additionally support faster lookup</span></span><br><span class="line"><span class="comment">     * when overpopulated. However, since the vast majority of bins in</span></span><br><span class="line"><span class="comment">     * normal use are not overpopulated, checking for existence of</span></span><br><span class="line"><span class="comment">     * tree bins may be delayed in the course of table methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Tree bins (i.e., bins whose elements are all TreeNodes) are            tree bin的红黑树按照hash值排序, (主要是按照hashcode排序)</span></span><br><span class="line"><span class="comment">     * ordered primarily by hashCode, but in the case of ties, if two         我一直搞不懂这个ties是什么意思, 直到看到TreeNode的find方法才明白, ties是指两个对象hash相同的情况</span></span><br><span class="line"><span class="comment">     * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,           当两个对象hash值相同的时候, 如果C实现了comparable接口, 可以用这个compareTo方法. </span></span><br><span class="line"><span class="comment">     * type then their compareTo method is used for ordering. (We             </span></span><br><span class="line"><span class="comment">     * conservatively check generic types via reflection to validate          </span></span><br><span class="line"><span class="comment">     * this -- see method comparableClassFor).  The added complexity         使用反射查看泛型参数是不是实现了Comparable接口 </span></span><br><span class="line"><span class="comment">     * of tree bins is worthwhile in providing worst-case O(log n)            </span></span><br><span class="line"><span class="comment">     * operations when keys either have distinct hashes or are               如果hash不相同, 或者是可排序的, 最坏情况下就是log n的复杂度</span></span><br><span class="line"><span class="comment">     * orderable, Thus, performance degrades gracefully under</span></span><br><span class="line"><span class="comment">     * accidental or malicious usages in which hashCode() methods</span></span><br><span class="line"><span class="comment">     * return values that are poorly distributed, as well as those in</span></span><br><span class="line"><span class="comment">     * which many keys share a hashCode, so long as they are also            如果很多hash相同, 但是他们是comparable的, 性能会下降</span></span><br><span class="line"><span class="comment">     * Comparable. (If neither of these apply, we may waste about a          </span></span><br><span class="line"><span class="comment">     * factor of two in time and space compared to taking no</span></span><br><span class="line"><span class="comment">     * precautions. But the only known cases stem from poor user</span></span><br><span class="line"><span class="comment">     * programming practices that are already so slow that this makes</span></span><br><span class="line"><span class="comment">     * little difference.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Because TreeNodes are about twice the size of regular nodes, we</span></span><br><span class="line"><span class="comment">     * use them only when bins contain enough nodes to warrant use</span></span><br><span class="line"><span class="comment">     * (see TREEIFY_THRESHOLD). And when they become too small (due to</span></span><br><span class="line"><span class="comment">     * removal or resizing) they are converted back to plain bins.  In</span></span><br><span class="line"><span class="comment">     * usages with well-distributed user hashCodes, tree bins are</span></span><br><span class="line"><span class="comment">     * rarely used.  Ideally, under random hashCodes, the frequency of      这里使用泊松分布说明了如果hashcode均匀, 出现tree bin的概率非常小</span></span><br><span class="line"><span class="comment">     * nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="comment">     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line"><span class="comment">     * parameter of about 0.5 on average for the default resizing</span></span><br><span class="line"><span class="comment">     * threshold of 0.75, although with a large variance because of</span></span><br><span class="line"><span class="comment">     * resizing granularity. Ignoring variance, the expected</span></span><br><span class="line"><span class="comment">     * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span></span><br><span class="line"><span class="comment">     * factorial(k)). The first values are:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:    0.60653066</span></span><br><span class="line"><span class="comment">     * 1:    0.30326533</span></span><br><span class="line"><span class="comment">     * 2:    0.07581633</span></span><br><span class="line"><span class="comment">     * 3:    0.01263606</span></span><br><span class="line"><span class="comment">     * 4:    0.00157952</span></span><br><span class="line"><span class="comment">     * 5:    0.00015795</span></span><br><span class="line"><span class="comment">     * 6:    0.00001316</span></span><br><span class="line"><span class="comment">     * 7:    0.00000094</span></span><br><span class="line"><span class="comment">     * 8:    0.00000006</span></span><br><span class="line"><span class="comment">     * more: less than 1 in ten million</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The root of a tree bin is normally its first node.  However,</span></span><br><span class="line"><span class="comment">     * sometimes (currently only upon Iterator.remove), the root might</span></span><br><span class="line"><span class="comment">     * be elsewhere, but can be recovered following parent links</span></span><br><span class="line"><span class="comment">     * (method TreeNode.root()).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * All applicable internal methods accept a hash code as an</span></span><br><span class="line"><span class="comment">     * argument (as normally supplied from a public method), allowing   所有的内部方法都接受一个hash变量来避免重复计算key的hash</span></span><br><span class="line"><span class="comment">     * them to call each other without recomputing user hashCodes.</span></span><br><span class="line"><span class="comment">     * Most internal methods also accept a &quot;tab&quot; argument, that is      大部分内部方法也接受一个tab变量, 大部分时间是当前数组的引用, </span></span><br><span class="line"><span class="comment">     * normally the current table, but may be a new or old one when     但是会因为resize等操作更新</span></span><br><span class="line"><span class="comment">     * resizing or converting.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When bin lists are treeified, split, or untreeified, we keep    树化或非树化之后的遍历顺序不变, 都是next指针维持的顺序</span></span><br><span class="line"><span class="comment">     * them in the same relative access/traversal order (i.e., field</span></span><br><span class="line"><span class="comment">     * Node.next) to better preserve locality, and to slightly</span></span><br><span class="line"><span class="comment">     * simplify handling of splits and traversals that invoke</span></span><br><span class="line"><span class="comment">     * iterator.remove. When using comparators on insertion, to keep a</span></span><br><span class="line"><span class="comment">     * total ordering (or as close as is required here) across</span></span><br><span class="line"><span class="comment">     * rebalancings, we compare classes and identityHashCodes as</span></span><br><span class="line"><span class="comment">     * tie-breakers.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The use and transitions among plain vs tree modes is</span></span><br><span class="line"><span class="comment">     * complicated by the existence of subclass LinkedHashMap. See     LinkedHashMap的树化, 非树化方法更复杂</span></span><br><span class="line"><span class="comment">     * below for hook methods defined to be invoked upon insertion,</span></span><br><span class="line"><span class="comment">     * removal and access that allow LinkedHashMap internals to</span></span><br><span class="line"><span class="comment">     * otherwise remain independent of these mechanics. (This also</span></span><br><span class="line"><span class="comment">     * requires that a map instance be passed to some utility methods</span></span><br><span class="line"><span class="comment">     * that may create new nodes.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The concurrent-programming-like SSA-based coding style helps</span></span><br><span class="line"><span class="comment">     * avoid aliasing errors amid all of the twisty pointer operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;  <span class="comment">//并不是链表长度一超过8就变为红黑树. 而是还要满足table.length &gt;= MIN_TREEIFY_CAPACITY才可以. 如果不超过, 就不树化了, 而是resize</span></span><br><span class="line">                                                <span class="comment">//所以hashmap扩容触发条件有2个, 第一个就是size大于了capacity * loadfactor, 第二个就是table.length小于MIN_TREEIFY_CAPACITY, 而且链表长度超过了8</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;   <span class="comment">//entry的真正实现类</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;                                   <span class="comment">//指向下一个元素的指针</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);    <span class="comment">//Entry的hashcode是key的hash和value的hash异或得到的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Static utilities -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">     * to lower.  Because the table uses power-of-two masking, sets of   由于table的长度总是2的整数次幂, 所以高位的不同并不会避免碰撞.</span></span><br><span class="line"><span class="comment">     * hashes that vary only in bits above the current mask will         所以要做一个变换使得高位的hashcode能够影响低位的</span></span><br><span class="line"><span class="comment">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">     * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">     * downward. There is a tradeoff between speed, utility, and         这是速度和可用性的tradeoff. </span></span><br><span class="line"><span class="comment">     * quality of bit-spreading. Because many common sets of hashes      因为很多类的哈希值已经是被设计为良好分布的了, 所以这个变换并不会使得他们受益很多</span></span><br><span class="line"><span class="comment">     * are already reasonably distributed (so don&#x27;t benefit from         并且因为有树化的设计, 碰撞了复杂度也不会提高很多.</span></span><br><span class="line"><span class="comment">     * spreading), and because we use trees to handle large sets of      所以没必要用一个复杂的变换. 仅仅用一个不花费太多时间的异或操作即可.</span></span><br><span class="line"><span class="comment">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">     * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);   <span class="comment">//注意到null的hash为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns x&#x27;s Class if it is of the form &quot;class C implements</span></span><br><span class="line"><span class="comment">     * Comparable&lt;C&gt;&quot;, else null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;                     <span class="comment">//通过反射获得实现接口Comparable的类的Class对象</span></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">            <span class="keyword">if</span> ((c = x.getClass()) == String.class) // bypass checks</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                        ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                         Comparable.class) &amp;&amp;</span><br><span class="line">                        (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns k.compareTo(x) if x matches kc (k&#x27;s screened comparable</span></span><br><span class="line"><span class="comment">     * class), else 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">                ((Comparable)k).compareTo(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;                 <span class="comment">//异或获得大于cap的最小的2的整数次幂</span></span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">     * necessary. When allocated, length is always a power of two.    长度总是2的整数次幂</span></span><br><span class="line"><span class="comment">     * (We also tolerate length zero in some operations to allow      长度是0也可以</span></span><br><span class="line"><span class="comment">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">     * for keySet() and values().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;                                       <span class="comment">//迭代器就是根据这个变量来决定是否</span></span><br><span class="line">                                                                  <span class="comment">//抛出ConcurrentModificationException</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// (The javadoc description is true upon serialization.                //并不是new完一个hashmap就立即创建table数组. 刚new完hashmap之后table[]数组为null</span></span><br><span class="line">    <span class="comment">// Additionally, if the table array has not been allocated, this       //直到put第一个元素的时候才会通过resize()方法创建table[]数组.</span></span><br><span class="line">    <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY.)              //如果table已经被创建了, 那么threshold为capacity * load factor. 超过这个值就扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;                           <span class="comment">//在table还未被创建的时候, 这个值等于即将要创建的table[]数组的长度. 也就是说第一次resize就把table变为大小为threshold的数组.</span></span><br><span class="line">    <span class="comment">/**                                      //如果使用空参构造器, 这个值初始为0, 否则这个值为大于等于capacity的第一个2的整数次幂.capacity为传入的指定大小</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Public operations -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)                            <span class="comment">//超过2^30的初始容量也会被变成2^30的容量</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);                   <span class="comment">//刚创建hashmap后, threshold为大于等于初始容量的第一个2的整数次幂</span></span><br><span class="line">    &#125;                                                                     <span class="comment">//table在new完hashmap之后, 插入值之前暂时为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted               //threshold = 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">     * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<span class="comment">//用一个map作为构造器参数</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;       <span class="comment">//首先要确定新的map的table的大小. 通过旧的map元素数量, loadFactor算出来. 仍然是2的整数次幂</span></span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.putAll and Map constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment">     * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">int</span> s = m.size();                                    </span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;                                        </span><br><span class="line">            <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size </span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">                resize();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value mappings in this map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value mappings in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;                       <span class="comment">//先检查对应桶中第一个是不是, 不是在判断是链表还是树. 是树就调用树的方法, 是链表就从头到尾开始查</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;          </span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node                 //利用短路逻辑. 而不是直接就比较 key.equals(k)</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))     <span class="comment">//如果hash值不等, 就肯定不相等.</span></span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the</span></span><br><span class="line"><span class="comment">     * specified key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   key   The key whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified</span></span><br><span class="line"><span class="comment">     * key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">     * value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,  //<span class="number">1.</span> 检查hashmap是不是第一次插入值, 如果是, 要调用resize初始化table</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;                                 <span class="comment">//2. 查看对应的桶中第一个元素是不是对应的值, 如果是, 直接修改这个值</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;                     <span class="comment">//3. 查看当前桶是链表还是树, 如果是链表, 依次查找, 找不到就在链表尾部插入一个新的node, 插入之后要检查是不是要树化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)         <span class="comment">//4. 如果是树, 调用树的put方法putTreeVal.</span></span><br><span class="line">            n = (tab = resize()).length;                            <span class="comment">//5. 如果插入了, 就++size, 再次判断是不是需要resize. 如果是替换, 就返回旧的值</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))              <span class="comment">//同样先检查第一个元素</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);  <span class="comment">//新元素插入到链表尾部</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st         //binCount是当前链表未插入new出来的节点的的长度, </span></span><br><span class="line">                            treeifyBin(tab, hash);                                  <span class="comment">//如果只看这一行可能会觉得判断条件是插入新节点</span></span><br><span class="line">                        <span class="keyword">break</span>;                                                     <span class="comment">//后的链表长度大于等于TREEIFY_THRESHOLD就可以了. 其实不是.</span></span><br><span class="line">                    &#125;                                                             <span class="comment">//这个长度是从第二个节点开始算的. 因为第一个节点我们之前已经判断过了</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;                                        <span class="comment">//所以是当总链表长度 大于 8 的时候才转换成树的. 如果链表插入元素之后的长度刚好为8, 是不进行转换的</span></span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//也可以理解为, 插入元素之前, 链表长度达到8, 并且要插入新元素, 就转化为红黑树</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);  <span class="comment">//默认的afterNodeAccess()方法为空函数, 如果有需求, 可以直接改这个函数作为回调, 不得不说HashMap的设计者很贴心</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict); <span class="comment">//和afterNodeAccess一样, 也是个空方法, 方便我们增加回调机制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in               //第1步. 检查table是不是null, 如果是, 说明是第一次resize,  </span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.            // 第一次的table长度要么是默认的16, 要么是threshold, 然后重新赋值threshold为capacity * loadfactor</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the             // 如果不是第一次, 直接新的长度和新的threshold 乘2, 但是要注意, 如果达到了最大值, 就不乘2了, threshold也直接定义为INT_MAX</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move          // 确定好长度之和就要new新的table了, 然后把原来的node放进去. 首先装第一个节点, 然后判断剩下的</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.                            // 如果是树化的, 调用方法split. 如果是链表, 拆成2部分, 装入两个不同的桶中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;                      </span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;                              <span class="comment">//如果不是第一次resize, 即table != null, 那么就扩展新的容量为2倍, 新的threshold也扩展为原来的2倍</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;          <span class="comment">// 如果旧的容量达到最大值, 就不扩容了, 而只是更新threshold为INT_MAX</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold   //如果是第一次resize, 即table为null, 那么第一次table应该设置为threshold大小的数组</span></span><br><span class="line">            newCap = oldThr;                                               <span class="comment">// 如果使用无参构造器, threshold为0, 就设置table大小为16. </span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults            </span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;                                            <span class="comment">//设置完table的大小之后, 就更新threshold为loadfactor * newCapacity</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;                    <span class="comment">// 如果新threshold和新capacity有一个超过2^30, 就把threshold设置为INT_MAX. </span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? <span class="comment">//为了使得继续添加元素也不会引起hashmap再次扩容</span></span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];        <span class="comment">//下面是根据上面计算出来的newCapacity来新建table[]数组</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;                 <span class="comment">//如果原来的table为null, 就直接返回新的数组即可. 否则还要将原来的元素迁移到新数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;             <span class="comment">//先把第一个节点放到正确的桶中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);<span class="comment">//如果是树状节点, 调用对应的方法</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;  </span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;                                <span class="comment">//(e.hash &amp; oldCap) == 0这一个判断很关键. 这个操作将原来的节点分成2部分, </span></span><br><span class="line">                            next = e.next;                 <span class="comment">//第一部分是模newCap还是原来的值的, 第二个部分是模newCap是原来的值加oldcap的</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">//例如, oldCap = 16, 某个桶内的元素哈希值为 1, 17, 33, 49, 65, 这些值模16都为1</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)      <span class="comment">//但是扩容之后 newCap = 32, 这些值模32之后就变为了2部分, 一部分模32仍然是1, (1, 33, 65)</span></span><br><span class="line">                                    loHead = e;         <span class="comment">//另一部分模32之后就变为了1+oldCap, 即17. (17, 49). 这两部分在新的table中是要放到不同的桶中的</span></span><br><span class="line">                                <span class="keyword">else</span>                   <span class="comment">//而(e.hash &amp; oldCap) == 0就是判断这些元素到底要放到哪个桶中.</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;            <span class="comment">//假设某个桶中所有元素模oldCap都为a, 遍历过程中loHead和loTail存储模newCap仍为a的元素, </span></span><br><span class="line">                            &#125;                          <span class="comment">//hiHead和hiTail存储模newCap为a + oldCap的元素, 并且这些元素的相对位置不变</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">     * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)      <span class="comment">//如果table.length小于MIN_TREEIFY_CAPACITY就不树化, 而是table扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);        <span class="comment">//将链表的所有节点转化为树节点, 结构仍然是链表. </span></span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                hd.treeify(tab);                                    <span class="comment">//将链表树化为红黑树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies all of the mappings from the specified map to this map.</span></span><br><span class="line"><span class="comment">     * These mappings will replace any mappings that this map had for</span></span><br><span class="line"><span class="comment">     * any of the keys currently in the specified map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m mappings to be stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key key whose mapping is to be removed from the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.remove and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;      <span class="comment">// 移除元素. 注意到, 移除很多个元素也不会触发resize缩小hashmap大小.</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;                        <span class="comment">//hashmap只能扩容不能缩容</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;                                             <span class="comment">//这里的if主要是找到给定key对应的引用node</span></span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;      <span class="comment">//如果跳出循环, p就是e的前一个结点. 即p是node的前一个节点. 根据这个来进行删除操作</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;                                                                            <span class="comment">//至此, 拿到了要删除的节点node</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||           <span class="comment">//这里的if主要是删除node</span></span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);<span class="comment">//可以定义删除节点后的触发操作. 这里函数体为空</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all of the mappings from this map.</span></span><br><span class="line"><span class="comment">     * The map will be empty after this call returns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     * specified value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     *         specified value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;   <span class="comment">//注意, TreeNode也有next指针, 可以这样来遍历</span></span><br><span class="line">                    <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                        (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))           </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the keys contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of</span></span><br><span class="line"><span class="comment">     * the iteration are undefined.  The set supports element removal,</span></span><br><span class="line"><span class="comment">     * which removes the corresponding mapping from the map, via the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the keys contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写到这里才想起来, 原来Map没有iterator()方法, 不能通过 map =  new HashMap(); map.iterator();来获取迭代器, 所以只能通过先获取KeySet, Values, EntrySet再迭代的方式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;                      <span class="comment">//内部类, 指向外围对象的指针为HashMap.this</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;          <span class="comment">//通过指向外围类对象的指针操作hashmap. 如果这个set进行clear操作, 对应的hashmap也会被clear</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;      <span class="comment">//KeySet对象事实上就是在原来的HashMap对象上套了个壳. 迭代器操作什么的都是建立在原来的对象上的</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;         <span class="comment">//Values类, EntrySet类同理</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Collection&#125; view of the values contained in this map.</span></span><br><span class="line"><span class="comment">     * The collection is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the collection, and vice-versa.  If the map is</span></span><br><span class="line"><span class="comment">     * modified while an iteration over the collection is in progress</span></span><br><span class="line"><span class="comment">     * (except through the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation),</span></span><br><span class="line"><span class="comment">     * the results of the iteration are undefined.  The collection</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not</span></span><br><span class="line"><span class="comment">     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a view of the values contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            vs = <span class="keyword">new</span> Values();</span><br><span class="line">            values = vs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;          <span class="comment">//同KeySet一样, 返回的是视图而不是副本</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the mappings contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</span></span><br><span class="line"><span class="comment">     * iterator) the results of the iteration are undefined.  The set</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the mappings contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">                Object key = e.getKey();</span><br><span class="line">                Object value = e.getValue();</span><br><span class="line">                <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overrides of JDK8 Map extension methods          //这一部分是jdk8新扩展的方法了, 大多数方法和底层原理无关, 就不仔细分析了. 我本人看源码的目的是为了了解底层</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e; V v;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">            e.value = newValue;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; (oldValue = old.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        V v = mappingFunction.apply(key);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">computeIfPresent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (oldValue = e.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = v;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        V oldValue = (old == <span class="keyword">null</span>) ? <span class="keyword">null</span> : old.value;</span><br><span class="line">        V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, v, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="function"><span class="params">                   BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">if</span> (old.value != <span class="keyword">null</span>)</span><br><span class="line">                v = remappingFunction.apply(old.value, value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                v = value;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, value, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    e.value = function.apply(e.key, e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// Cloning and serialization</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and</span></span><br><span class="line"><span class="comment">     * values themselves are not cloned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a shallow copy of this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">        result.reinitialize();</span><br><span class="line">        result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These methods are also used when serializing HashSets</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> loadFactor; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (table != <span class="keyword">null</span>) ? table.length :</span><br><span class="line">            (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">            DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,</span></span><br><span class="line"><span class="comment">     * serialize it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the</span></span><br><span class="line"><span class="comment">     *             bucket array) is emitted (int), followed by the</span></span><br><span class="line"><span class="comment">     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value</span></span><br><span class="line"><span class="comment">     *             mappings), followed by the key (Object) and value (Object)</span></span><br><span class="line"><span class="comment">     *             for each key-value mapping.  The key-value mappings are</span></span><br><span class="line"><span class="comment">     *             emitted in no particular order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span>                   <span class="comment">//写入的时候只写入桶数量, size, 和各个entry. 其他的不写</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">        <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(buckets);</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        internalWriteEntries(s);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//之前一直好奇writeObject和readObject方法是怎么回事, 是private的并且没有public方法调用他们. 如果写这两个方法是为了ObjectInputStream或ObjectOutputStream使用, 那也不对啊.</span></span><br><span class="line"><span class="comment">//这两个流使用序列化的时候是ObjectInputStream类中的方法 ObjectInputStream in = new ObjectInputStream(); in.readObject();</span></span><br><span class="line"><span class="comment">// 而不是HashMap类中的方法HashMap map = new HashMap(); map.readObject(in);</span></span><br><span class="line"><span class="comment">//后来上网查了资料 https://zhuanlan.zhihu.com/p/84533476 才发现ObjectInputStream类中的readObject方法也是通过反射看看被写入的类中有没有实现.</span></span><br><span class="line"><span class="comment">//实际上在ObjectOutputStream中进行序列化操作的时候，会判断被序列化的对象是否自己重写了writeObject方法，如果重写了，就会调用被序列化对象自己的writeObject方法，如果没有重写，才会调用默认的序列化方法。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitutes this map from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException if the class of a serialized object</span></span><br><span class="line"><span class="comment">     *         could not be found</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if an I/O error occurs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span>              <span class="comment">//读取的时候只读键值对数量, 和各个键值对</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">        <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">        <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                             mappings);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">            <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">            <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">            <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">            <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                       DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                       (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                       MAXIMUM_CAPACITY :</span><br><span class="line">                       tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span></span><br><span class="line">            <span class="comment">// what we&#x27;re actually creating.</span></span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">            table = tab;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    K key = (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    V value = (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;                               <span class="comment">//entrySet(), keySet(), values()返回的集合的迭代器的基类. 从第0个bucket开始遍历</span></span><br><span class="line">        Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">        <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] t = table;</span><br><span class="line">            current = next = <span class="keyword">null</span>;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] t;</span><br><span class="line">            Node&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;        <span class="comment">//把当前的next传递给current, 然后找下一个next</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            K key = p.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// spliterators                                  //为并行遍历设置的迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;K,V&gt; map;</span><br><span class="line">        Node&lt;K,V&gt; current;          <span class="comment">// current node</span></span><br><span class="line">        <span class="keyword">int</span> index;                  <span class="comment">// current index, modified on advance/split</span></span><br><span class="line">        <span class="keyword">int</span> fence;                  <span class="comment">// one past last index</span></span><br><span class="line">        <span class="keyword">int</span> est;                    <span class="comment">// size estimate</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;       <span class="comment">// for comodification checks</span></span><br><span class="line"></span><br><span class="line">        HashMapSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin,</span><br><span class="line">                           <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                           <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">this</span>.map = m;</span><br><span class="line">            <span class="keyword">this</span>.index = origin;</span><br><span class="line">            <span class="keyword">this</span>.fence = fence;</span><br><span class="line">            <span class="keyword">this</span>.est = est;</span><br><span class="line">            <span class="keyword">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getFence</span><span class="params">()</span> </span>&#123; <span class="comment">// initialize fence and size on first use</span></span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                HashMap&lt;K,V&gt; m = map;</span><br><span class="line">                est = m.size;</span><br><span class="line">                expectedModCount = m.modCount;</span><br><span class="line">                Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            getFence(); <span class="comment">// force init</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">long</span>) est;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        KeySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                       <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> KeySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                        expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p.key);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        K k = current.key;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(k);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        ValueSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                         <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ValueSpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p.value);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        V v = current.value;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(v);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        EntrySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                         <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EntrySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Node&lt;K,V&gt; e = current;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// LinkedHashMap support</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The following package-protected methods are designed to be</span></span><br><span class="line"><span class="comment">     * overridden by LinkedHashMap, but not by any other subclass.</span></span><br><span class="line"><span class="comment">     * Nearly all other internal methods are also package-protected</span></span><br><span class="line"><span class="comment">     * but are declared final, so can be used by LinkedHashMap, view</span></span><br><span class="line"><span class="comment">     * classes, and HashSet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a regular (non-tree) node</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For conversion from TreeNodes to plain nodes</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a tree bin node</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For treeifyBin</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reset to initial default state.  Called by clone and readObject.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        table = <span class="keyword">null</span>;</span><br><span class="line">        entrySet = <span class="keyword">null</span>;</span><br><span class="line">        keySet = <span class="keyword">null</span>;</span><br><span class="line">        values = <span class="keyword">null</span>;</span><br><span class="line">        modCount = <span class="number">0</span>;</span><br><span class="line">        threshold = <span class="number">0</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called only from writeObject, to ensure compatible ordering.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    s.writeObject(e.key);</span><br><span class="line">                    s.writeObject(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// Tree bins</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  LinkedHashMap.Entry的定义</span></span><br><span class="line"><span class="comment">    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span></span><br><span class="line"><span class="comment">        Entry&lt;K,V&gt; before, after;</span></span><br><span class="line"><span class="comment">        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">            super(hash, key, value, next);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">     * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">     * linked node.</span></span><br><span class="line"><span class="comment">     */</span>     <span class="comment">//这里推荐 https://blog.csdn.net/anlian523/article/details/103649200 这篇博客, 对红黑树的操作讲解的都非常细. 我的笔记有一部分也是参考的这篇博客</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;                 <span class="comment">// 树状的bin节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links     //是这样的继承关系, LinkedHashMap.Entry继承了HashMap.Node, HashMap.TreeNode又继承了LinkedHashMap.Entry</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion        链表的上一个节点</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Ensures that the given root is the first node of its bin.</span></span><br><span class="line"><span class="comment">         */</span> <span class="comment">//因为有的时候旋转会使根节点发生变化, 即经过某次操作后, table[]中储存的可能不是根节点了. 这时要重新将根节点放到table[]中</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">                <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; rn; </span><br><span class="line">                    tab[index] = root;                                              <span class="comment">//第一步, 先把table[index]设为root</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; rp = root.prev;<span class="comment">//rn代表root.prev, rn代表root.next</span></span><br><span class="line">                    <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)                                  <span class="comment">//第二步, 处理链表顺序使得root在双向链表的第一个</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;                             <span class="comment">// 即链表 first &lt;-&gt; ... &lt;-&gt; rp &lt;-&gt; root &lt;-&gt; rn &lt;-&gt; ...</span></span><br><span class="line">                    <span class="keyword">if</span> (rp != <span class="keyword">null</span>)                                                <span class="comment">//变为 root &lt;-&gt; first &lt;-&gt; ... &lt;-&gt; rp &lt;-&gt; rn &lt;-&gt; ...</span></span><br><span class="line">                        rp.next = rn; </span><br><span class="line">                    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                        first.prev = root;</span><br><span class="line">                    root.next = first;</span><br><span class="line">                    root.prev = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Finds the node starting at root p with the given hash and key.</span></span><br><span class="line"><span class="comment">         * The kc argument caches comparableClassFor(key) upon first use</span></span><br><span class="line"><span class="comment">         * comparing keys.</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="comment">//这段代码大概的逻辑如下</span></span><br><span class="line">        <span class="comment">//  TreeNode find(Object k)</span></span><br><span class="line">        <span class="comment">//  &#123;</span></span><br><span class="line">        <span class="comment">//      TreeNode curr = this;</span></span><br><span class="line">        <span class="comment">//      while(curr != null)</span></span><br><span class="line">        <span class="comment">//      &#123;</span></span><br><span class="line">        <span class="comment">//         if(curr.key.hash &gt; k.hash)</span></span><br><span class="line">        <span class="comment">//             curr = curr.left;             //红黑树的顺序貌似是先以hashcode为主, hashcode相等再去调用对象的compareTo方法</span></span><br><span class="line">        <span class="comment">//         else if(curr.key.hash &lt; k.hash)</span></span><br><span class="line">        <span class="comment">//             curr = curr.left;</span></span><br><span class="line">        <span class="comment">//         else if(curr.key.equals(k))</span></span><br><span class="line">        <span class="comment">//             return curr;</span></span><br><span class="line">        <span class="comment">//         else if(k有compareTo方法 &amp;&amp; k.compareTo(curr.key) != 0)                         //hashcode相等, 但是值不相等, 所以要用compareTo方法比较curr和 k</span></span><br><span class="line">        <span class="comment">//         &#123;                                    //正常情况下不可能出现 k.compareTo(curr.key) == 0的. 因为这两个如果相等的话, 在上一层的if中就会被返回.</span></span><br><span class="line">        <span class="comment">//             if(curr.key.compareTo(k) &gt; 0)</span></span><br><span class="line">        <span class="comment">//                 curr = curr.left;</span></span><br><span class="line">        <span class="comment">//             else</span></span><br><span class="line">        <span class="comment">//                 curr = curr.right;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         else if(curr.right.find(k) != null)                 //hashCode和compareTo都判断不出来大小关系, 只能先递归地判断右边整个子树有没有这个元素, 然后再迭代的查找左子树</span></span><br><span class="line">        <span class="comment">//             return curr.right.find(k);</span></span><br><span class="line">        <span class="comment">//         else      //右子树也没有, 查找左子树</span></span><br><span class="line">        <span class="comment">//             curr = curr.left;</span></span><br><span class="line">        <span class="comment">//      &#125;</span></span><br><span class="line">        <span class="comment">//      return null;</span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;         <span class="comment">//kc是对象k的Class对象</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)  <span class="comment">//如果k没有实现Comparable接口或者compareTo方法返回的是0, 就递归的查找右子树的所有值</span></span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;                                          <span class="comment">// 如果右子树也没有, 就查找左子树.</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);                                     </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Calls find for root node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Tie-breaking utility for ordering insertions when equal</span></span><br><span class="line"><span class="comment">         * hashCodes and non-comparable. We don&#x27;t require a total</span></span><br><span class="line"><span class="comment">         * order, just a consistent insertion rule to maintain</span></span><br><span class="line"><span class="comment">         * equivalence across rebalancings. Tie-breaking further than</span></span><br><span class="line"><span class="comment">         * necessary simplifies testing a bit.                   //这个函数只有两个对象hash相同, compareTo相同(或者不支持compareTo方法)时在才会调用</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;   <span class="comment">//可以看成一个约定, 当两个对象hash相同, compareTo相同时, 通过内存中的位置规定了插入红黑树的方向. 是左孩子还是右孩子</span></span><br><span class="line">            <span class="keyword">int</span> d;                                   <span class="comment">//但是查找的时候不能这么做, 因为查找的时候可能是不同地址的相同对象, 如果插入时的对象和查找时给的对象相等, 但地址值不一样, 就会发生错误</span></span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||            <span class="comment">//查找的时候如果发生了hash相同, compareTo相同(或者不支持compareTo方法)的情况, 只能左右子树一起查, 不能根据这个tieBreakOrder方法只查一个子树</span></span><br><span class="line">                (d = a.getClass().getName().</span><br><span class="line">                 compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                     -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;                        <span class="comment">//这个方法虽然长, 但是完成的事情很简单, 只是在红黑树中找到x合适的位置(叶子节点)并插入</span></span><br><span class="line">            TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;                               <span class="comment">//至于插入后怎么旋转, 怎么改变红黑颜色, 就是balanceInsertion()方法的事情了</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">                x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;                               <span class="comment">//第一个节点作为头节点</span></span><br><span class="line">                    x.parent = <span class="keyword">null</span>;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    root = x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    K k = x.key;</span><br><span class="line">                    <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                        <span class="keyword">int</span> dir, ph;</span><br><span class="line">                        K pk = p.key;</span><br><span class="line">                        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                            dir = -<span class="number">1</span>;                       <span class="comment">// 又是熟悉的套路, 先根据hash确定在左子树还是右子树, hash相同在判断compareTo方法</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)                    <span class="comment">//compareTo相同或者没有compareTo方法, 就按照我们插入时的约定tieBreakOrder, 根据内存地址来判断</span></span><br><span class="line">                            dir = <span class="number">1</span>;                        <span class="comment">//如果a的内存地址小于等于b的内存地址, 就把a放到b的左子树中的某个叶子节点的位置. 这里的dir是方向direction的意思. 即走左子树还是右子树</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                            dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;             <span class="comment">//注意到这个==null, 表示只能在叶子节点上插入</span></span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            root = balanceInsertion(root, x);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns a list of non-TreeNodes replacing those linked from</span></span><br><span class="line"><span class="comment">         * this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;          <span class="comment">//这个方法就很简单了</span></span><br><span class="line">            Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tl.next = p;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Tree version of putVal.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;                          <span class="comment">//和treeify方法差不多, 都是先判断hash值, 再用compareTo, 这两个都判断不出来的时候, 就要左右两棵子树都查找了</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;                                   <span class="comment">//一旦进行左子树和右子树的全树扫描, 就把search标记为true. </span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)                               <span class="comment">//下一次再出现这样的情况, 就说明树里面没有k这个键, 按照tieBreakOrder的规则找个地方插入就可以了</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;                      <span class="comment">//这里直接返回键k对应的TreeNode, 由调用这个方法的调用者把p的value改成v.</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;      <span class="comment">//如果搜索到红黑树的叶子节点还是没有找到, 就在叶子节点插入新的TreeNode x.</span></span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;                            <span class="comment">//至于插入后红黑树的旋转和重新染色, 要调用静态方法balanceInsertion()了</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);    <span class="comment">//同时, 要把x加入到双向链表中, 放到x.parent的后面</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes the given node, that must be present before this call.</span></span><br><span class="line"><span class="comment">         * This is messier than typical red-black deletion code because we</span></span><br><span class="line"><span class="comment">         * cannot swap the contents of an interior node with a leaf</span></span><br><span class="line"><span class="comment">         * successor that is pinned by &quot;next&quot; pointers that are accessible       //由于TreeNode除了left, 和right指针外, 还有prev和next指针. 所以不能像普通的红黑树一样删除节点</span></span><br><span class="line"><span class="comment">         * independently during traversal. So instead we swap the tree</span></span><br><span class="line"><span class="comment">         * linkages. If the current tree appears to have too few nodes,</span></span><br><span class="line"><span class="comment">         * the bin is converted back to a plain bin. (The test triggers</span></span><br><span class="line"><span class="comment">         * somewhere between 2 and 6 nodes, depending on tree structure).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,          //从tree中移除当前的树节点<span class="keyword">this</span>.</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)            </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;          </span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;  <span class="comment">//first为桶中的第一个元素</span></span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;             <span class="comment">//这里的succ为当前节点的successor, pred为当前节点的predecessor</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)          <span class="comment">//如果删除了this之后整个树为空了就直接返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)   <span class="comment">//重置根节点</span></span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">                || (movable</span><br><span class="line">                    &amp;&amp; (root.right == <span class="keyword">null</span>         <span class="comment">//如果右子树是空, 左子树不会超过1个元素(因为是红黑树). 所以要非树化</span></span><br><span class="line">                        || (rl = root.left) == <span class="keyword">null</span>  <span class="comment">//如果左子树是空, 同样要非树化</span></span><br><span class="line">                        || rl.left == <span class="keyword">null</span>))) &#123;       <span class="comment">//如果左子树的左子树是空, 左子树的右子树不会超过1个元素, 所以左子树不会超过2个元素, 右子树自然不可能超过4个元素</span></span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;          <span class="comment">//p为要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;                                     <span class="comment">//第一种情况  p的左右子树都不为空</span></span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;                                        <span class="comment">//从右子树中找到右子树最小的节点s来替代即将要被删除的节点p</span></span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors      //交换s和p的颜色</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;                          <span class="comment">//提前备份s的右节点, 和p的父节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent                //如果s就是p的右孩子, 把s设置为p的父节点</span></span><br><span class="line">                    p.parent = s;                               </span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;                            <span class="comment">// 这一段是比较难想象的, 画个图会清楚很多. 博客 https://blog.csdn.net/anlian523/article/details/103649200 上面写的十分好 </span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;        <span class="comment">//p放到s的位置上, 这一段这么多的交换操作, 实际上就是为了交换s和p的位置</span></span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;                            <span class="comment">//        pp                                    pp</span></span><br><span class="line">                        <span class="keyword">else</span>                                       <span class="comment">//        /                                     /</span></span><br><span class="line">                            sp.right = p;                         <span class="comment">//        p                                     s</span></span><br><span class="line">                    &#125;                                            <span class="comment">//        / \                                   / \</span></span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)                 <span class="comment">//        pl  pr             变为               pl  pr</span></span><br><span class="line">                        pr.parent = s;                         <span class="comment">//            /                                     /</span></span><br><span class="line">                &#125;                                             <span class="comment">//            s                                     p</span></span><br><span class="line">                p.left = <span class="keyword">null</span>;                               <span class="comment">//              \                                     \</span></span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)                 <span class="comment">//                sr                                    sr</span></span><br><span class="line">                    sr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)                           <span class="comment">//然后将sr赋值给replacement</span></span><br><span class="line">                    pl.parent = s;</span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)                         <span class="comment">//第二种情况, p的右子树空, replacement = pl</span></span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)                        <span class="comment">//第三种情况, p的左子树空, replacement = pr</span></span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span>                                         <span class="comment">//第四种情况, p是叶子节点, replacement = p</span></span><br><span class="line">                replacement = p;</span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;                      <span class="comment">//将p从树中分离出来, 使得树中没有任何一个节点的指针指向p. (但是p的指针可能还指向树中的某些节点)</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;    <span class="comment">//replacement.parent一开始是指向p的, 现在指向p的父节点了</span></span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;                         <span class="comment">//pp的孩子也由p变为replacement了. 这样p就分离出来了</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                                                                                        <span class="comment">//p是红色就可以直接删, 不会影响红黑树结构</span></span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);        <span class="comment">//如果p为黑, 删掉p之后会引起红黑树不满足规则, 从root到任意一个叶子节点的黑色节点数量不变</span></span><br><span class="line">                                                                                        <span class="comment">//, 所以要进行调整, 而replacement就是要被调整的节点</span></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach            //断绝p和树中任何节点的关系</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment">         * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment">         * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;         <span class="comment">//和resize()方法中的思想差不多, 都是讲一棵树中的元素分为2组, 装到不同的桶中</span></span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)  // 如果high里也有节点，说明low和high二者的红黑树结构由于拆分都应该被破坏掉了，所以需要树化</span></span><br><span class="line">                    <span class="comment">//反之，如果high里没有节点，那说明所有节点都在low里面。又由于连接链表时是按照原顺序来的，而原顺序又保持了</span></span><br><span class="line">                    <span class="comment">//红黑树结构（前提节点都在一个桶里）。所以就不需要做树化操作了，因为红黑树结构没有破坏。</span></span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">        <span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;         <span class="comment">//左旋</span></span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;                                    <span class="comment">//     p                          pr</span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;                  <span class="comment">//    /  \                        / \</span></span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)                  <span class="comment">//    pl  pr            变为      p  rr       如果p.parent不存在, 说明新的根为pr, 肯定是黑色</span></span><br><span class="line">                    rl.parent = p;                                   <span class="comment">//         / \                   / \           </span></span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)             <span class="comment">//         rl rr                 pl rl</span></span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;               <span class="comment">//右旋</span></span><br><span class="line">                <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)              <span class="comment">//     p                          pl</span></span><br><span class="line">                    lr.parent = p;                               <span class="comment">//    /  \                        / \</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)         <span class="comment">//    pl  pr            变为      ll  p       如果p.parent不存在, 说明新的根为pl, 肯定是黑色</span></span><br><span class="line">                    (root = l).red = <span class="keyword">false</span>;                    <span class="comment">//    / \                             / \           </span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)                       <span class="comment">//   ll  lr                          lr  pr</span></span><br><span class="line">                    pp.right = l;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.left = l;</span><br><span class="line">                l.right = p;</span><br><span class="line">                p.parent = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,       //这个函数是修复插入节点之后的红黑树的, 而不是插入节点</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            x.red = <span class="keyword">true</span>;                                                  <span class="comment">//新插入的节点总是红的</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;                         <span class="comment">//如果插入的节点没有父节点, 就说明插入了根节点, 变为黑</span></span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)        <span class="comment">//插入的节点父节点是黑的, 或者x的爷爷是空, 直接插入即可</span></span><br><span class="line">                    <span class="keyword">return</span> root;                                      <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;                        <span class="comment">//下面开始重点了, xp是红, 并且是左孩子, xppr存在并且是红</span></span><br><span class="line">                    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;     <span class="comment">//            xpp(黑)                    xpp(红)            (这时候会问, 把xpp弄成红的了, 如果xppp是红的, 不就矛盾了吗)</span></span><br><span class="line">                        xppr.red = <span class="keyword">false</span>;                             <span class="comment">//           /      \                  /      \             (事实上, 开头有个for循环, 就是不断处理这种问题的, x = xpp就是这个循环的更新)</span></span><br><span class="line">                        xp.red = <span class="keyword">false</span>;                               <span class="comment">//         xp(红)   xppr(红)  --&gt;  xp(黑)   xppr(黑)</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;                               <span class="comment">//        /                         /</span></span><br><span class="line">                        x = xpp;                                      <span class="comment">//       x(红)                    x(红)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.right) &#123;                                  <span class="comment">//否则就要旋转了</span></span><br><span class="line">                            root = rotateLeft(root, x = xp);                       <span class="comment">//如果x是一个右孩子, 先把他弄成左孩子的父亲然后x指向旋转后的xp, 然后交换xp和xpp的颜色, 再旋转调成平衡. 如果x是左孩子, 直接旋转平衡即可   </span></span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;         <span class="comment">//  xpp(黑)                 xpp(黑)              xpp(黑)                  xpp(红)                    xp(黑)</span></span><br><span class="line">                        &#125;                                                            <span class="comment">//  /     \                  /   \                /    \                 /      \                    /     \</span></span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;                                           <span class="comment">//  xp(红)  xppl(?)  -&gt;     x(红) xppl(?)  -&gt;   xp(红)   xppl(?)   --&gt;   xp(黑)   xppl(?)     --&gt;    x(红)  xpp(红)           (在每个for循环中, x的深度就减少1, 直到根节点, 或者中途return)</span></span><br><span class="line">                            xp.red = <span class="keyword">false</span>;                                        <span class="comment">//  /   \                    /                   /                        /                           /         \</span></span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;                                    <span class="comment">//xpl(?)  x(红)              xp(红)              x(红)                    x(红)                       xpl(?)      xppl(?)</span></span><br><span class="line">                                <span class="comment">// xpp.red = true;                                  //                        /                   /                         /</span></span><br><span class="line">                                root = rotateRight(root, xpp);                  <span class="comment">//                          xpl(?)              xpl(?)                    xpl(?)                 </span></span><br><span class="line">                            &#125; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;                                                <span class="comment">// xp是右孩子的情况, 和上面的讨论类似, 就不写了, 画个图思路就清晰很多了. (手画二叉树实在是太麻烦了)</span></span><br><span class="line">                    <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                            root = rotateRight(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,          //这个函数是修复删节点之后的红黑树的, 而不是删除节点</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">                                                                               <span class="comment">//整个函数是一个循环过程，可能会经过若干次循环。不管是刚调用此函数的第一次循环，或者是以后的循环，</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;                              <span class="comment">//每次循环体刚开始时，x节点子树的黑节点数，肯定是比x的兄弟节点子树的黑节点数少1，这是由removeTreeNode函数来做保证的（由于删掉了一个黑色节点，所以黑节点数少1）</span></span><br><span class="line">                <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)                                  <span class="comment">//既然知道了x的黑节点数，比x的兄弟节点饿黑节点数少1，那么就需要通过调整来使得平衡。</span></span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;            <span class="comment">// 边界情况, 可以直接返回. (x是root, x是red) x是red直接把x变黑就可以了</span></span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;                   <span class="comment">// x是左孩子</span></span><br><span class="line">                    <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;        <span class="comment">//x的兄弟非空, 并且是红色的</span></span><br><span class="line">                        xpr.red = <span class="keyword">false</span>;                                          <span class="comment">//      xp(黑)                    xp(红)                xpr(黑)</span></span><br><span class="line">                        xp.red = <span class="keyword">true</span>;                                           <span class="comment">//      /    \         -&gt;         /    \        -&gt;      /     \</span></span><br><span class="line">                        root = rotateLeft(root, xp);                            <span class="comment">// x(黑,n-1)  xpr(红)        x(黑,n-1)  xpr(黑)         xp(红)  xprr(n)        至此只需要调节xp下面的两个节点不平衡的问题了, 进入下面的if</span></span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;       <span class="comment">//              / \                     /  \             /    \</span></span><br><span class="line">                    &#125;                                                         <span class="comment">//         xprl(n)  xprr(n)         xprl(n)  xprr(n)  x(黑,n-1) xprl(黑,n) </span></span><br><span class="line">                    <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)                                         <span class="comment">//括号中的n代表从当前节点走到尽头需要经历n个黑色节点. 从一开始c的子树就比兄弟子树的黑节点少1.</span></span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;             <span class="comment">// 剩下的不想画图了, 分类太多了, 在纸上画一画就出来了, 或者参考 https://blog.csdn.net/anlian523/article/details/103649200             </span></span><br><span class="line">                        <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;                          <span class="comment">//即    xp(红)            这种情况的处理办法. 要对xpr的子节点进行分类讨论</span></span><br><span class="line">                            (sl == <span class="keyword">null</span> || !sl.red)) &#123;                         <span class="comment">//      /     \</span></span><br><span class="line">                            xpr.red = <span class="keyword">true</span>;                                   <span class="comment">//  x(黑,n-1)  xpr(黑,n)</span></span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                                xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpr);</span><br><span class="line">                                xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                    <span class="keyword">null</span> : xp.right;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                                root = rotateLeft(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// symmetric                    //x是右孩子, 和上面的对称着来就可以了</span></span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                        xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                        <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                            (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                            xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">                                xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpl);</span><br><span class="line">                                xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                    <span class="keyword">null</span> : xp.left;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                                root = rotateRight(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Recursive invariant check</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;           <span class="comment">//查看红黑树是否还是合法的</span></span><br><span class="line">            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,      </span><br><span class="line">                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">            <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)                             <span class="comment">//查看双向链表是不是正确的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)            <span class="comment">//查看二叉树是不是正确的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))     <span class="comment">//查看是不是BST</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)  <span class="comment">//查看红黑节点是不是正确</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))                    <span class="comment">//递归地查询左右子树</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>1</title>
    <url>/2021/05/23/Others/1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/1970/01/01/%E9%9D%A2%E7%BB%8F/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%89%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>自我介绍</p>
<p>N个文件, 每个文件有序, 怎么合并成一个整体有序的文件? 时间空间复杂度是多少? (外部排序)</p>
<p>如何设计一个整数压缩算法? 一个整数数组, 用尽可能小的空间存放, 并且可以压缩完之后可以还原. (这个应该有专门的整数压缩算法, 但我不知道, 用之前学的霍夫曼编码构造了一下)</p>
<p>讲讲进程间通讯和线程间通讯的方法?</p>
<p>编程题, </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用数组实现队列</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> values[];</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">begin</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Queue(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    ++n;</span><br><span class="line">    values = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="built_in">size</span> = n;</span><br><span class="line">    <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Queue()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] values;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">end</span> == (<span class="built_in">begin</span> - <span class="number">1</span>) % <span class="built_in">size</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;FullQueue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">end</span> = (<span class="built_in">end</span> + <span class="number">1</span>) % <span class="built_in">size</span>;</span><br><span class="line">      values[<span class="built_in">end</span>] = a;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">end</span> == <span class="built_in">begin</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;EmptyQueue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">int</span> ret = values[<span class="built_in">begin</span>];</span><br><span class="line">      <span class="built_in">begin</span> = (<span class="built_in">begin</span> + <span class="number">1</span>) % <span class="built_in">size</span>;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
